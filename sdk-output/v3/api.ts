/* tslint:disable */
/* eslint-disable */
/**
 * IdentityNow V3 API
 * Use these APIs to interact with the IdentityNow platform to achieve repeatable, automated processes with greater scalability. We encourage you to join the SailPoint Developer Community forum at https://developer.sailpoint.com/discuss to connect with other developers using our APIs.
 *
 * The version of the OpenAPI document: 3.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from '../configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Access
 */
export interface Access {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof Access
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof Access
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Access
     */
    'displayName'?: string;
    /**
     * 
     * @type {DtoType}
     * @memberof Access
     */
    'type'?: DtoType;
    /**
     * 
     * @type {string}
     * @memberof Access
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface AccessAllOf
 */
export interface AccessAllOf {
    /**
     * 
     * @type {DtoType}
     * @memberof AccessAllOf
     */
    'type'?: DtoType;
    /**
     * 
     * @type {string}
     * @memberof AccessAllOf
     */
    'description'?: string | null;
}
/**
 * This is more of a complete representation of an access profile.  
 * @export
 * @interface AccessProfileDocument
 */
export interface AccessProfileDocument {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof AccessProfileDocument
     */
    'id': string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof AccessProfileDocument
     */
    'name': string;
    /**
     * 
     * @type {DocumentType}
     * @memberof AccessProfileDocument
     */
    '_type': DocumentType;
    /**
     * The description of the access item
     * @type {string}
     * @memberof AccessProfileDocument
     */
    'description'?: string;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof AccessProfileDocument
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof AccessProfileDocument
     */
    'modified'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof AccessProfileDocument
     */
    'synced'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof AccessProfileDocument
     */
    'enabled'?: boolean;
    /**
     * Indicates if the access can be requested
     * @type {boolean}
     * @memberof AccessProfileDocument
     */
    'requestable'?: boolean;
    /**
     * Indicates if comments are required when requesting access
     * @type {boolean}
     * @memberof AccessProfileDocument
     */
    'requestCommentsRequired'?: boolean;
    /**
     * 
     * @type {Owner}
     * @memberof AccessProfileDocument
     */
    'owner'?: Owner;
    /**
     * 
     * @type {Reference1}
     * @memberof AccessProfileDocument
     */
    'source'?: Reference1;
    /**
     * 
     * @type {Array<BaseEntitlement>}
     * @memberof AccessProfileDocument
     */
    'entitlements'?: Array<BaseEntitlement>;
    /**
     * 
     * @type {number}
     * @memberof AccessProfileDocument
     */
    'entitlementCount'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof AccessProfileDocument
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface AccessProfileDocumentAllOf
 */
export interface AccessProfileDocumentAllOf {
    /**
     * 
     * @type {Reference1}
     * @memberof AccessProfileDocumentAllOf
     */
    'source'?: Reference1;
    /**
     * 
     * @type {Array<BaseEntitlement>}
     * @memberof AccessProfileDocumentAllOf
     */
    'entitlements'?: Array<BaseEntitlement>;
    /**
     * 
     * @type {number}
     * @memberof AccessProfileDocumentAllOf
     */
    'entitlementCount'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof AccessProfileDocumentAllOf
     */
    'tags'?: Array<string>;
}
/**
 * EntitlementReference
 * @export
 * @interface AccessProfileEntitlement
 */
export interface AccessProfileEntitlement {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof AccessProfileEntitlement
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof AccessProfileEntitlement
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessProfileEntitlement
     */
    'displayName'?: string;
    /**
     * 
     * @type {DtoType}
     * @memberof AccessProfileEntitlement
     */
    'type'?: DtoType;
    /**
     * 
     * @type {string}
     * @memberof AccessProfileEntitlement
     */
    'description'?: string | null;
    /**
     * 
     * @type {Reference1}
     * @memberof AccessProfileEntitlement
     */
    'source'?: Reference1;
    /**
     * 
     * @type {boolean}
     * @memberof AccessProfileEntitlement
     */
    'privileged'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AccessProfileEntitlement
     */
    'attribute'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessProfileEntitlement
     */
    'value'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AccessProfileEntitlement
     */
    'standalone'?: boolean;
}
/**
 * Role
 * @export
 * @interface AccessProfileRole
 */
export interface AccessProfileRole {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof AccessProfileRole
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof AccessProfileRole
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessProfileRole
     */
    'displayName'?: string;
    /**
     * 
     * @type {DtoType}
     * @memberof AccessProfileRole
     */
    'type'?: DtoType;
    /**
     * 
     * @type {string}
     * @memberof AccessProfileRole
     */
    'description'?: string | null;
    /**
     * 
     * @type {DisplayReference}
     * @memberof AccessProfileRole
     */
    'owner'?: DisplayReference;
    /**
     * 
     * @type {boolean}
     * @memberof AccessProfileRole
     */
    'disabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AccessProfileRole
     */
    'revocable'?: boolean;
}
/**
 * This is a summary representation of an access profile.
 * @export
 * @interface AccessProfileSummary
 */
export interface AccessProfileSummary {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof AccessProfileSummary
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof AccessProfileSummary
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessProfileSummary
     */
    'displayName'?: string;
    /**
     * 
     * @type {DtoType}
     * @memberof AccessProfileSummary
     */
    'type'?: DtoType;
    /**
     * 
     * @type {string}
     * @memberof AccessProfileSummary
     */
    'description'?: string | null;
    /**
     * 
     * @type {Reference1}
     * @memberof AccessProfileSummary
     */
    'source'?: Reference1;
    /**
     * 
     * @type {DisplayReference}
     * @memberof AccessProfileSummary
     */
    'owner'?: DisplayReference;
    /**
     * 
     * @type {boolean}
     * @memberof AccessProfileSummary
     */
    'revocable'?: boolean;
}
/**
 * 
 * @export
 * @interface AccessProfileSummaryAllOf
 */
export interface AccessProfileSummaryAllOf {
    /**
     * 
     * @type {Reference1}
     * @memberof AccessProfileSummaryAllOf
     */
    'source'?: Reference1;
    /**
     * 
     * @type {DisplayReference}
     * @memberof AccessProfileSummaryAllOf
     */
    'owner'?: DisplayReference;
    /**
     * 
     * @type {boolean}
     * @memberof AccessProfileSummaryAllOf
     */
    'revocable'?: boolean;
}
/**
 * 
 * @export
 * @interface AccessRequest
 */
export interface AccessRequest {
    /**
     * A list of Identity IDs for whom the Access is requested. If it\'s a Revoke request, there can only be one Identity ID.
     * @type {Array<string>}
     * @memberof AccessRequest
     */
    'requestedFor': Array<string>;
    /**
     * 
     * @type {AccessRequestType}
     * @memberof AccessRequest
     */
    'requestType'?: AccessRequestType;
    /**
     * 
     * @type {Array<AccessRequestItem>}
     * @memberof AccessRequest
     */
    'requestedItems': Array<AccessRequestItem>;
    /**
     * Arbitrary key-value pairs. They will never be processed by the IdentityNow system but will be returned on associated APIs such as /account-activities.
     * @type {{ [key: string]: string; }}
     * @memberof AccessRequest
     */
    'clientMetadata'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface AccessRequestConfig
 */
export interface AccessRequestConfig {
    /**
     * If true, then approvals must be processed by external system.
     * @type {boolean}
     * @memberof AccessRequestConfig
     */
    'approvalsMustBeExternal'?: boolean;
    /**
     * If true and requester and reviewer are the same, then automatically approve the approval.
     * @type {boolean}
     * @memberof AccessRequestConfig
     */
    'autoApprovalEnabled'?: boolean;
    /**
     * 
     * @type {RequestOnBehalfOfConfig}
     * @memberof AccessRequestConfig
     */
    'requestOnBehalfOfConfig'?: RequestOnBehalfOfConfig;
    /**
     * 
     * @type {ApprovalReminderAndEscalationConfig}
     * @memberof AccessRequestConfig
     */
    'approvalReminderAndEscalationConfig'?: ApprovalReminderAndEscalationConfig;
    /**
     * 
     * @type {EntitlementRequestConfig}
     * @memberof AccessRequestConfig
     */
    'entitlementRequestConfig'?: EntitlementRequestConfig;
}
/**
 * 
 * @export
 * @interface AccessRequestItem
 */
export interface AccessRequestItem {
    /**
     * The type of the item being requested.
     * @type {string}
     * @memberof AccessRequestItem
     */
    'type': AccessRequestItemTypeEnum;
    /**
     * ID of Role, Access Profile or Entitlement being requested.
     * @type {string}
     * @memberof AccessRequestItem
     */
    'id': string;
    /**
     * Comment provided by requester. * Comment is required when the request is of type Revoke Access. 
     * @type {string}
     * @memberof AccessRequestItem
     */
    'comment'?: string;
    /**
     * Arbitrary key-value pairs. They will never be processed by the IdentityNow system but will be returned on associated APIs such as /account-activities and /access-request-status.
     * @type {{ [key: string]: string; }}
     * @memberof AccessRequestItem
     */
    'clientMetadata'?: { [key: string]: string; };
    /**
     * The date the role or access profile is no longer assigned to the specified identity. * Specify a date in the future. * The current SLA for the deprovisioning is 24 hours. * This date can be modified to either extend or decrease the duration of access item assignments for the specified identity. * Currently it is not supported for entitlements. 
     * @type {string}
     * @memberof AccessRequestItem
     */
    'removeDate'?: string;
}

export const AccessRequestItemTypeEnum = {
    AccessProfile: 'ACCESS_PROFILE',
    Role: 'ROLE',
    Entitlement: 'ENTITLEMENT'
} as const;

export type AccessRequestItemTypeEnum = typeof AccessRequestItemTypeEnum[keyof typeof AccessRequestItemTypeEnum];

/**
 * Provides additional details about this access request phase.
 * @export
 * @interface AccessRequestPhases
 */
export interface AccessRequestPhases {
    /**
     * The time that this phase started.
     * @type {string}
     * @memberof AccessRequestPhases
     */
    'started'?: string;
    /**
     * The time that this phase finished.
     * @type {string}
     * @memberof AccessRequestPhases
     */
    'finished'?: string;
    /**
     * The name of this phase.
     * @type {string}
     * @memberof AccessRequestPhases
     */
    'name'?: string;
    /**
     * The state of this phase.
     * @type {string}
     * @memberof AccessRequestPhases
     */
    'state'?: AccessRequestPhasesStateEnum;
    /**
     * The state of this phase.
     * @type {string}
     * @memberof AccessRequestPhases
     */
    'result'?: AccessRequestPhasesResultEnum;
    /**
     * A reference to another object on the RequestedItemStatus that contains more details about the phase. Note that for the Provisioning phase, this will be empty if there are no manual work items.
     * @type {string}
     * @memberof AccessRequestPhases
     */
    'phaseReference'?: string;
}

export const AccessRequestPhasesStateEnum = {
    Pending: 'PENDING',
    Executing: 'EXECUTING',
    Completed: 'COMPLETED',
    Cancelled: 'CANCELLED'
} as const;

export type AccessRequestPhasesStateEnum = typeof AccessRequestPhasesStateEnum[keyof typeof AccessRequestPhasesStateEnum];
export const AccessRequestPhasesResultEnum = {
    Successful: 'SUCCESSFUL',
    Failed: 'FAILED'
} as const;

export type AccessRequestPhasesResultEnum = typeof AccessRequestPhasesResultEnum[keyof typeof AccessRequestPhasesResultEnum];

/**
 * Access request type. Defaults to GRANT_ACCESS. REVOKE_ACCESS type can only have a single Identity ID in the requestedFor field. Currently REVOKE_ACCESS is not supported for entitlements.
 * @export
 * @enum {string}
 */

export const AccessRequestType = {
    GrantAccess: 'GRANT_ACCESS',
    RevokeAccess: 'REVOKE_ACCESS'
} as const;

export type AccessRequestType = typeof AccessRequestType[keyof typeof AccessRequestType];


/**
 * 
 * @export
 * @interface AccessReviewItem
 */
export interface AccessReviewItem {
    /**
     * 
     * @type {AccessSummary}
     * @memberof AccessReviewItem
     */
    'accessSummary'?: AccessSummary;
    /**
     * 
     * @type {CertificationIdentitySummary}
     * @memberof AccessReviewItem
     */
    'identitySummary'?: CertificationIdentitySummary;
    /**
     * The review item\'s id
     * @type {string}
     * @memberof AccessReviewItem
     */
    'id'?: string;
    /**
     * Whether the review item is complete
     * @type {boolean}
     * @memberof AccessReviewItem
     */
    'completed'?: boolean;
    /**
     * Indicates whether the review item is for new access to a source
     * @type {boolean}
     * @memberof AccessReviewItem
     */
    'newAccess'?: boolean;
    /**
     * 
     * @type {CertificationDecision}
     * @memberof AccessReviewItem
     */
    'decision'?: CertificationDecision;
    /**
     * Comments for this review item
     * @type {string}
     * @memberof AccessReviewItem
     */
    'comments'?: string | null;
}
/**
 * 
 * @export
 * @interface AccessReviewReassignment
 */
export interface AccessReviewReassignment {
    /**
     * 
     * @type {Array<ReassignReference>}
     * @memberof AccessReviewReassignment
     */
    'reassign': Array<ReassignReference>;
    /**
     * The ID of the identity to which the certification is reassigned
     * @type {string}
     * @memberof AccessReviewReassignment
     */
    'reassignTo': string;
    /**
     * The reason comment for why the reassign was made
     * @type {string}
     * @memberof AccessReviewReassignment
     */
    'reason': string;
}
/**
 * An object holding the access that is being reviewed
 * @export
 * @interface AccessSummary
 */
export interface AccessSummary {
    /**
     * 
     * @type {AccessSummaryAccess}
     * @memberof AccessSummary
     */
    'access'?: AccessSummaryAccess;
    /**
     * 
     * @type {ReviewableEntitlement}
     * @memberof AccessSummary
     */
    'entitlement'?: ReviewableEntitlement | null;
    /**
     * 
     * @type {ReviewableAccessProfile}
     * @memberof AccessSummary
     */
    'accessProfile'?: ReviewableAccessProfile;
    /**
     * 
     * @type {ReviewableRole}
     * @memberof AccessSummary
     */
    'role'?: ReviewableRole | null;
}
/**
 * 
 * @export
 * @interface AccessSummaryAccess
 */
export interface AccessSummaryAccess {
    /**
     * 
     * @type {DtoType}
     * @memberof AccessSummaryAccess
     */
    'type'?: DtoType;
    /**
     * The ID of the item being certified
     * @type {string}
     * @memberof AccessSummaryAccess
     */
    'id'?: string;
    /**
     * The name of the item being certified
     * @type {string}
     * @memberof AccessSummaryAccess
     */
    'name'?: string;
}
/**
 * Access type of API Client indicating online or offline use
 * @export
 * @enum {string}
 */

export const AccessType = {
    Online: 'ONLINE',
    Offline: 'OFFLINE'
} as const;

export type AccessType = typeof AccessType[keyof typeof AccessType];


/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * System-generated unique ID of the Object
     * @type {string}
     * @memberof Account
     */
    'id'?: string;
    /**
     * Name of the Object
     * @type {string}
     * @memberof Account
     */
    'name': string;
    /**
     * Creation date of the Object
     * @type {string}
     * @memberof Account
     */
    'created'?: string;
    /**
     * Last modification date of the Object
     * @type {string}
     * @memberof Account
     */
    'modified'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'sourceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'identityId'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof Account
     */
    'attributes'?: { [key: string]: any; };
    /**
     * Indicates if this account is from an authoritative source
     * @type {boolean}
     * @memberof Account
     */
    'authoritative'?: boolean;
    /**
     * A description of the account
     * @type {string}
     * @memberof Account
     */
    'description'?: string | null;
    /**
     * Indicates if the account is currently disabled
     * @type {boolean}
     * @memberof Account
     */
    'disabled'?: boolean;
    /**
     * Indicates if the account is currently locked
     * @type {boolean}
     * @memberof Account
     */
    'locked'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'nativeIdentity'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Account
     */
    'systemAccount'?: boolean;
    /**
     * Indicates if this account is not correlated to an identity
     * @type {boolean}
     * @memberof Account
     */
    'uncorrelated'?: boolean;
    /**
     * The unique ID of the account as determined by the account schema
     * @type {string}
     * @memberof Account
     */
    'uuid'?: string;
    /**
     * Indicates if the account has been manually correlated to an identity
     * @type {boolean}
     * @memberof Account
     */
    'manuallyCorrelated'?: boolean;
    /**
     * Indicates if the account has entitlements
     * @type {boolean}
     * @memberof Account
     */
    'hasEntitlements'?: boolean;
}
/**
 * Object for specifying Actions to be performed on a specified list of sources\' account.
 * @export
 * @interface AccountAction
 */
export interface AccountAction {
    /**
     * Describes if action will be enabled or disabled
     * @type {string}
     * @memberof AccountAction
     */
    'action'?: AccountActionActionEnum;
    /**
     * List of unique source IDs. The sources must have the ENABLE feature or flat file source. See \"/sources\" endpoint for source features.
     * @type {Set<string>}
     * @memberof AccountAction
     */
    'sourceIds'?: Set<string>;
}

export const AccountActionActionEnum = {
    Enable: 'ENABLE',
    Disable: 'DISABLE'
} as const;

export type AccountActionActionEnum = typeof AccountActionActionEnum[keyof typeof AccountActionActionEnum];

/**
 * 
 * @export
 * @interface AccountActivity
 */
export interface AccountActivity {
    /**
     * Id of the account activity
     * @type {string}
     * @memberof AccountActivity
     */
    'id'?: string;
    /**
     * The name of the activity
     * @type {string}
     * @memberof AccountActivity
     */
    'name'?: string;
    /**
     * When the activity was first created
     * @type {string}
     * @memberof AccountActivity
     */
    'created'?: string;
    /**
     * When the activity was last modified
     * @type {string}
     * @memberof AccountActivity
     */
    'modified'?: string | null;
    /**
     * When the activity was completed
     * @type {string}
     * @memberof AccountActivity
     */
    'completed'?: string | null;
    /**
     * 
     * @type {CompletionStatus}
     * @memberof AccountActivity
     */
    'completionStatus'?: CompletionStatus | null;
    /**
     * The type of action the activity performed.  Please see the following list of types.  This list may grow over time.  - CloudAutomated - IdentityAttributeUpdate - appRequest - LifecycleStateChange - AccountStateUpdate - AccountAttributeUpdate - CloudPasswordRequest - Attribute Synchronization Refresh - Certification - Identity Refresh - Lifecycle Change Refresh   [Learn more here](https://documentation.sailpoint.com/saas/help/search/searchable-fields.html#searching-account-activity-data). 
     * @type {string}
     * @memberof AccountActivity
     */
    'type'?: string | null;
    /**
     * 
     * @type {IdentitySummary}
     * @memberof AccountActivity
     */
    'requesterIdentitySummary'?: IdentitySummary | null;
    /**
     * 
     * @type {IdentitySummary}
     * @memberof AccountActivity
     */
    'targetIdentitySummary'?: IdentitySummary | null;
    /**
     * A list of error messages, if any, that were encountered.
     * @type {Array<string>}
     * @memberof AccountActivity
     */
    'errors'?: Array<string> | null;
    /**
     * A list of warning messages, if any, that were encountered.
     * @type {Array<string>}
     * @memberof AccountActivity
     */
    'warnings'?: Array<string> | null;
    /**
     * Individual actions performed as part of this account activity
     * @type {Array<AccountActivityItem>}
     * @memberof AccountActivity
     */
    'items'?: Array<AccountActivityItem>;
    /**
     * 
     * @type {ExecutionStatus}
     * @memberof AccountActivity
     */
    'executionStatus'?: ExecutionStatus;
    /**
     * Arbitrary key-value pairs, if any were included in the corresponding access request
     * @type {{ [key: string]: string; }}
     * @memberof AccountActivity
     */
    'clientMetadata'?: { [key: string]: string; } | null;
}
/**
 * AccountActivity
 * @export
 * @interface AccountActivityDocument
 */
export interface AccountActivityDocument {
    /**
     * 
     * @type {string}
     * @memberof AccountActivityDocument
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AccountActivityDocument
     */
    'name': string;
    /**
     * 
     * @type {DocumentType}
     * @memberof AccountActivityDocument
     */
    '_type': DocumentType;
    /**
     * The type of action that this activity performed
     * @type {string}
     * @memberof AccountActivityDocument
     */
    'action'?: string;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof AccountActivityDocument
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof AccountActivityDocument
     */
    'modified'?: string | null;
    /**
     * The current stage of the activity
     * @type {string}
     * @memberof AccountActivityDocument
     */
    'stage'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountActivityDocument
     */
    'origin'?: string | null;
    /**
     * the current status of the activity
     * @type {string}
     * @memberof AccountActivityDocument
     */
    'status'?: string;
    /**
     * 
     * @type {AccountSource}
     * @memberof AccountActivityDocument
     */
    'requester'?: AccountSource;
    /**
     * 
     * @type {AccountSource}
     * @memberof AccountActivityDocument
     */
    'recipient'?: AccountSource;
    /**
     * 
     * @type {string}
     * @memberof AccountActivityDocument
     */
    'trackingNumber'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AccountActivityDocument
     */
    'errors'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof AccountActivityDocument
     */
    'warnings'?: Array<string> | null;
    /**
     * 
     * @type {Array<Approval>}
     * @memberof AccountActivityDocument
     */
    'approvals'?: Array<Approval>;
    /**
     * 
     * @type {Array<OriginalRequest>}
     * @memberof AccountActivityDocument
     */
    'originalRequests'?: Array<OriginalRequest>;
    /**
     * 
     * @type {Array<ExpansionItem>}
     * @memberof AccountActivityDocument
     */
    'expansionItems'?: Array<ExpansionItem>;
    /**
     * 
     * @type {Array<AccountRequest>}
     * @memberof AccountActivityDocument
     */
    'accountRequests'?: Array<AccountRequest>;
    /**
     * 
     * @type {string}
     * @memberof AccountActivityDocument
     */
    'sources'?: string;
}
/**
 * 
 * @export
 * @interface AccountActivityItem
 */
export interface AccountActivityItem {
    /**
     * Item id
     * @type {string}
     * @memberof AccountActivityItem
     */
    'id'?: string;
    /**
     * Human-readable display name of item
     * @type {string}
     * @memberof AccountActivityItem
     */
    'name'?: string;
    /**
     * Date and time item was requested
     * @type {string}
     * @memberof AccountActivityItem
     */
    'requested'?: string;
    /**
     * 
     * @type {WorkItemState}
     * @memberof AccountActivityItem
     */
    'approvalStatus'?: WorkItemState;
    /**
     * 
     * @type {ProvisioningState}
     * @memberof AccountActivityItem
     */
    'provisioningStatus'?: ProvisioningState;
    /**
     * 
     * @type {Comment}
     * @memberof AccountActivityItem
     */
    'requesterComment'?: Comment | null;
    /**
     * 
     * @type {IdentitySummary}
     * @memberof AccountActivityItem
     */
    'reviewerIdentitySummary'?: IdentitySummary | null;
    /**
     * 
     * @type {Comment}
     * @memberof AccountActivityItem
     */
    'reviewerComment'?: Comment | null;
    /**
     * 
     * @type {AccountActivityItemOperation}
     * @memberof AccountActivityItem
     */
    'operation'?: AccountActivityItemOperation;
    /**
     * Attribute to which account activity applies
     * @type {string}
     * @memberof AccountActivityItem
     */
    'attribute'?: string | null;
    /**
     * Value of attribute
     * @type {string}
     * @memberof AccountActivityItem
     */
    'value'?: string | null;
    /**
     * Native identity in the target system to which the account activity applies
     * @type {string}
     * @memberof AccountActivityItem
     */
    'nativeIdentity'?: string | null;
    /**
     * Id of Source to which account activity applies
     * @type {string}
     * @memberof AccountActivityItem
     */
    'sourceId'?: string;
    /**
     * 
     * @type {AccountRequestInfo}
     * @memberof AccountActivityItem
     */
    'accountRequestInfo'?: AccountRequestInfo | null;
    /**
     * Arbitrary key-value pairs, if any were included in the corresponding access request item
     * @type {{ [key: string]: string; }}
     * @memberof AccountActivityItem
     */
    'clientMetadata'?: { [key: string]: string; } | null;
    /**
     * The date the role or access profile is no longer assigned to the specified identity.
     * @type {string}
     * @memberof AccountActivityItem
     */
    'removeDate'?: string | null;
}
/**
 * Represents an operation in an account activity item
 * @export
 * @enum {string}
 */

export const AccountActivityItemOperation = {
    Add: 'ADD',
    Create: 'CREATE',
    Modify: 'MODIFY',
    Delete: 'DELETE',
    Disable: 'DISABLE',
    Enable: 'ENABLE',
    Unlock: 'UNLOCK',
    Lock: 'LOCK',
    Remove: 'REMOVE'
} as const;

export type AccountActivityItemOperation = typeof AccountActivityItemOperation[keyof typeof AccountActivityItemOperation];


/**
 * AccountActivity
 * @export
 * @interface AccountActivitySearchedItem
 */
export interface AccountActivitySearchedItem {
    /**
     * 
     * @type {string}
     * @memberof AccountActivitySearchedItem
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AccountActivitySearchedItem
     */
    'name': string;
    /**
     * 
     * @type {DocumentType}
     * @memberof AccountActivitySearchedItem
     */
    '_type': DocumentType;
    /**
     * The type of action that this activity performed
     * @type {string}
     * @memberof AccountActivitySearchedItem
     */
    'action'?: string;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof AccountActivitySearchedItem
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof AccountActivitySearchedItem
     */
    'modified'?: string | null;
    /**
     * The current stage of the activity
     * @type {string}
     * @memberof AccountActivitySearchedItem
     */
    'stage'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountActivitySearchedItem
     */
    'origin'?: string | null;
    /**
     * the current status of the activity
     * @type {string}
     * @memberof AccountActivitySearchedItem
     */
    'status'?: string;
    /**
     * 
     * @type {AccountSource}
     * @memberof AccountActivitySearchedItem
     */
    'requester'?: AccountSource;
    /**
     * 
     * @type {AccountSource}
     * @memberof AccountActivitySearchedItem
     */
    'recipient'?: AccountSource;
    /**
     * 
     * @type {string}
     * @memberof AccountActivitySearchedItem
     */
    'trackingNumber'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AccountActivitySearchedItem
     */
    'errors'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof AccountActivitySearchedItem
     */
    'warnings'?: Array<string> | null;
    /**
     * 
     * @type {Array<Approval>}
     * @memberof AccountActivitySearchedItem
     */
    'approvals'?: Array<Approval>;
    /**
     * 
     * @type {Array<OriginalRequest>}
     * @memberof AccountActivitySearchedItem
     */
    'originalRequests'?: Array<OriginalRequest>;
    /**
     * 
     * @type {Array<ExpansionItem>}
     * @memberof AccountActivitySearchedItem
     */
    'expansionItems'?: Array<ExpansionItem>;
    /**
     * 
     * @type {Array<AccountRequest>}
     * @memberof AccountActivitySearchedItem
     */
    'accountRequests'?: Array<AccountRequest>;
    /**
     * 
     * @type {string}
     * @memberof AccountActivitySearchedItem
     */
    'sources'?: string;
}
/**
 * 
 * @export
 * @interface AccountActivitySearchedItemAllOf
 */
export interface AccountActivitySearchedItemAllOf {
    /**
     * The type of action that this activity performed
     * @type {string}
     * @memberof AccountActivitySearchedItemAllOf
     */
    'action'?: string;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof AccountActivitySearchedItemAllOf
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof AccountActivitySearchedItemAllOf
     */
    'modified'?: string | null;
    /**
     * The current stage of the activity
     * @type {string}
     * @memberof AccountActivitySearchedItemAllOf
     */
    'stage'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountActivitySearchedItemAllOf
     */
    'origin'?: string | null;
    /**
     * the current status of the activity
     * @type {string}
     * @memberof AccountActivitySearchedItemAllOf
     */
    'status'?: string;
    /**
     * 
     * @type {AccountSource}
     * @memberof AccountActivitySearchedItemAllOf
     */
    'requester'?: AccountSource;
    /**
     * 
     * @type {AccountSource}
     * @memberof AccountActivitySearchedItemAllOf
     */
    'recipient'?: AccountSource;
    /**
     * 
     * @type {string}
     * @memberof AccountActivitySearchedItemAllOf
     */
    'trackingNumber'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AccountActivitySearchedItemAllOf
     */
    'errors'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof AccountActivitySearchedItemAllOf
     */
    'warnings'?: Array<string> | null;
    /**
     * 
     * @type {Array<Approval>}
     * @memberof AccountActivitySearchedItemAllOf
     */
    'approvals'?: Array<Approval>;
    /**
     * 
     * @type {Array<OriginalRequest>}
     * @memberof AccountActivitySearchedItemAllOf
     */
    'originalRequests'?: Array<OriginalRequest>;
    /**
     * 
     * @type {Array<ExpansionItem>}
     * @memberof AccountActivitySearchedItemAllOf
     */
    'expansionItems'?: Array<ExpansionItem>;
    /**
     * 
     * @type {Array<AccountRequest>}
     * @memberof AccountActivitySearchedItemAllOf
     */
    'accountRequests'?: Array<AccountRequest>;
    /**
     * 
     * @type {string}
     * @memberof AccountActivitySearchedItemAllOf
     */
    'sources'?: string;
}
/**
 * 
 * @export
 * @interface AccountAllOf
 */
export interface AccountAllOf {
    /**
     * 
     * @type {string}
     * @memberof AccountAllOf
     */
    'sourceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountAllOf
     */
    'identityId'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof AccountAllOf
     */
    'attributes'?: { [key: string]: any; };
    /**
     * Indicates if this account is from an authoritative source
     * @type {boolean}
     * @memberof AccountAllOf
     */
    'authoritative'?: boolean;
    /**
     * A description of the account
     * @type {string}
     * @memberof AccountAllOf
     */
    'description'?: string | null;
    /**
     * Indicates if the account is currently disabled
     * @type {boolean}
     * @memberof AccountAllOf
     */
    'disabled'?: boolean;
    /**
     * Indicates if the account is currently locked
     * @type {boolean}
     * @memberof AccountAllOf
     */
    'locked'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AccountAllOf
     */
    'nativeIdentity'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AccountAllOf
     */
    'systemAccount'?: boolean;
    /**
     * Indicates if this account is not correlated to an identity
     * @type {boolean}
     * @memberof AccountAllOf
     */
    'uncorrelated'?: boolean;
    /**
     * The unique ID of the account as determined by the account schema
     * @type {string}
     * @memberof AccountAllOf
     */
    'uuid'?: string;
    /**
     * Indicates if the account has been manually correlated to an identity
     * @type {boolean}
     * @memberof AccountAllOf
     */
    'manuallyCorrelated'?: boolean;
    /**
     * Indicates if the account has entitlements
     * @type {boolean}
     * @memberof AccountAllOf
     */
    'hasEntitlements'?: boolean;
}
/**
 * 
 * @export
 * @interface AccountAttribute
 */
export interface AccountAttribute {
    /**
     * A reference to the source to search for the account
     * @type {string}
     * @memberof AccountAttribute
     */
    'sourceName': string;
    /**
     * The name of the attribute on the account to return. This should match the name of the account attribute name visible in the user interface, or on the source schema.
     * @type {string}
     * @memberof AccountAttribute
     */
    'attributeName': string;
    /**
     * The value of this configuration is a string name of the attribute to use when determining the ordering of returned accounts when there are multiple entries
     * @type {string}
     * @memberof AccountAttribute
     */
    'accountSortAttribute'?: string;
    /**
     * The value of this configuration is a boolean (true/false). Controls the order of the sort when there are multiple accounts. If not defined, the transform will default to false (ascending order)
     * @type {boolean}
     * @memberof AccountAttribute
     */
    'accountSortDescending'?: boolean;
    /**
     * The value of this configuration is a boolean (true/false). Controls which account to source a value from for an attribute.  If this flag is set to true, the transform returns the value from the first account in the list, even if it is null. If it is set to false, the transform returns the first non-null value. If not defined, the transform will default to false
     * @type {boolean}
     * @memberof AccountAttribute
     */
    'accountReturnFirstLink'?: boolean;
    /**
     * This expression queries the database to narrow search results. The value of this configuration is a sailpoint.object.Filter expression and used when searching against the database.  The default filter will always include the source and identity, and any subsequent expressions will be combined in an AND operation to the existing search criteria. Only certain searchable attributes are available:  - `nativeIdentity` - the Account ID  - `displayName` - the Account Name  - `entitlements` - a boolean value to determine if the account has entitlements
     * @type {string}
     * @memberof AccountAttribute
     */
    'accountFilter'?: string;
    /**
     * This expression is used to search and filter accounts in memory. The value of this configuration is a sailpoint.object.Filter expression and used when searching against the returned resultset.  All account attributes are available for filtering as this operation is performed in memory.
     * @type {string}
     * @memberof AccountAttribute
     */
    'accountPropertyFilter'?: string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof AccountAttribute
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof AccountAttribute
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface AccountAttributes
 */
export interface AccountAttributes {
    /**
     * The schema attribute values for the account
     * @type {{ [key: string]: any; }}
     * @memberof AccountAttributes
     */
    'attributes': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface AccountAttributesCreate
 */
export interface AccountAttributesCreate {
    /**
     * 
     * @type {AccountAttributesCreateAttributes}
     * @memberof AccountAttributesCreate
     */
    'attributes': AccountAttributesCreateAttributes;
}
/**
 * The schema attribute values for the account
 * @export
 * @interface AccountAttributesCreateAttributes
 */
export interface AccountAttributesCreateAttributes {
    [key: string]: string | any;

    /**
     * Target source to create an account
     * @type {string}
     * @memberof AccountAttributesCreateAttributes
     */
    'sourceId': string;
}
/**
 * Account
 * @export
 * @interface AccountDocument
 */
export interface AccountDocument {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof AccountDocument
     */
    'id': string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof AccountDocument
     */
    'name': string;
    /**
     * 
     * @type {DocumentType}
     * @memberof AccountDocument
     */
    '_type': DocumentType;
    /**
     * The ID of the account
     * @type {string}
     * @memberof AccountDocument
     */
    'accountId'?: string;
    /**
     * 
     * @type {AccountSource}
     * @memberof AccountDocument
     */
    'source'?: AccountSource;
    /**
     * Indicates if the account is disabled
     * @type {boolean}
     * @memberof AccountDocument
     */
    'disabled'?: boolean;
    /**
     * Indicates if the account is locked
     * @type {boolean}
     * @memberof AccountDocument
     */
    'locked'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AccountDocument
     */
    'privileged'?: boolean;
    /**
     * Indicates if the account has been manually correlated to an identity
     * @type {boolean}
     * @memberof AccountDocument
     */
    'manuallyCorrelated'?: boolean;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof AccountDocument
     */
    'passwordLastSet'?: string | null;
    /**
     * a map or dictionary of key/value pairs
     * @type {{ [key: string]: any; }}
     * @memberof AccountDocument
     */
    'entitlementAttributes'?: { [key: string]: any; } | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof AccountDocument
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof AccountDocument
     */
    'modified'?: string | null;
    /**
     * a map or dictionary of key/value pairs
     * @type {{ [key: string]: any; }}
     * @memberof AccountDocument
     */
    'attributes'?: { [key: string]: any; };
    /**
     * 
     * @type {DisplayReference}
     * @memberof AccountDocument
     */
    'identity'?: DisplayReference;
    /**
     * 
     * @type {Array<AccessProfileEntitlement>}
     * @memberof AccountDocument
     */
    'access'?: Array<AccessProfileEntitlement>;
    /**
     * The number of entitlements assigned to the account
     * @type {number}
     * @memberof AccountDocument
     */
    'entitlementCount'?: number;
    /**
     * Indicates if the account is not correlated to an identity
     * @type {boolean}
     * @memberof AccountDocument
     */
    'uncorrelated'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof AccountDocument
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface AccountDocumentAllOf
 */
export interface AccountDocumentAllOf {
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof AccountDocumentAllOf
     */
    'modified'?: string | null;
    /**
     * a map or dictionary of key/value pairs
     * @type {{ [key: string]: any; }}
     * @memberof AccountDocumentAllOf
     */
    'attributes'?: { [key: string]: any; };
    /**
     * 
     * @type {DisplayReference}
     * @memberof AccountDocumentAllOf
     */
    'identity'?: DisplayReference;
    /**
     * 
     * @type {Array<AccessProfileEntitlement>}
     * @memberof AccountDocumentAllOf
     */
    'access'?: Array<AccessProfileEntitlement>;
    /**
     * The number of entitlements assigned to the account
     * @type {number}
     * @memberof AccountDocumentAllOf
     */
    'entitlementCount'?: number;
    /**
     * Indicates if the account is not correlated to an identity
     * @type {boolean}
     * @memberof AccountDocumentAllOf
     */
    'uncorrelated'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof AccountDocumentAllOf
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface AccountRequest
 */
export interface AccountRequest {
    /**
     * Unique ID of the account
     * @type {string}
     * @memberof AccountRequest
     */
    'accountId'?: string;
    /**
     * 
     * @type {Array<AttributeRequest>}
     * @memberof AccountRequest
     */
    'attributeRequests'?: Array<AttributeRequest>;
    /**
     * The operation that was performed
     * @type {string}
     * @memberof AccountRequest
     */
    'op'?: string;
    /**
     * 
     * @type {AccountSource}
     * @memberof AccountRequest
     */
    'provisioningTarget'?: AccountSource;
    /**
     * 
     * @type {AccountRequestResult}
     * @memberof AccountRequest
     */
    'result'?: AccountRequestResult;
    /**
     * 
     * @type {AccountSource}
     * @memberof AccountRequest
     */
    'source'?: AccountSource;
}
/**
 * If an account activity item is associated with an access request, captures details of that request.
 * @export
 * @interface AccountRequestInfo
 */
export interface AccountRequestInfo {
    /**
     * Id of requested object
     * @type {string}
     * @memberof AccountRequestInfo
     */
    'requestedObjectId'?: string;
    /**
     * Human-readable name of requested object
     * @type {string}
     * @memberof AccountRequestInfo
     */
    'requestedObjectName'?: string;
    /**
     * 
     * @type {RequestableObjectType}
     * @memberof AccountRequestInfo
     */
    'requestedObjectType'?: RequestableObjectType;
}
/**
 * 
 * @export
 * @interface AccountRequestResult
 */
export interface AccountRequestResult {
    /**
     * 
     * @type {Array<string>}
     * @memberof AccountRequestResult
     */
    'errors'?: Array<string>;
    /**
     * The status of the account request
     * @type {string}
     * @memberof AccountRequestResult
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountRequestResult
     */
    'ticketId'?: string | null;
}
/**
 * 
 * @export
 * @interface AccountSource
 */
export interface AccountSource {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof AccountSource
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof AccountSource
     */
    'name'?: string;
    /**
     * the type of source returned
     * @type {string}
     * @memberof AccountSource
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface AccountSourceAllOf
 */
export interface AccountSourceAllOf {
    /**
     * the type of source returned
     * @type {string}
     * @memberof AccountSourceAllOf
     */
    'type'?: string;
}
/**
 * Request used for account enable/disable
 * @export
 * @interface AccountToggleRequest
 */
export interface AccountToggleRequest {
    /**
     * If set, an external process validates that the user wants to proceed with this request.
     * @type {string}
     * @memberof AccountToggleRequest
     */
    'externalVerificationId'?: string;
    /**
     * If set, provisioning updates the account attribute at the source.   This option is used when the account is not synced to ensure the attribute is updated. Providing \'true\' for an unlocked account will add and process \'Unlock\' operation by the workflow.
     * @type {boolean}
     * @memberof AccountToggleRequest
     */
    'forceProvisioning'?: boolean;
}
/**
 * Request used for account unlock
 * @export
 * @interface AccountUnlockRequest
 */
export interface AccountUnlockRequest {
    /**
     * If set, an external process validates that the user wants to proceed with this request.
     * @type {string}
     * @memberof AccountUnlockRequest
     */
    'externalVerificationId'?: string;
    /**
     * If set, the IDN account is unlocked after the workflow completes.
     * @type {boolean}
     * @memberof AccountUnlockRequest
     */
    'unlockIDNAccount'?: boolean;
    /**
     * If set, provisioning updates the account attribute at the source.   This option is used when the account is not synced to ensure the attribute is updated.
     * @type {boolean}
     * @memberof AccountUnlockRequest
     */
    'forceProvisioning'?: boolean;
}
/**
 * Accounts async response containing details on started async process
 * @export
 * @interface AccountsAsyncResult
 */
export interface AccountsAsyncResult {
    /**
     * id of the task
     * @type {string}
     * @memberof AccountsAsyncResult
     */
    'id': string;
}
/**
 * Aggregation
 * @export
 * @interface Aggregation
 */
export interface Aggregation {
    /**
     * 
     * @type {string}
     * @memberof Aggregation
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Aggregation
     */
    'name': string;
    /**
     * 
     * @type {DocumentType}
     * @memberof Aggregation
     */
    '_type': DocumentType;
    /**
     * 
     * @type {string}
     * @memberof Aggregation
     */
    'status'?: string;
    /**
     * 
     * @type {number}
     * @memberof Aggregation
     */
    'duration'?: number;
    /**
     * 
     * @type {number}
     * @memberof Aggregation
     */
    'avgDuration'?: number;
    /**
     * 
     * @type {number}
     * @memberof Aggregation
     */
    'changedAccounts'?: number;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof Aggregation
     */
    'nextScheduled'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof Aggregation
     */
    'startTime'?: string | null;
    /**
     * John Doe
     * @type {string}
     * @memberof Aggregation
     */
    'sourceOwner'?: string;
}
/**
 * 
 * @export
 * @interface AggregationAllOf
 */
export interface AggregationAllOf {
    /**
     * 
     * @type {string}
     * @memberof AggregationAllOf
     */
    'status'?: string;
    /**
     * 
     * @type {number}
     * @memberof AggregationAllOf
     */
    'duration'?: number;
    /**
     * 
     * @type {number}
     * @memberof AggregationAllOf
     */
    'avgDuration'?: number;
    /**
     * 
     * @type {number}
     * @memberof AggregationAllOf
     */
    'changedAccounts'?: number;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof AggregationAllOf
     */
    'nextScheduled'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof AggregationAllOf
     */
    'startTime'?: string | null;
    /**
     * John Doe
     * @type {string}
     * @memberof AggregationAllOf
     */
    'sourceOwner'?: string;
}
/**
 * Aggregation
 * @export
 * @interface AggregationDocument
 */
export interface AggregationDocument {
    /**
     * 
     * @type {string}
     * @memberof AggregationDocument
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AggregationDocument
     */
    'name': string;
    /**
     * 
     * @type {DocumentType}
     * @memberof AggregationDocument
     */
    '_type': DocumentType;
    /**
     * 
     * @type {string}
     * @memberof AggregationDocument
     */
    'status'?: string;
    /**
     * 
     * @type {number}
     * @memberof AggregationDocument
     */
    'duration'?: number;
    /**
     * 
     * @type {number}
     * @memberof AggregationDocument
     */
    'avgDuration'?: number;
    /**
     * 
     * @type {number}
     * @memberof AggregationDocument
     */
    'changedAccounts'?: number;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof AggregationDocument
     */
    'nextScheduled'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof AggregationDocument
     */
    'startTime'?: string | null;
    /**
     * John Doe
     * @type {string}
     * @memberof AggregationDocument
     */
    'sourceOwner'?: string;
}
/**
 * 
 * @export
 * @interface AggregationResult
 */
export interface AggregationResult {
    /**
     * The document containing the results of the aggregation. This document is controlled by Elasticsearch and depends on the type of aggregation query that is run.  See Elasticsearch [Aggregations](https://www.elastic.co/guide/en/elasticsearch/reference/5.2/search-aggregations.html) documentation for information. 
     * @type {object}
     * @memberof AggregationResult
     */
    'aggregations'?: object;
    /**
     * The results of the aggregation search query. 
     * @type {Array<SearchDocument>}
     * @memberof AggregationResult
     */
    'hits'?: Array<SearchDocument>;
}
/**
 * Enum representing the currently available query languages for aggregations, which are used to perform calculations or groupings on search results.  Additional values may be added in the future without notice. 
 * @export
 * @enum {string}
 */

export const AggregationType = {
    Dsl: 'DSL',
    Sailpoint: 'SAILPOINT'
} as const;

export type AggregationType = typeof AggregationType[keyof typeof AggregationType];


/**
 * 
 * @export
 * @interface Aggregations
 */
export interface Aggregations {
    /**
     * 
     * @type {NestedAggregation}
     * @memberof Aggregations
     */
    'nested'?: NestedAggregation;
    /**
     * 
     * @type {MetricAggregation}
     * @memberof Aggregations
     */
    'metric'?: MetricAggregation;
    /**
     * 
     * @type {FilterAggregation}
     * @memberof Aggregations
     */
    'filter'?: FilterAggregation;
    /**
     * 
     * @type {BucketAggregation}
     * @memberof Aggregations
     */
    'bucket'?: BucketAggregation;
}
/**
 * 
 * @export
 * @interface App
 */
export interface App {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof App
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof App
     */
    'name'?: string;
    /**
     * 
     * @type {Reference1}
     * @memberof App
     */
    'source'?: Reference1;
    /**
     * 
     * @type {AppAllOfAccount}
     * @memberof App
     */
    'account'?: AppAllOfAccount;
}
/**
 * 
 * @export
 * @interface AppAllOf
 */
export interface AppAllOf {
    /**
     * 
     * @type {Reference1}
     * @memberof AppAllOf
     */
    'source'?: Reference1;
    /**
     * 
     * @type {AppAllOfAccount}
     * @memberof AppAllOf
     */
    'account'?: AppAllOfAccount;
}
/**
 * 
 * @export
 * @interface AppAllOfAccount
 */
export interface AppAllOfAccount {
    /**
     * The SailPoint generated unique ID
     * @type {string}
     * @memberof AppAllOfAccount
     */
    'id'?: string;
    /**
     * The account ID generated by the source
     * @type {string}
     * @memberof AppAllOfAccount
     */
    'accountId'?: string;
}
/**
 * 
 * @export
 * @interface Approval
 */
export interface Approval {
    /**
     * 
     * @type {Array<ApprovalComment>}
     * @memberof Approval
     */
    'comments'?: Array<ApprovalComment>;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof Approval
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof Approval
     */
    'modified'?: string | null;
    /**
     * 
     * @type {AccountSource}
     * @memberof Approval
     */
    'owner'?: AccountSource;
    /**
     * The result of the approval
     * @type {string}
     * @memberof Approval
     */
    'result'?: string;
    /**
     * 
     * @type {string}
     * @memberof Approval
     */
    'type'?: string | null;
}
/**
 * 
 * @export
 * @interface ApprovalComment
 */
export interface ApprovalComment {
    /**
     * The comment text
     * @type {string}
     * @memberof ApprovalComment
     */
    'comment'?: string;
    /**
     * The name of the commenter
     * @type {string}
     * @memberof ApprovalComment
     */
    'commenter'?: string;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof ApprovalComment
     */
    'date'?: string | null;
}
/**
 * 
 * @export
 * @interface ApprovalForwardHistory
 */
export interface ApprovalForwardHistory {
    /**
     * Display name of approver that forwarded the approval.
     * @type {string}
     * @memberof ApprovalForwardHistory
     */
    'oldApproverName'?: string;
    /**
     * Display name of approver to whom the approval was forwarded.
     * @type {string}
     * @memberof ApprovalForwardHistory
     */
    'newApproverName'?: string;
    /**
     * Comment made by old approver when forwarding.
     * @type {string}
     * @memberof ApprovalForwardHistory
     */
    'comment'?: string;
    /**
     * Time at which approval was forwarded.
     * @type {string}
     * @memberof ApprovalForwardHistory
     */
    'modified'?: string;
}
/**
 * 
 * @export
 * @interface ApprovalItemDetails
 */
export interface ApprovalItemDetails {
    /**
     * ID of the approval item
     * @type {string}
     * @memberof ApprovalItemDetails
     */
    'id'?: string;
    /**
     * The account referenced by the approval item
     * @type {string}
     * @memberof ApprovalItemDetails
     */
    'account'?: string;
    /**
     * The name the application/source
     * @type {string}
     * @memberof ApprovalItemDetails
     */
    'application'?: string;
    /**
     * The name of the attribute
     * @type {string}
     * @memberof ApprovalItemDetails
     */
    'attributeName'?: string;
    /**
     * The operation of the attribute
     * @type {string}
     * @memberof ApprovalItemDetails
     */
    'attributeOperation'?: string;
    /**
     * The value of the attribute
     * @type {string}
     * @memberof ApprovalItemDetails
     */
    'attributeValue'?: string;
    /**
     * 
     * @type {WorkItemState}
     * @memberof ApprovalItemDetails
     */
    'state'?: WorkItemState;
}
/**
 * 
 * @export
 * @interface ApprovalItems
 */
export interface ApprovalItems {
    /**
     * ID of the approval item
     * @type {string}
     * @memberof ApprovalItems
     */
    'id'?: string;
    /**
     * The account referenced by the approval item
     * @type {string}
     * @memberof ApprovalItems
     */
    'account'?: string;
    /**
     * The name the application/source
     * @type {string}
     * @memberof ApprovalItems
     */
    'application'?: string;
    /**
     * The name of the attribute
     * @type {string}
     * @memberof ApprovalItems
     */
    'attributeName'?: string;
    /**
     * The operation of the attribute
     * @type {string}
     * @memberof ApprovalItems
     */
    'attributeOperation'?: string;
    /**
     * The value of the attribute
     * @type {string}
     * @memberof ApprovalItems
     */
    'attributeValue'?: string;
    /**
     * 
     * @type {WorkItemState}
     * @memberof ApprovalItems
     */
    'state'?: WorkItemState;
}
/**
 * 
 * @export
 * @interface ApprovalReminderAndEscalationConfig
 */
export interface ApprovalReminderAndEscalationConfig {
    /**
     * Number of days to wait before the first reminder. If no reminders are configured, then this is the number of days to wait before escalation.
     * @type {number}
     * @memberof ApprovalReminderAndEscalationConfig
     */
    'daysUntilEscalation'?: number;
    /**
     * Number of days to wait between reminder notifications.
     * @type {number}
     * @memberof ApprovalReminderAndEscalationConfig
     */
    'daysBetweenReminders'?: number;
    /**
     * Maximum number of reminder notification to send to the reviewer before approval escalation.
     * @type {number}
     * @memberof ApprovalReminderAndEscalationConfig
     */
    'maxReminders'?: number;
    /**
     * 
     * @type {IdentityReferenceWithNameAndEmail}
     * @memberof ApprovalReminderAndEscalationConfig
     */
    'fallbackApproverRef'?: IdentityReferenceWithNameAndEmail | null;
}
/**
 * Describes the individual or group that is responsible for an approval step.
 * @export
 * @enum {string}
 */

export const ApprovalScheme = {
    AppOwner: 'APP_OWNER',
    SourceOwner: 'SOURCE_OWNER',
    Manager: 'MANAGER',
    RoleOwner: 'ROLE_OWNER',
    AccessProfileOwner: 'ACCESS_PROFILE_OWNER',
    GovernanceGroup: 'GOVERNANCE_GROUP'
} as const;

export type ApprovalScheme = typeof ApprovalScheme[keyof typeof ApprovalScheme];


/**
 * Enum representing the non-employee request approval status
 * @export
 * @enum {string}
 */

export const ApprovalStatus = {
    Approved: 'APPROVED',
    Rejected: 'REJECTED',
    Pending: 'PENDING',
    NotReady: 'NOT_READY',
    Cancelled: 'CANCELLED'
} as const;

export type ApprovalStatus = typeof ApprovalStatus[keyof typeof ApprovalStatus];


/**
 * 
 * @export
 * @interface ApprovalStatusDto
 */
export interface ApprovalStatusDto {
    /**
     * True if the request for this item was forwarded from one owner to another.
     * @type {boolean}
     * @memberof ApprovalStatusDto
     */
    'forwarded'?: boolean;
    /**
     * 
     * @type {BaseReferenceDto}
     * @memberof ApprovalStatusDto
     */
    'originalOwner'?: BaseReferenceDto;
    /**
     * 
     * @type {BaseReferenceDto}
     * @memberof ApprovalStatusDto
     */
    'currentOwner'?: BaseReferenceDto;
    /**
     * 
     * @type {BaseReferenceDto}
     * @memberof ApprovalStatusDto
     */
    'reviewedBy'?: BaseReferenceDto;
    /**
     * Time at which item was modified.
     * @type {string}
     * @memberof ApprovalStatusDto
     */
    'modified'?: string;
    /**
     * 
     * @type {ManualWorkItemState}
     * @memberof ApprovalStatusDto
     */
    'status'?: ManualWorkItemState;
    /**
     * 
     * @type {ApprovalScheme}
     * @memberof ApprovalStatusDto
     */
    'scheme'?: ApprovalScheme;
    /**
     * If the request failed, includes any error messages that were generated.
     * @type {Array<ErrorMessageDto>}
     * @memberof ApprovalStatusDto
     */
    'errorMessages'?: Array<ErrorMessageDto>;
    /**
     * Comment, if any, provided by the approver.
     * @type {string}
     * @memberof ApprovalStatusDto
     */
    'comment'?: string;
    /**
     * The date the role or access profile is no longer assigned to the specified identity.
     * @type {string}
     * @memberof ApprovalStatusDto
     */
    'removeDate'?: string;
}
/**
 * 
 * @export
 * @interface ApprovalSummary
 */
export interface ApprovalSummary {
    /**
     * The number of pending access requests approvals.
     * @type {number}
     * @memberof ApprovalSummary
     */
    'pending'?: number;
    /**
     * The number of approved access requests approvals.
     * @type {number}
     * @memberof ApprovalSummary
     */
    'approved'?: number;
    /**
     * The number of rejected access requests approvals.
     * @type {number}
     * @memberof ApprovalSummary
     */
    'rejected'?: number;
}
/**
 * 
 * @export
 * @interface AttributeDefinition
 */
export interface AttributeDefinition {
    /**
     * The name of the attribute.
     * @type {string}
     * @memberof AttributeDefinition
     */
    'name'?: string;
    /**
     * 
     * @type {AttributeDefinitionType}
     * @memberof AttributeDefinition
     */
    'type'?: AttributeDefinitionType;
    /**
     * 
     * @type {AttributeDefinitionSchema}
     * @memberof AttributeDefinition
     */
    'schema'?: AttributeDefinitionSchema;
    /**
     * A human-readable description of the attribute.
     * @type {string}
     * @memberof AttributeDefinition
     */
    'description'?: string;
    /**
     * Flag indicating whether or not the attribute is multi-valued.
     * @type {boolean}
     * @memberof AttributeDefinition
     */
    'isMultiValued'?: boolean;
    /**
     * Flag indicating whether or not the attribute is an entitlement.
     * @type {boolean}
     * @memberof AttributeDefinition
     */
    'isEntitlement'?: boolean;
    /**
     * Flag indicating whether or not the attribute represents a group. This can only be `true` if `isEntitlement` is also `true` **and** there is a schema defined for the attribute.. 
     * @type {boolean}
     * @memberof AttributeDefinition
     */
    'isGroup'?: boolean;
}
/**
 * A reference to the schema on the source to the attribute values map to.
 * @export
 * @interface AttributeDefinitionSchema
 */
export interface AttributeDefinitionSchema {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof AttributeDefinitionSchema
     */
    'type'?: AttributeDefinitionSchemaTypeEnum;
    /**
     * The object ID this reference applies to.
     * @type {string}
     * @memberof AttributeDefinitionSchema
     */
    'id'?: string;
    /**
     * The human-readable display name of the object.
     * @type {string}
     * @memberof AttributeDefinitionSchema
     */
    'name'?: string;
}

export const AttributeDefinitionSchemaTypeEnum = {
    ConnectorSchema: 'CONNECTOR_SCHEMA'
} as const;

export type AttributeDefinitionSchemaTypeEnum = typeof AttributeDefinitionSchemaTypeEnum[keyof typeof AttributeDefinitionSchemaTypeEnum];

/**
 * The underlying type of the value which an AttributeDefinition represents.
 * @export
 * @enum {string}
 */

export const AttributeDefinitionType = {
    String: 'STRING',
    Long: 'LONG',
    Int: 'INT',
    Boolean: 'BOOLEAN'
} as const;

export type AttributeDefinitionType = typeof AttributeDefinitionType[keyof typeof AttributeDefinitionType];


/**
 * 
 * @export
 * @interface AttributeRequest
 */
export interface AttributeRequest {
    /**
     * The attribute name
     * @type {string}
     * @memberof AttributeRequest
     */
    'name'?: string;
    /**
     * The operation to perform
     * @type {string}
     * @memberof AttributeRequest
     */
    'op'?: string;
    /**
     * The value of the attribute
     * @type {string}
     * @memberof AttributeRequest
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface Base64Decode
 */
export interface Base64Decode {
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Base64Decode
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Base64Decode
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface Base64Encode
 */
export interface Base64Encode {
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Base64Encode
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Base64Encode
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface BaseAccess
 */
export interface BaseAccess {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof BaseAccess
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof BaseAccess
     */
    'name'?: string;
    /**
     * The description of the access item
     * @type {string}
     * @memberof BaseAccess
     */
    'description'?: string;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof BaseAccess
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof BaseAccess
     */
    'modified'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof BaseAccess
     */
    'synced'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof BaseAccess
     */
    'enabled'?: boolean;
    /**
     * Indicates if the access can be requested
     * @type {boolean}
     * @memberof BaseAccess
     */
    'requestable'?: boolean;
    /**
     * Indicates if comments are required when requesting access
     * @type {boolean}
     * @memberof BaseAccess
     */
    'requestCommentsRequired'?: boolean;
    /**
     * 
     * @type {Owner}
     * @memberof BaseAccess
     */
    'owner'?: Owner;
}
/**
 * 
 * @export
 * @interface BaseAccessAllOf
 */
export interface BaseAccessAllOf {
    /**
     * The description of the access item
     * @type {string}
     * @memberof BaseAccessAllOf
     */
    'description'?: string;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof BaseAccessAllOf
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof BaseAccessAllOf
     */
    'modified'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof BaseAccessAllOf
     */
    'synced'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof BaseAccessAllOf
     */
    'enabled'?: boolean;
    /**
     * Indicates if the access can be requested
     * @type {boolean}
     * @memberof BaseAccessAllOf
     */
    'requestable'?: boolean;
    /**
     * Indicates if comments are required when requesting access
     * @type {boolean}
     * @memberof BaseAccessAllOf
     */
    'requestCommentsRequired'?: boolean;
    /**
     * 
     * @type {Owner}
     * @memberof BaseAccessAllOf
     */
    'owner'?: Owner;
}
/**
 * 
 * @export
 * @interface BaseAccount
 */
export interface BaseAccount {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof BaseAccount
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof BaseAccount
     */
    'name'?: string;
    /**
     * The ID of the account
     * @type {string}
     * @memberof BaseAccount
     */
    'accountId'?: string;
    /**
     * 
     * @type {AccountSource}
     * @memberof BaseAccount
     */
    'source'?: AccountSource;
    /**
     * Indicates if the account is disabled
     * @type {boolean}
     * @memberof BaseAccount
     */
    'disabled'?: boolean;
    /**
     * Indicates if the account is locked
     * @type {boolean}
     * @memberof BaseAccount
     */
    'locked'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BaseAccount
     */
    'privileged'?: boolean;
    /**
     * Indicates if the account has been manually correlated to an identity
     * @type {boolean}
     * @memberof BaseAccount
     */
    'manuallyCorrelated'?: boolean;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof BaseAccount
     */
    'passwordLastSet'?: string | null;
    /**
     * a map or dictionary of key/value pairs
     * @type {{ [key: string]: any; }}
     * @memberof BaseAccount
     */
    'entitlementAttributes'?: { [key: string]: any; } | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof BaseAccount
     */
    'created'?: string | null;
}
/**
 * 
 * @export
 * @interface BaseAccountAllOf
 */
export interface BaseAccountAllOf {
    /**
     * The ID of the account
     * @type {string}
     * @memberof BaseAccountAllOf
     */
    'accountId'?: string;
    /**
     * 
     * @type {AccountSource}
     * @memberof BaseAccountAllOf
     */
    'source'?: AccountSource;
    /**
     * Indicates if the account is disabled
     * @type {boolean}
     * @memberof BaseAccountAllOf
     */
    'disabled'?: boolean;
    /**
     * Indicates if the account is locked
     * @type {boolean}
     * @memberof BaseAccountAllOf
     */
    'locked'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BaseAccountAllOf
     */
    'privileged'?: boolean;
    /**
     * Indicates if the account has been manually correlated to an identity
     * @type {boolean}
     * @memberof BaseAccountAllOf
     */
    'manuallyCorrelated'?: boolean;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof BaseAccountAllOf
     */
    'passwordLastSet'?: string | null;
    /**
     * a map or dictionary of key/value pairs
     * @type {{ [key: string]: any; }}
     * @memberof BaseAccountAllOf
     */
    'entitlementAttributes'?: { [key: string]: any; } | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof BaseAccountAllOf
     */
    'created'?: string | null;
}
/**
 * 
 * @export
 * @interface BaseCommonDto
 */
export interface BaseCommonDto {
    /**
     * System-generated unique ID of the Object
     * @type {string}
     * @memberof BaseCommonDto
     */
    'id'?: string;
    /**
     * Name of the Object
     * @type {string}
     * @memberof BaseCommonDto
     */
    'name': string;
    /**
     * Creation date of the Object
     * @type {string}
     * @memberof BaseCommonDto
     */
    'created'?: string;
    /**
     * Last modification date of the Object
     * @type {string}
     * @memberof BaseCommonDto
     */
    'modified'?: string;
}
/**
 * 
 * @export
 * @interface BaseDocument
 */
export interface BaseDocument {
    /**
     * 
     * @type {string}
     * @memberof BaseDocument
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BaseDocument
     */
    'name': string;
    /**
     * 
     * @type {DocumentType}
     * @memberof BaseDocument
     */
    '_type': DocumentType;
}
/**
 * 
 * @export
 * @interface BaseEntitlement
 */
export interface BaseEntitlement {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof BaseEntitlement
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof BaseEntitlement
     */
    'name'?: string;
    /**
     * A description of the entitlement
     * @type {string}
     * @memberof BaseEntitlement
     */
    'description'?: string;
    /**
     * The name of the entitlement attribute
     * @type {string}
     * @memberof BaseEntitlement
     */
    'attribute'?: string;
    /**
     * The value of the entitlement
     * @type {string}
     * @memberof BaseEntitlement
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface BaseEntitlementAllOf
 */
export interface BaseEntitlementAllOf {
    /**
     * A description of the entitlement
     * @type {string}
     * @memberof BaseEntitlementAllOf
     */
    'description'?: string;
    /**
     * The name of the entitlement attribute
     * @type {string}
     * @memberof BaseEntitlementAllOf
     */
    'attribute'?: string;
    /**
     * The value of the entitlement
     * @type {string}
     * @memberof BaseEntitlementAllOf
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface BaseReferenceDto
 */
export interface BaseReferenceDto {
    /**
     * 
     * @type {DtoType}
     * @memberof BaseReferenceDto
     */
    'type'?: DtoType;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof BaseReferenceDto
     */
    'id'?: string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof BaseReferenceDto
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface Bound
 */
export interface Bound {
    /**
     * The value of the range\'s endpoint.
     * @type {string}
     * @memberof Bound
     */
    'value': string;
    /**
     * Indicates if the endpoint is included in the range.
     * @type {boolean}
     * @memberof Bound
     */
    'inclusive'?: boolean;
}
/**
 * The bucket to group the results of the aggregation query by.
 * @export
 * @interface BucketAggregation
 */
export interface BucketAggregation {
    /**
     * The name of the bucket aggregate to be included in the result.
     * @type {string}
     * @memberof BucketAggregation
     */
    'name': string;
    /**
     * 
     * @type {BucketType}
     * @memberof BucketAggregation
     */
    'type'?: BucketType;
    /**
     * The field to bucket on. Prefix the field name with \'@\' to reference a nested object.
     * @type {string}
     * @memberof BucketAggregation
     */
    'field': string;
    /**
     * Maximum number of buckets to include.
     * @type {number}
     * @memberof BucketAggregation
     */
    'size'?: number;
    /**
     * Minimum number of documents a bucket should have.
     * @type {number}
     * @memberof BucketAggregation
     */
    'minDocCount'?: number;
}
/**
 * Enum representing the currently supported bucket aggregation types. Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */

export const BucketType = {
    Terms: 'TERMS'
} as const;

export type BucketType = typeof BucketType[keyof typeof BucketType];


/**
 * 
 * @export
 * @interface Campaign
 */
export interface Campaign {
    /**
     * The unique ID of the campaign.
     * @type {string}
     * @memberof Campaign
     */
    'id': string;
    /**
     * The name of the campaign.
     * @type {string}
     * @memberof Campaign
     */
    'name': string;
    /**
     * The type of object that is being referenced.
     * @type {string}
     * @memberof Campaign
     */
    'type': CampaignTypeEnum;
    /**
     * The type of the campaign.
     * @type {string}
     * @memberof Campaign
     */
    'campaignType': CampaignCampaignTypeEnum;
    /**
     * The description of the campaign set by the admin who created it.
     * @type {string}
     * @memberof Campaign
     */
    'description': string | null;
}

export const CampaignTypeEnum = {
    Campaign: 'CAMPAIGN'
} as const;

export type CampaignTypeEnum = typeof CampaignTypeEnum[keyof typeof CampaignTypeEnum];
export const CampaignCampaignTypeEnum = {
    Manager: 'MANAGER',
    SourceOwner: 'SOURCE_OWNER',
    Search: 'SEARCH'
} as const;

export type CampaignCampaignTypeEnum = typeof CampaignCampaignTypeEnum[keyof typeof CampaignCampaignTypeEnum];

/**
 * 
 * @export
 * @interface CampaignReference
 */
export interface CampaignReference {
    /**
     * The unique ID of the campaign.
     * @type {string}
     * @memberof CampaignReference
     */
    'id': string;
    /**
     * The name of the campaign.
     * @type {string}
     * @memberof CampaignReference
     */
    'name': string;
    /**
     * The type of object that is being referenced.
     * @type {string}
     * @memberof CampaignReference
     */
    'type': CampaignReferenceTypeEnum;
    /**
     * The type of the campaign.
     * @type {string}
     * @memberof CampaignReference
     */
    'campaignType': CampaignReferenceCampaignTypeEnum;
    /**
     * The description of the campaign set by the admin who created it.
     * @type {string}
     * @memberof CampaignReference
     */
    'description': string | null;
}

export const CampaignReferenceTypeEnum = {
    Campaign: 'CAMPAIGN'
} as const;

export type CampaignReferenceTypeEnum = typeof CampaignReferenceTypeEnum[keyof typeof CampaignReferenceTypeEnum];
export const CampaignReferenceCampaignTypeEnum = {
    Manager: 'MANAGER',
    SourceOwner: 'SOURCE_OWNER',
    Search: 'SEARCH'
} as const;

export type CampaignReferenceCampaignTypeEnum = typeof CampaignReferenceCampaignTypeEnum[keyof typeof CampaignReferenceCampaignTypeEnum];

/**
 * Request body payload for cancel access request endpoint.
 * @export
 * @interface CancelAccessRequest
 */
export interface CancelAccessRequest {
    /**
     * ID of the account activity object corresponding to the access request.
     * @type {string}
     * @memberof CancelAccessRequest
     */
    'accountActivityId': string;
    /**
     * Reason for cancelling the pending access request.
     * @type {string}
     * @memberof CancelAccessRequest
     */
    'comment': string;
}
/**
 * Provides additional details for a request that has been cancelled.
 * @export
 * @interface CancelledRequestDetails
 */
export interface CancelledRequestDetails {
    /**
     * Comment made by the owner when cancelling the associated request.
     * @type {string}
     * @memberof CancelledRequestDetails
     */
    'comment'?: string;
    /**
     * 
     * @type {BaseReferenceDto}
     * @memberof CancelledRequestDetails
     */
    'owner'?: BaseReferenceDto;
    /**
     * Date comment was added by the owner when cancelling the associated request
     * @type {string}
     * @memberof CancelledRequestDetails
     */
    'modified'?: string;
}
/**
 * 
 * @export
 * @interface Certification
 */
export interface Certification {
    /**
     * id of the certification
     * @type {string}
     * @memberof Certification
     */
    'id'?: string;
    /**
     * name of the certification
     * @type {string}
     * @memberof Certification
     */
    'name'?: string;
    /**
     * 
     * @type {CampaignReference}
     * @memberof Certification
     */
    'campaign'?: CampaignReference;
    /**
     * Have all decisions been made?
     * @type {boolean}
     * @memberof Certification
     */
    'completed'?: boolean;
    /**
     * The number of identities for whom all decisions have been made and are complete.
     * @type {number}
     * @memberof Certification
     */
    'identitiesCompleted'?: number;
    /**
     * The total number of identities in the Certification, both complete and incomplete.
     * @type {number}
     * @memberof Certification
     */
    'identitiesTotal'?: number;
    /**
     * created date
     * @type {string}
     * @memberof Certification
     */
    'created'?: string;
    /**
     * modified date
     * @type {string}
     * @memberof Certification
     */
    'modified'?: string;
    /**
     * The number of approve/revoke/acknowledge decisions that have been made.
     * @type {number}
     * @memberof Certification
     */
    'decisionsMade'?: number;
    /**
     * The total number of approve/revoke/acknowledge decisions.
     * @type {number}
     * @memberof Certification
     */
    'decisionsTotal'?: number;
    /**
     * The due date of the certification.
     * @type {string}
     * @memberof Certification
     */
    'due'?: string;
    /**
     * The date the reviewer signed off on the Certification.
     * @type {string}
     * @memberof Certification
     */
    'signed'?: string | null;
    /**
     * 
     * @type {Reviewer}
     * @memberof Certification
     */
    'reviewer'?: Reviewer;
    /**
     * 
     * @type {Reassignment}
     * @memberof Certification
     */
    'reassignment'?: Reassignment | null;
    /**
     * Identifies if the certification has an error
     * @type {boolean}
     * @memberof Certification
     */
    'hasErrors'?: boolean;
    /**
     * Description of the certification error
     * @type {string}
     * @memberof Certification
     */
    'errorMessage'?: string | null;
    /**
     * 
     * @type {CertificationPhase}
     * @memberof Certification
     */
    'phase'?: CertificationPhase;
}
/**
 * The decision to approve or revoke the review item
 * @export
 * @enum {string}
 */

export const CertificationDecision = {
    Approve: 'APPROVE',
    Revoke: 'REVOKE'
} as const;

export type CertificationDecision = typeof CertificationDecision[keyof typeof CertificationDecision];


/**
 * 
 * @export
 * @interface CertificationIdentitySummary
 */
export interface CertificationIdentitySummary {
    /**
     * The ID of the identity summary
     * @type {string}
     * @memberof CertificationIdentitySummary
     */
    'id'?: string;
    /**
     * Name of the linked identity
     * @type {string}
     * @memberof CertificationIdentitySummary
     */
    'name'?: string;
    /**
     * The ID of the identity being certified
     * @type {string}
     * @memberof CertificationIdentitySummary
     */
    'identityId'?: string;
    /**
     * Indicates whether the review items for the linked identity\'s certification have been completed
     * @type {boolean}
     * @memberof CertificationIdentitySummary
     */
    'completed'?: boolean;
}
/**
 * The current phase of the campaign. * `STAGED`: The campaign is waiting to be activated. * `ACTIVE`: The campaign is active. * `SIGNED`: The reviewer has signed off on the campaign, and it is considered complete. 
 * @export
 * @enum {string}
 */

export const CertificationPhase = {
    Staged: 'STAGED',
    Active: 'ACTIVE',
    Signed: 'SIGNED'
} as const;

export type CertificationPhase = typeof CertificationPhase[keyof typeof CertificationPhase];


/**
 * 
 * @export
 * @interface CertificationReference
 */
export interface CertificationReference {
    /**
     * The id of the certification.
     * @type {string}
     * @memberof CertificationReference
     */
    'id'?: string;
    /**
     * The name of the certification.
     * @type {string}
     * @memberof CertificationReference
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CertificationReference
     */
    'type'?: CertificationReferenceTypeEnum;
    /**
     * 
     * @type {Reviewer}
     * @memberof CertificationReference
     */
    'reviewer'?: Reviewer;
}

export const CertificationReferenceTypeEnum = {
    Certification: 'CERTIFICATION'
} as const;

export type CertificationReferenceTypeEnum = typeof CertificationReferenceTypeEnum[keyof typeof CertificationReferenceTypeEnum];

/**
 * Type of an API Client indicating public or confidentials use
 * @export
 * @enum {string}
 */

export const ClientType = {
    Confidential: 'CONFIDENTIAL',
    Public: 'PUBLIC'
} as const;

export type ClientType = typeof ClientType[keyof typeof ClientType];


/**
 * 
 * @export
 * @interface Column
 */
export interface Column {
    /**
     * The name of the field. 
     * @type {string}
     * @memberof Column
     */
    'field': string;
    /**
     * The value of the header. 
     * @type {string}
     * @memberof Column
     */
    'header'?: string;
}
/**
 * 
 * @export
 * @interface Comment
 */
export interface Comment {
    /**
     * Id of the identity making the comment
     * @type {string}
     * @memberof Comment
     */
    'commenterId'?: string;
    /**
     * Human-readable display name of the identity making the comment
     * @type {string}
     * @memberof Comment
     */
    'commenterName'?: string;
    /**
     * Content of the comment
     * @type {string}
     * @memberof Comment
     */
    'body'?: string;
    /**
     * Date and time comment was made
     * @type {string}
     * @memberof Comment
     */
    'date'?: string;
}
/**
 * 
 * @export
 * @interface CommentDto
 */
export interface CommentDto {
    /**
     * Content of the comment
     * @type {string}
     * @memberof CommentDto
     */
    'comment'?: string;
    /**
     * 
     * @type {CommentDtoAuthor}
     * @memberof CommentDto
     */
    'author'?: CommentDtoAuthor;
    /**
     * Date and time comment was created
     * @type {string}
     * @memberof CommentDto
     */
    'created'?: string;
}
/**
 * 
 * @export
 * @interface CommentDtoAuthor
 */
export interface CommentDtoAuthor {
    /**
     * 
     * @type {DtoType}
     * @memberof CommentDtoAuthor
     */
    'type'?: DtoType;
    /**
     * ID of the author
     * @type {string}
     * @memberof CommentDtoAuthor
     */
    'id'?: string;
    /**
     * Human-readable display name of the identity making the comment
     * @type {string}
     * @memberof CommentDtoAuthor
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface CompletedApproval
 */
export interface CompletedApproval {
    /**
     * The approval id.
     * @type {string}
     * @memberof CompletedApproval
     */
    'id'?: string;
    /**
     * The name of the approval.
     * @type {string}
     * @memberof CompletedApproval
     */
    'name'?: string;
    /**
     * When the approval was created.
     * @type {string}
     * @memberof CompletedApproval
     */
    'created'?: string;
    /**
     * When the approval was modified last time.
     * @type {string}
     * @memberof CompletedApproval
     */
    'modified'?: string;
    /**
     * When the access-request was created.
     * @type {string}
     * @memberof CompletedApproval
     */
    'requestCreated'?: string;
    /**
     * 
     * @type {AccessRequestType}
     * @memberof CompletedApproval
     */
    'requestType'?: AccessRequestType;
    /**
     * 
     * @type {BaseReferenceDto}
     * @memberof CompletedApproval
     */
    'requester'?: BaseReferenceDto;
    /**
     * 
     * @type {BaseReferenceDto}
     * @memberof CompletedApproval
     */
    'requestedFor'?: BaseReferenceDto;
    /**
     * 
     * @type {BaseReferenceDto}
     * @memberof CompletedApproval
     */
    'reviewedBy'?: BaseReferenceDto;
    /**
     * 
     * @type {BaseReferenceDto}
     * @memberof CompletedApproval
     */
    'owner'?: BaseReferenceDto;
    /**
     * 
     * @type {RequestableObjectReference}
     * @memberof CompletedApproval
     */
    'requestedObject'?: RequestableObjectReference;
    /**
     * 
     * @type {CommentDto}
     * @memberof CompletedApproval
     */
    'requesterComment'?: CommentDto;
    /**
     * 
     * @type {CommentDto}
     * @memberof CompletedApproval
     */
    'reviewerComment'?: CommentDto;
    /**
     * The history of the previous reviewers comments.
     * @type {Array<CommentDto>}
     * @memberof CompletedApproval
     */
    'previousReviewersComments'?: Array<CommentDto>;
    /**
     * The history of approval forward action.
     * @type {Array<ApprovalForwardHistory>}
     * @memberof CompletedApproval
     */
    'forwardHistory'?: Array<ApprovalForwardHistory>;
    /**
     * When true the rejector has to provide comments when rejecting
     * @type {boolean}
     * @memberof CompletedApproval
     */
    'commentRequiredWhenRejected'?: boolean;
    /**
     * 
     * @type {CompletedApprovalState}
     * @memberof CompletedApproval
     */
    'state'?: CompletedApprovalState;
    /**
     * The date the role or access profile is no longer assigned to the specified identity.
     * @type {string}
     * @memberof CompletedApproval
     */
    'removeDate'?: string;
    /**
     * If true, then the request was to change the remove date or sunset date.
     * @type {boolean}
     * @memberof CompletedApproval
     */
    'removeDateUpdateRequested'?: boolean;
    /**
     * The remove date or sunset date that was assigned at the time of the request.
     * @type {string}
     * @memberof CompletedApproval
     */
    'currentRemoveDate'?: string;
    /**
     * 
     * @type {SodViolationContextCheckCompleted}
     * @memberof CompletedApproval
     */
    'sodViolationContext'?: SodViolationContextCheckCompleted;
}
/**
 * Enum represents completed approval object\'s state.
 * @export
 * @enum {string}
 */

export const CompletedApprovalState = {
    Approved: 'APPROVED',
    Rejected: 'REJECTED'
} as const;

export type CompletedApprovalState = typeof CompletedApprovalState[keyof typeof CompletedApprovalState];


/**
 * The status after completion.
 * @export
 * @enum {string}
 */

export const CompletionStatus = {
    Success: 'SUCCESS',
    Failure: 'FAILURE',
    Incomplete: 'INCOMPLETE',
    Pending: 'PENDING'
} as const;

export type CompletionStatus = typeof CompletionStatus[keyof typeof CompletionStatus];


/**
 * 
 * @export
 * @interface Concatenation
 */
export interface Concatenation {
    /**
     * An array of items to join together
     * @type {Array<object>}
     * @memberof Concatenation
     */
    'values': Array<object>;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Concatenation
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Concatenation
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface Conditional
 */
export interface Conditional {
    /**
     * A comparison statement that follows the structure of `ValueA eq ValueB` where `ValueA` and `ValueB` are static strings or outputs of other transforms.   The `eq` operator is the only valid comparison
     * @type {string}
     * @memberof Conditional
     */
    'expression': string;
    /**
     * The output of the transform if the expression evalutes to true
     * @type {string}
     * @memberof Conditional
     */
    'positiveCondition': string;
    /**
     * The output of the transform if the expression evalutes to false
     * @type {string}
     * @memberof Conditional
     */
    'negativeCondition': string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Conditional
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Conditional
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface CreateAccessRequest401Response
 */
export interface CreateAccessRequest401Response {
    /**
     * A message describing the error
     * @type {object}
     * @memberof CreateAccessRequest401Response
     */
    'error'?: object;
}
/**
 * 
 * @export
 * @interface CreateAccessRequest429Response
 */
export interface CreateAccessRequest429Response {
    /**
     * A message describing the error
     * @type {object}
     * @memberof CreateAccessRequest429Response
     */
    'message'?: object;
}
/**
 * 
 * @export
 * @interface CreateOAuthClientRequest
 */
export interface CreateOAuthClientRequest {
    /**
     * The name of the business the API Client should belong to
     * @type {string}
     * @memberof CreateOAuthClientRequest
     */
    'businessName'?: string | null;
    /**
     * The homepage URL associated with the owner of the API Client
     * @type {string}
     * @memberof CreateOAuthClientRequest
     */
    'homepageUrl'?: string | null;
    /**
     * A human-readable name for the API Client
     * @type {string}
     * @memberof CreateOAuthClientRequest
     */
    'name': string | null;
    /**
     * A description of the API Client
     * @type {string}
     * @memberof CreateOAuthClientRequest
     */
    'description': string | null;
    /**
     * The number of seconds an access token generated for this API Client is valid for
     * @type {number}
     * @memberof CreateOAuthClientRequest
     */
    'accessTokenValiditySeconds': number;
    /**
     * The number of seconds a refresh token generated for this API Client is valid for
     * @type {number}
     * @memberof CreateOAuthClientRequest
     */
    'refreshTokenValiditySeconds'?: number;
    /**
     * A list of the approved redirect URIs. Provide one or more URIs when assigning the AUTHORIZATION_CODE grant type to a new OAuth Client.
     * @type {Array<string>}
     * @memberof CreateOAuthClientRequest
     */
    'redirectUris'?: Array<string> | null;
    /**
     * A list of OAuth 2.0 grant types this API Client can be used with
     * @type {Array<GrantType>}
     * @memberof CreateOAuthClientRequest
     */
    'grantTypes': Array<GrantType> | null;
    /**
     * 
     * @type {AccessType}
     * @memberof CreateOAuthClientRequest
     */
    'accessType': AccessType;
    /**
     * 
     * @type {ClientType}
     * @memberof CreateOAuthClientRequest
     */
    'type'?: ClientType;
    /**
     * An indicator of whether the API Client can be used for requests internal within the product.
     * @type {boolean}
     * @memberof CreateOAuthClientRequest
     */
    'internal'?: boolean;
    /**
     * An indicator of whether the API Client is enabled for use
     * @type {boolean}
     * @memberof CreateOAuthClientRequest
     */
    'enabled': boolean;
    /**
     * An indicator of whether the API Client supports strong authentication
     * @type {boolean}
     * @memberof CreateOAuthClientRequest
     */
    'strongAuthSupported'?: boolean;
    /**
     * An indicator of whether the API Client supports the serialization of SAML claims when used with the authorization_code flow
     * @type {boolean}
     * @memberof CreateOAuthClientRequest
     */
    'claimsSupported'?: boolean;
    /**
     * Scopes of the API Client. If no scope is specified, the client will be created with the default scope \"sp:scopes:all\". This means the API Client will have all the rights of the owner who created it.
     * @type {Array<string>}
     * @memberof CreateOAuthClientRequest
     */
    'scope'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface CreateOAuthClientResponse
 */
export interface CreateOAuthClientResponse {
    /**
     * ID of the OAuth client
     * @type {string}
     * @memberof CreateOAuthClientResponse
     */
    'id': string;
    /**
     * Secret of the OAuth client (This field is only returned on the intial create call.)
     * @type {string}
     * @memberof CreateOAuthClientResponse
     */
    'secret': string;
    /**
     * The name of the business the API Client should belong to
     * @type {string}
     * @memberof CreateOAuthClientResponse
     */
    'businessName': string;
    /**
     * The homepage URL associated with the owner of the API Client
     * @type {string}
     * @memberof CreateOAuthClientResponse
     */
    'homepageUrl': string;
    /**
     * A human-readable name for the API Client
     * @type {string}
     * @memberof CreateOAuthClientResponse
     */
    'name': string;
    /**
     * A description of the API Client
     * @type {string}
     * @memberof CreateOAuthClientResponse
     */
    'description': string;
    /**
     * The number of seconds an access token generated for this API Client is valid for
     * @type {number}
     * @memberof CreateOAuthClientResponse
     */
    'accessTokenValiditySeconds': number;
    /**
     * The number of seconds a refresh token generated for this API Client is valid for
     * @type {number}
     * @memberof CreateOAuthClientResponse
     */
    'refreshTokenValiditySeconds': number;
    /**
     * A list of the approved redirect URIs used with the authorization_code flow
     * @type {Array<string>}
     * @memberof CreateOAuthClientResponse
     */
    'redirectUris': Array<string>;
    /**
     * A list of OAuth 2.0 grant types this API Client can be used with
     * @type {Array<GrantType>}
     * @memberof CreateOAuthClientResponse
     */
    'grantTypes': Array<GrantType>;
    /**
     * 
     * @type {AccessType}
     * @memberof CreateOAuthClientResponse
     */
    'accessType': AccessType;
    /**
     * 
     * @type {ClientType}
     * @memberof CreateOAuthClientResponse
     */
    'type': ClientType;
    /**
     * An indicator of whether the API Client can be used for requests internal to IDN
     * @type {boolean}
     * @memberof CreateOAuthClientResponse
     */
    'internal': boolean;
    /**
     * An indicator of whether the API Client is enabled for use
     * @type {boolean}
     * @memberof CreateOAuthClientResponse
     */
    'enabled': boolean;
    /**
     * An indicator of whether the API Client supports strong authentication
     * @type {boolean}
     * @memberof CreateOAuthClientResponse
     */
    'strongAuthSupported': boolean;
    /**
     * An indicator of whether the API Client supports the serialization of SAML claims when used with the authorization_code flow
     * @type {boolean}
     * @memberof CreateOAuthClientResponse
     */
    'claimsSupported': boolean;
    /**
     * The date and time, down to the millisecond, when the API Client was created
     * @type {string}
     * @memberof CreateOAuthClientResponse
     */
    'created': string;
    /**
     * The date and time, down to the millisecond, when the API Client was last updated
     * @type {string}
     * @memberof CreateOAuthClientResponse
     */
    'modified': string;
    /**
     * Scopes of the API Client.
     * @type {Array<string>}
     * @memberof CreateOAuthClientResponse
     */
    'scope': Array<string> | null;
}
/**
 * Object for specifying the name of a personal access token to create
 * @export
 * @interface CreatePersonalAccessTokenRequest
 */
export interface CreatePersonalAccessTokenRequest {
    /**
     * The name of the personal access token (PAT) to be created. Cannot be the same as another PAT owned by the user for whom this PAT is being created.
     * @type {string}
     * @memberof CreatePersonalAccessTokenRequest
     */
    'name': string;
    /**
     * Scopes of the personal  access token. If no scope is specified, the token will be created with the default scope \"sp:scopes:all\". This means the personal access token will have all the rights of the owner who created it.
     * @type {Array<string>}
     * @memberof CreatePersonalAccessTokenRequest
     */
    'scope'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface CreatePersonalAccessTokenResponse
 */
export interface CreatePersonalAccessTokenResponse {
    /**
     * The ID of the personal access token (to be used as the username for Basic Auth).
     * @type {string}
     * @memberof CreatePersonalAccessTokenResponse
     */
    'id': string;
    /**
     * The secret of the personal access token (to be used as the password for Basic Auth).
     * @type {string}
     * @memberof CreatePersonalAccessTokenResponse
     */
    'secret': string;
    /**
     * Scopes of the personal  access token.
     * @type {Array<string>}
     * @memberof CreatePersonalAccessTokenResponse
     */
    'scope': Array<string> | null;
    /**
     * The name of the personal access token. Cannot be the same as other personal access tokens owned by a user.
     * @type {string}
     * @memberof CreatePersonalAccessTokenResponse
     */
    'name': string;
    /**
     * 
     * @type {BaseReferenceDto}
     * @memberof CreatePersonalAccessTokenResponse
     */
    'owner': BaseReferenceDto;
    /**
     * The date and time, down to the millisecond, when this personal access token was created.
     * @type {string}
     * @memberof CreatePersonalAccessTokenResponse
     */
    'created': string;
}
/**
 * 
 * @export
 * @interface DateCompare
 */
export interface DateCompare {
    /**
     * 
     * @type {DateCompareFirstDate}
     * @memberof DateCompare
     */
    'firstDate': DateCompareFirstDate;
    /**
     * 
     * @type {DateCompareSecondDate}
     * @memberof DateCompare
     */
    'secondDate': DateCompareSecondDate;
    /**
     * This is the comparison to perform. | Operation | Description | | --------- | ------- | | LT        | Strictly less than: firstDate < secondDate | | LTE       | Less than or equal to: firstDate <= secondDate | | GT        | Strictly greater than: firstDate > secondDate | | GTE       | Greater than or equal to: firstDate >= secondDate | 
     * @type {string}
     * @memberof DateCompare
     */
    'operator': DateCompareOperatorEnum;
    /**
     * The output of the transform if the expression evalutes to true
     * @type {string}
     * @memberof DateCompare
     */
    'positiveCondition': string;
    /**
     * The output of the transform if the expression evalutes to false
     * @type {string}
     * @memberof DateCompare
     */
    'negativeCondition': string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof DateCompare
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof DateCompare
     */
    'input'?: { [key: string]: any; };
}

export const DateCompareOperatorEnum = {
    Lt: 'LT',
    Lte: 'LTE',
    Gt: 'GT',
    Gte: 'GTE'
} as const;

export type DateCompareOperatorEnum = typeof DateCompareOperatorEnum[keyof typeof DateCompareOperatorEnum];

/**
 * @type DateCompareFirstDate
 * This is the first date to consider (The date that would be on the left hand side of the comparison operation).
 * @export
 */
export type DateCompareFirstDate = AccountAttribute | DateFormat;

/**
 * @type DateCompareSecondDate
 * This is the second date to consider (The date that would be on the right hand side of the comparison operation).
 * @export
 */
export type DateCompareSecondDate = AccountAttribute | DateFormat;

/**
 * 
 * @export
 * @interface DateFormat
 */
export interface DateFormat {
    /**
     * 
     * @type {DateFormatInputFormat}
     * @memberof DateFormat
     */
    'inputFormat'?: DateFormatInputFormat;
    /**
     * 
     * @type {DateFormatOutputFormat}
     * @memberof DateFormat
     */
    'outputFormat'?: DateFormatOutputFormat;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof DateFormat
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof DateFormat
     */
    'input'?: { [key: string]: any; };
}
/**
 * @type DateFormatInputFormat
 * A string value indicating either the explicit SimpleDateFormat or the built-in named format that the data is coming in as.  *If no inputFormat is provided, the transform assumes that it is in ISO8601 format*
 * @export
 */
export type DateFormatInputFormat = NamedConstructs | string;

/**
 * @type DateFormatOutputFormat
 * A string value indicating either the explicit SimpleDateFormat or the built-in named format that the data should be formatted into.  *If no inputFormat is provided, the transform assumes that it is in ISO8601 format*
 * @export
 */
export type DateFormatOutputFormat = NamedConstructs | string;

/**
 * 
 * @export
 * @interface DateMath
 */
export interface DateMath {
    /**
     * A string value of the date and time components to operation on, along with the math operations to execute. 
     * @type {string}
     * @memberof DateMath
     */
    'expression': string;
    /**
     * A boolean value to indicate whether the transform should round up or down when a rounding `/` operation is defined in the expression.    If not provided, the transform will default to `false`   `true` indicates the transform should round up (i.e., truncate the fractional date/time component indicated and then add one unit of that component)   `false` indicates the transform should round down (i.e., truncate the fractional date/time component indicated) 
     * @type {boolean}
     * @memberof DateMath
     */
    'roundUp'?: boolean;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof DateMath
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof DateMath
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface DecomposeDiacriticalMarks
 */
export interface DecomposeDiacriticalMarks {
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof DecomposeDiacriticalMarks
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof DecomposeDiacriticalMarks
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface DeleteSource202Response
 */
export interface DeleteSource202Response {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof DeleteSource202Response
     */
    'type'?: DeleteSource202ResponseTypeEnum;
    /**
     * ID of the task result
     * @type {string}
     * @memberof DeleteSource202Response
     */
    'id'?: string;
    /**
     * Human-readable display name of the task result (should be null/empty)
     * @type {string}
     * @memberof DeleteSource202Response
     */
    'name'?: string;
}

export const DeleteSource202ResponseTypeEnum = {
    TaskResult: 'TASK_RESULT'
} as const;

export type DeleteSource202ResponseTypeEnum = typeof DeleteSource202ResponseTypeEnum[keyof typeof DeleteSource202ResponseTypeEnum];

/**
 * 
 * @export
 * @interface DisplayReference
 */
export interface DisplayReference {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof DisplayReference
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof DisplayReference
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DisplayReference
     */
    'displayName'?: string;
}
/**
 * 
 * @export
 * @interface DisplayReferenceAllOf
 */
export interface DisplayReferenceAllOf {
    /**
     * 
     * @type {string}
     * @memberof DisplayReferenceAllOf
     */
    'displayName'?: string;
}
/**
 * Enum representing the currently supported document types.  Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */

export const DocumentType = {
    Accessprofile: 'accessprofile',
    Accountactivity: 'accountactivity',
    Account: 'account',
    Aggregation: 'aggregation',
    Entitlement: 'entitlement',
    Event: 'event',
    Identity: 'identity',
    Role: 'role'
} as const;

export type DocumentType = typeof DocumentType[keyof typeof DocumentType];


/**
 * An enumeration of the types of DTOs supported within the IdentityNow infrastructure.
 * @export
 * @enum {string}
 */

export const DtoType = {
    AccountCorrelationConfig: 'ACCOUNT_CORRELATION_CONFIG',
    AccessProfile: 'ACCESS_PROFILE',
    AccessRequestApproval: 'ACCESS_REQUEST_APPROVAL',
    Account: 'ACCOUNT',
    Application: 'APPLICATION',
    Campaign: 'CAMPAIGN',
    CampaignFilter: 'CAMPAIGN_FILTER',
    Certification: 'CERTIFICATION',
    Cluster: 'CLUSTER',
    ConnectorSchema: 'CONNECTOR_SCHEMA',
    Entitlement: 'ENTITLEMENT',
    GovernanceGroup: 'GOVERNANCE_GROUP',
    Identity: 'IDENTITY',
    IdentityProfile: 'IDENTITY_PROFILE',
    IdentityRequest: 'IDENTITY_REQUEST',
    LifecycleState: 'LIFECYCLE_STATE',
    PasswordPolicy: 'PASSWORD_POLICY',
    Role: 'ROLE',
    Rule: 'RULE',
    SodPolicy: 'SOD_POLICY',
    Source: 'SOURCE',
    TagCategory: 'TAG_CATEGORY',
    TaskResult: 'TASK_RESULT',
    ReportResult: 'REPORT_RESULT',
    SodViolation: 'SOD_VIOLATION',
    AccountActivity: 'ACCOUNT_ACTIVITY'
} as const;

export type DtoType = typeof DtoType[keyof typeof DtoType];


/**
 * 
 * @export
 * @interface E164phone
 */
export interface E164phone {
    /**
     * This is an optional attribute that can be used to define the region of the phone number to format into.   If defaultRegion is not provided, it will take US as the default country.   The format of the country code should be in [ISO 3166-1 alpha-2 format](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) 
     * @type {string}
     * @memberof E164phone
     */
    'defaultRegion'?: string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof E164phone
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof E164phone
     */
    'input'?: { [key: string]: any; };
}
/**
 * This is used for representing email configuration for a lifecycle state
 * @export
 * @interface EmailNotificationOption
 */
export interface EmailNotificationOption {
    /**
     * If true, then the manager is notified of the lifecycle state change.
     * @type {boolean}
     * @memberof EmailNotificationOption
     */
    'notifyManagers'?: boolean;
    /**
     * If true, then all the admins are notified of the lifecycle state change.
     * @type {boolean}
     * @memberof EmailNotificationOption
     */
    'notifyAllAdmins'?: boolean;
    /**
     * If true, then the users specified in \"emailAddressList\" below are notified of lifecycle state change.
     * @type {boolean}
     * @memberof EmailNotificationOption
     */
    'notifySpecificUsers'?: boolean;
    /**
     * List of user email addresses. If \"notifySpecificUsers\" option is true, then these users are notified of lifecycle state change.
     * @type {Array<string>}
     * @memberof EmailNotificationOption
     */
    'emailAddressList'?: Array<string>;
}
/**
 * Entitlement
 * @export
 * @interface EntitlementDocument
 */
export interface EntitlementDocument {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof EntitlementDocument
     */
    'id': string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof EntitlementDocument
     */
    'name': string;
    /**
     * 
     * @type {DocumentType}
     * @memberof EntitlementDocument
     */
    '_type': DocumentType;
    /**
     * A description of the entitlement
     * @type {string}
     * @memberof EntitlementDocument
     */
    'description'?: string;
    /**
     * The name of the entitlement attribute
     * @type {string}
     * @memberof EntitlementDocument
     */
    'attribute'?: string;
    /**
     * The value of the entitlement
     * @type {string}
     * @memberof EntitlementDocument
     */
    'value'?: string;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof EntitlementDocument
     */
    'modified'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof EntitlementDocument
     */
    'synced'?: string | null;
    /**
     * The display name of the entitlement
     * @type {string}
     * @memberof EntitlementDocument
     */
    'displayName'?: string;
    /**
     * 
     * @type {Reference1}
     * @memberof EntitlementDocument
     */
    'source'?: Reference1;
    /**
     * 
     * @type {boolean}
     * @memberof EntitlementDocument
     */
    'privileged'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof EntitlementDocument
     */
    'identityCount'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof EntitlementDocument
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface EntitlementDocumentAllOf
 */
export interface EntitlementDocumentAllOf {
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof EntitlementDocumentAllOf
     */
    'modified'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof EntitlementDocumentAllOf
     */
    'synced'?: string | null;
    /**
     * The display name of the entitlement
     * @type {string}
     * @memberof EntitlementDocumentAllOf
     */
    'displayName'?: string;
    /**
     * 
     * @type {Reference1}
     * @memberof EntitlementDocumentAllOf
     */
    'source'?: Reference1;
    /**
     * 
     * @type {boolean}
     * @memberof EntitlementDocumentAllOf
     */
    'privileged'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof EntitlementDocumentAllOf
     */
    'identityCount'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof EntitlementDocumentAllOf
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface EntitlementDto
 */
export interface EntitlementDto {
    /**
     * System-generated unique ID of the Object
     * @type {string}
     * @memberof EntitlementDto
     */
    'id'?: string;
    /**
     * Name of the Object
     * @type {string}
     * @memberof EntitlementDto
     */
    'name': string;
    /**
     * Creation date of the Object
     * @type {string}
     * @memberof EntitlementDto
     */
    'created'?: string;
    /**
     * Last modification date of the Object
     * @type {string}
     * @memberof EntitlementDto
     */
    'modified'?: string;
    /**
     * Name of the entitlement attribute
     * @type {string}
     * @memberof EntitlementDto
     */
    'attribute'?: string;
    /**
     * Raw value of the entitlement
     * @type {string}
     * @memberof EntitlementDto
     */
    'value'?: string;
    /**
     * Entitlment description
     * @type {string}
     * @memberof EntitlementDto
     */
    'description'?: string;
    /**
     * Entitlement attributes
     * @type {{ [key: string]: any; }}
     * @memberof EntitlementDto
     */
    'attributes'?: { [key: string]: any; };
    /**
     * Schema objectType on the given application that maps to an Account Group
     * @type {string}
     * @memberof EntitlementDto
     */
    'sourceSchemaObjectType'?: string;
    /**
     * Determines if this Entitlement is privileged.
     * @type {boolean}
     * @memberof EntitlementDto
     */
    'privileged'?: boolean;
    /**
     * Determines if this Entitlement is goverened in the cloud.
     * @type {boolean}
     * @memberof EntitlementDto
     */
    'cloudGoverned'?: boolean;
    /**
     * 
     * @type {BaseReferenceDto}
     * @memberof EntitlementDto
     */
    'source'?: BaseReferenceDto;
}
/**
 * Entitlement object that represents entitlement
 * @export
 * @interface EntitlementDtoAllOf
 */
export interface EntitlementDtoAllOf {
    /**
     * Name of the entitlement attribute
     * @type {string}
     * @memberof EntitlementDtoAllOf
     */
    'attribute'?: string;
    /**
     * Raw value of the entitlement
     * @type {string}
     * @memberof EntitlementDtoAllOf
     */
    'value'?: string;
    /**
     * Entitlment description
     * @type {string}
     * @memberof EntitlementDtoAllOf
     */
    'description'?: string;
    /**
     * Entitlement attributes
     * @type {{ [key: string]: any; }}
     * @memberof EntitlementDtoAllOf
     */
    'attributes'?: { [key: string]: any; };
    /**
     * Schema objectType on the given application that maps to an Account Group
     * @type {string}
     * @memberof EntitlementDtoAllOf
     */
    'sourceSchemaObjectType'?: string;
    /**
     * Determines if this Entitlement is privileged.
     * @type {boolean}
     * @memberof EntitlementDtoAllOf
     */
    'privileged'?: boolean;
    /**
     * Determines if this Entitlement is goverened in the cloud.
     * @type {boolean}
     * @memberof EntitlementDtoAllOf
     */
    'cloudGoverned'?: boolean;
    /**
     * 
     * @type {BaseReferenceDto}
     * @memberof EntitlementDtoAllOf
     */
    'source'?: BaseReferenceDto;
}
/**
 * 
 * @export
 * @interface EntitlementRequestConfig
 */
export interface EntitlementRequestConfig {
    /**
     * Flag for allowing entitlement request.
     * @type {boolean}
     * @memberof EntitlementRequestConfig
     */
    'allowEntitlementRequest'?: boolean;
    /**
     * Flag for requiring comments while submitting an entitlement request.
     * @type {boolean}
     * @memberof EntitlementRequestConfig
     */
    'requestCommentsRequired'?: boolean;
    /**
     * Flag for requiring comments while rejecting an entitlement request.
     * @type {boolean}
     * @memberof EntitlementRequestConfig
     */
    'deniedCommentsRequired'?: boolean;
    /**
     * Approval schemes for granting entitlement request. This can be empty if no approval is needed. Multiple schemes must be comma-separated. The valid schemes are \"sourceOwner\", \"manager\" and \"workgroup:{id}\". Multiple workgroups (governance groups) can be used. 
     * @type {string}
     * @memberof EntitlementRequestConfig
     */
    'grantRequestApprovalSchemes'?: string;
}
/**
 * EntitlementReference
 * @export
 * @interface EntitlementSummary
 */
export interface EntitlementSummary {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof EntitlementSummary
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof EntitlementSummary
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntitlementSummary
     */
    'displayName'?: string;
    /**
     * 
     * @type {DtoType}
     * @memberof EntitlementSummary
     */
    'type'?: DtoType;
    /**
     * 
     * @type {string}
     * @memberof EntitlementSummary
     */
    'description'?: string | null;
    /**
     * 
     * @type {Reference1}
     * @memberof EntitlementSummary
     */
    'source'?: Reference1;
    /**
     * 
     * @type {boolean}
     * @memberof EntitlementSummary
     */
    'privileged'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EntitlementSummary
     */
    'attribute'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntitlementSummary
     */
    'value'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EntitlementSummary
     */
    'standalone'?: boolean;
}
/**
 * 
 * @export
 * @interface EntitlementSummaryAllOf
 */
export interface EntitlementSummaryAllOf {
    /**
     * 
     * @type {Reference1}
     * @memberof EntitlementSummaryAllOf
     */
    'source'?: Reference1;
    /**
     * 
     * @type {boolean}
     * @memberof EntitlementSummaryAllOf
     */
    'privileged'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EntitlementSummaryAllOf
     */
    'attribute'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntitlementSummaryAllOf
     */
    'value'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EntitlementSummaryAllOf
     */
    'standalone'?: boolean;
}
/**
 * 
 * @export
 * @interface ErrorMessageDto
 */
export interface ErrorMessageDto {
    /**
     * The locale for the message text, a BCP 47 language tag.
     * @type {string}
     * @memberof ErrorMessageDto
     */
    'locale'?: string;
    /**
     * 
     * @type {LocaleOrigin}
     * @memberof ErrorMessageDto
     */
    'localeOrigin'?: LocaleOrigin;
    /**
     * Actual text of the error message in the indicated locale.
     * @type {string}
     * @memberof ErrorMessageDto
     */
    'text'?: string;
}
/**
 * 
 * @export
 * @interface ErrorResponseDto
 */
export interface ErrorResponseDto {
    /**
     * Fine-grained error code providing more detail of the error.
     * @type {string}
     * @memberof ErrorResponseDto
     */
    'detailCode'?: string;
    /**
     * Unique tracking id for the error.
     * @type {string}
     * @memberof ErrorResponseDto
     */
    'trackingId'?: string;
    /**
     * Generic localized reason for error
     * @type {Array<ErrorMessageDto>}
     * @memberof ErrorResponseDto
     */
    'messages'?: Array<ErrorMessageDto>;
    /**
     * Plain-text descriptive reasons to provide additional detail to the text provided in the messages field
     * @type {Array<ErrorMessageDto>}
     * @memberof ErrorResponseDto
     */
    'causes'?: Array<ErrorMessageDto>;
}
/**
 * Event
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'name': string;
    /**
     * 
     * @type {DocumentType}
     * @memberof Event
     */
    '_type': DocumentType;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof Event
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof Event
     */
    'synced'?: string | null;
    /**
     * The action that was performed
     * @type {string}
     * @memberof Event
     */
    'action'?: string;
    /**
     * The type of event
     * @type {string}
     * @memberof Event
     */
    'type'?: string;
    /**
     * 
     * @type {NameType}
     * @memberof Event
     */
    'actor'?: NameType;
    /**
     * 
     * @type {NameType}
     * @memberof Event
     */
    'target'?: NameType;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'stack'?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'trackingNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'ipAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'details'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof Event
     */
    'attributes'?: { [key: string]: any; };
    /**
     * 
     * @type {Array<string>}
     * @memberof Event
     */
    'objects'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'operation'?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'technicalName'?: string;
}
/**
 * 
 * @export
 * @interface EventAllOf
 */
export interface EventAllOf {
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof EventAllOf
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof EventAllOf
     */
    'synced'?: string | null;
    /**
     * The action that was performed
     * @type {string}
     * @memberof EventAllOf
     */
    'action'?: string;
    /**
     * The type of event
     * @type {string}
     * @memberof EventAllOf
     */
    'type'?: string;
    /**
     * 
     * @type {NameType}
     * @memberof EventAllOf
     */
    'actor'?: NameType;
    /**
     * 
     * @type {NameType}
     * @memberof EventAllOf
     */
    'target'?: NameType;
    /**
     * 
     * @type {string}
     * @memberof EventAllOf
     */
    'stack'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventAllOf
     */
    'trackingNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventAllOf
     */
    'ipAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventAllOf
     */
    'details'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof EventAllOf
     */
    'attributes'?: { [key: string]: any; };
    /**
     * 
     * @type {Array<string>}
     * @memberof EventAllOf
     */
    'objects'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof EventAllOf
     */
    'operation'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventAllOf
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventAllOf
     */
    'technicalName'?: string;
}
/**
 * Event
 * @export
 * @interface EventDocument
 */
export interface EventDocument {
    /**
     * 
     * @type {string}
     * @memberof EventDocument
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EventDocument
     */
    'name': string;
    /**
     * 
     * @type {DocumentType}
     * @memberof EventDocument
     */
    '_type': DocumentType;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof EventDocument
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof EventDocument
     */
    'synced'?: string | null;
    /**
     * The action that was performed
     * @type {string}
     * @memberof EventDocument
     */
    'action'?: string;
    /**
     * The type of event
     * @type {string}
     * @memberof EventDocument
     */
    'type'?: string;
    /**
     * 
     * @type {NameType}
     * @memberof EventDocument
     */
    'actor'?: NameType;
    /**
     * 
     * @type {NameType}
     * @memberof EventDocument
     */
    'target'?: NameType;
    /**
     * 
     * @type {string}
     * @memberof EventDocument
     */
    'stack'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventDocument
     */
    'trackingNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventDocument
     */
    'ipAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventDocument
     */
    'details'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof EventDocument
     */
    'attributes'?: { [key: string]: any; };
    /**
     * 
     * @type {Array<string>}
     * @memberof EventDocument
     */
    'objects'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof EventDocument
     */
    'operation'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventDocument
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventDocument
     */
    'technicalName'?: string;
}
/**
 * The current state of execution.
 * @export
 * @enum {string}
 */

export const ExecutionStatus = {
    Executing: 'EXECUTING',
    Verifying: 'VERIFYING',
    Terminated: 'TERMINATED',
    Completed: 'COMPLETED'
} as const;

export type ExecutionStatus = typeof ExecutionStatus[keyof typeof ExecutionStatus];


/**
 * 
 * @export
 * @interface ExpansionItem
 */
export interface ExpansionItem {
    /**
     * The ID of the account
     * @type {string}
     * @memberof ExpansionItem
     */
    'accountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExpansionItem
     */
    'cause'?: string;
    /**
     * The name of the item
     * @type {string}
     * @memberof ExpansionItem
     */
    'name'?: string;
    /**
     * 
     * @type {Array<AttributeRequest>}
     * @memberof ExpansionItem
     */
    'attributeRequests'?: Array<AttributeRequest>;
    /**
     * 
     * @type {AccountSource}
     * @memberof ExpansionItem
     */
    'source'?: AccountSource;
}
/**
 * 
 * @export
 * @interface FieldDetailsDto
 */
export interface FieldDetailsDto {
    /**
     * The name of the attribute.
     * @type {string}
     * @memberof FieldDetailsDto
     */
    'name'?: string;
    /**
     * The transform to apply to the field
     * @type {object}
     * @memberof FieldDetailsDto
     */
    'transform'?: object;
    /**
     * Attributes required for the transform
     * @type {object}
     * @memberof FieldDetailsDto
     */
    'attributes'?: object;
    /**
     * Flag indicating whether or not the attribute is required.
     * @type {boolean}
     * @memberof FieldDetailsDto
     */
    'isRequired'?: boolean;
    /**
     * The type of the attribute.
     * @type {string}
     * @memberof FieldDetailsDto
     */
    'type'?: string;
    /**
     * Flag indicating whether or not the attribute is multi-valued.
     * @type {boolean}
     * @memberof FieldDetailsDto
     */
    'isMultiValued'?: boolean;
}
/**
 * 
 * @export
 * @interface Filter
 */
export interface Filter {
    /**
     * 
     * @type {FilterType}
     * @memberof Filter
     */
    'type'?: FilterType;
    /**
     * 
     * @type {Range}
     * @memberof Filter
     */
    'range'?: Range;
    /**
     * The terms to be filtered.
     * @type {Array<string>}
     * @memberof Filter
     */
    'terms'?: Array<string>;
    /**
     * Indicates if the filter excludes results.
     * @type {boolean}
     * @memberof Filter
     */
    'exclude'?: boolean;
}
/**
 * An additional filter to constrain the results of the search query.
 * @export
 * @interface FilterAggregation
 */
export interface FilterAggregation {
    /**
     * The name of the filter aggregate to be included in the result.
     * @type {string}
     * @memberof FilterAggregation
     */
    'name': string;
    /**
     * 
     * @type {SearchFilterType}
     * @memberof FilterAggregation
     */
    'type'?: SearchFilterType;
    /**
     * The search field to apply the filter to.  Prefix the field name with \'@\' to reference a nested object. 
     * @type {string}
     * @memberof FilterAggregation
     */
    'field': string;
    /**
     * The value to filter on.
     * @type {string}
     * @memberof FilterAggregation
     */
    'value': string;
}
/**
 * Enum representing the currently supported filter types. Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */

export const FilterType = {
    Exists: 'EXISTS',
    Range: 'RANGE',
    Terms: 'TERMS'
} as const;

export type FilterType = typeof FilterType[keyof typeof FilterType];


/**
 * 
 * @export
 * @interface FirstValid
 */
export interface FirstValid {
    /**
     * An array of attributes to evaluate for existence.
     * @type {Array<object>}
     * @memberof FirstValid
     */
    'values': Array<object>;
    /**
     * a true or false value representing to move on to the next option if an error (like an Null Pointer Exception) were to occur.
     * @type {boolean}
     * @memberof FirstValid
     */
    'ignoreErrors'?: boolean;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof FirstValid
     */
    'requiresPeriodicRefresh'?: boolean;
}
/**
 * 
 * @export
 * @interface FormDetails
 */
export interface FormDetails {
    /**
     * ID of the form
     * @type {string}
     * @memberof FormDetails
     */
    'id'?: string;
    /**
     * Name of the form
     * @type {string}
     * @memberof FormDetails
     */
    'name'?: string;
    /**
     * The form title
     * @type {string}
     * @memberof FormDetails
     */
    'title'?: string;
    /**
     * The form subtitle.
     * @type {string}
     * @memberof FormDetails
     */
    'subtitle'?: string;
    /**
     * The name of the user that should be shown this form
     * @type {string}
     * @memberof FormDetails
     */
    'targetUser'?: string;
    /**
     * 
     * @type {SectionDetails}
     * @memberof FormDetails
     */
    'sections'?: SectionDetails;
}
/**
 * 
 * @export
 * @interface FormItemDetails
 */
export interface FormItemDetails {
    /**
     * Name of the FormItem
     * @type {string}
     * @memberof FormItemDetails
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ForwardApprovalDto
 */
export interface ForwardApprovalDto {
    /**
     * The Id of the new owner
     * @type {string}
     * @memberof ForwardApprovalDto
     */
    'newOwnerId': string;
    /**
     * The comment provided by the forwarder
     * @type {string}
     * @memberof ForwardApprovalDto
     */
    'comment': string;
}
/**
 * 
 * @export
 * @interface GenerateRandomString
 */
export interface GenerateRandomString {
    /**
     * This must always be set to \"Cloud Services Deployment Utility\"
     * @type {string}
     * @memberof GenerateRandomString
     */
    'name': string;
    /**
     * The operation to perform `generateRandomString`
     * @type {string}
     * @memberof GenerateRandomString
     */
    'operation': string;
    /**
     * This must be either \"true\" or \"false\" to indicate whether the generator logic should include numbers
     * @type {boolean}
     * @memberof GenerateRandomString
     */
    'includeNumbers': boolean;
    /**
     * This must be either \"true\" or \"false\" to indicate whether the generator logic should include special characters
     * @type {boolean}
     * @memberof GenerateRandomString
     */
    'includeSpecialChars': boolean;
    /**
     * This specifies how long the randomly generated string needs to be   >NOTE Due to identity attribute data constraints, the maximum allowable value is 450 characters 
     * @type {string}
     * @memberof GenerateRandomString
     */
    'length': string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof GenerateRandomString
     */
    'requiresPeriodicRefresh'?: boolean;
}
/**
 * 
 * @export
 * @interface GenericRule
 */
export interface GenericRule {
    /**
     * This is the name of the Generic rule that needs to be invoked by the transform
     * @type {string}
     * @memberof GenericRule
     */
    'name': string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof GenericRule
     */
    'requiresPeriodicRefresh'?: boolean;
}
/**
 * 
 * @export
 * @interface GetOAuthClientResponse
 */
export interface GetOAuthClientResponse {
    /**
     * ID of the OAuth client
     * @type {string}
     * @memberof GetOAuthClientResponse
     */
    'id': string;
    /**
     * The name of the business the API Client should belong to
     * @type {string}
     * @memberof GetOAuthClientResponse
     */
    'businessName': string | null;
    /**
     * The homepage URL associated with the owner of the API Client
     * @type {string}
     * @memberof GetOAuthClientResponse
     */
    'homepageUrl': string | null;
    /**
     * A human-readable name for the API Client
     * @type {string}
     * @memberof GetOAuthClientResponse
     */
    'name': string;
    /**
     * A description of the API Client
     * @type {string}
     * @memberof GetOAuthClientResponse
     */
    'description': string | null;
    /**
     * The number of seconds an access token generated for this API Client is valid for
     * @type {number}
     * @memberof GetOAuthClientResponse
     */
    'accessTokenValiditySeconds': number;
    /**
     * The number of seconds a refresh token generated for this API Client is valid for
     * @type {number}
     * @memberof GetOAuthClientResponse
     */
    'refreshTokenValiditySeconds': number;
    /**
     * A list of the approved redirect URIs used with the authorization_code flow
     * @type {Array<string>}
     * @memberof GetOAuthClientResponse
     */
    'redirectUris': Array<string> | null;
    /**
     * A list of OAuth 2.0 grant types this API Client can be used with
     * @type {Array<GrantType>}
     * @memberof GetOAuthClientResponse
     */
    'grantTypes': Array<GrantType>;
    /**
     * 
     * @type {AccessType}
     * @memberof GetOAuthClientResponse
     */
    'accessType': AccessType;
    /**
     * 
     * @type {ClientType}
     * @memberof GetOAuthClientResponse
     */
    'type': ClientType;
    /**
     * An indicator of whether the API Client can be used for requests internal to IDN
     * @type {boolean}
     * @memberof GetOAuthClientResponse
     */
    'internal': boolean;
    /**
     * An indicator of whether the API Client is enabled for use
     * @type {boolean}
     * @memberof GetOAuthClientResponse
     */
    'enabled': boolean;
    /**
     * An indicator of whether the API Client supports strong authentication
     * @type {boolean}
     * @memberof GetOAuthClientResponse
     */
    'strongAuthSupported': boolean;
    /**
     * An indicator of whether the API Client supports the serialization of SAML claims when used with the authorization_code flow
     * @type {boolean}
     * @memberof GetOAuthClientResponse
     */
    'claimsSupported': boolean;
    /**
     * The date and time, down to the millisecond, when the API Client was created
     * @type {string}
     * @memberof GetOAuthClientResponse
     */
    'created': string;
    /**
     * The date and time, down to the millisecond, when the API Client was last updated
     * @type {string}
     * @memberof GetOAuthClientResponse
     */
    'modified': string;
    /**
     * The date and time, down to the millisecond, when this API Client was last used to generate an access token. This timestamp does not get updated on every API Client usage, but only once a day. This property can be useful for identifying which API Clients are no longer actively used and can be removed.
     * @type {string}
     * @memberof GetOAuthClientResponse
     */
    'lastUsed'?: string | null;
    /**
     * Scopes of the API Client.
     * @type {Array<string>}
     * @memberof GetOAuthClientResponse
     */
    'scope': Array<string> | null;
}
/**
 * 
 * @export
 * @interface GetPersonalAccessTokenResponse
 */
export interface GetPersonalAccessTokenResponse {
    /**
     * The ID of the personal access token (to be used as the username for Basic Auth).
     * @type {string}
     * @memberof GetPersonalAccessTokenResponse
     */
    'id': string;
    /**
     * The name of the personal access token. Cannot be the same as other personal access tokens owned by a user.
     * @type {string}
     * @memberof GetPersonalAccessTokenResponse
     */
    'name': string;
    /**
     * Scopes of the personal  access token.
     * @type {Array<string>}
     * @memberof GetPersonalAccessTokenResponse
     */
    'scope': Array<string> | null;
    /**
     * 
     * @type {BaseReferenceDto}
     * @memberof GetPersonalAccessTokenResponse
     */
    'owner': BaseReferenceDto;
    /**
     * The date and time, down to the millisecond, when this personal access token was created.
     * @type {string}
     * @memberof GetPersonalAccessTokenResponse
     */
    'created': string;
    /**
     * The date and time, down to the millisecond, when this personal access token was last used to generate an access token. This timestamp does not get updated on every PAT usage, but only once a day. This property can be useful for identifying which PATs are no longer actively used and can be removed.
     * @type {string}
     * @memberof GetPersonalAccessTokenResponse
     */
    'lastUsed'?: string | null;
}
/**
 * 
 * @export
 * @interface GetReferenceIdentityAttribute
 */
export interface GetReferenceIdentityAttribute {
    /**
     * This must always be set to \"Cloud Services Deployment Utility\"
     * @type {string}
     * @memberof GetReferenceIdentityAttribute
     */
    'name': string;
    /**
     * The operation to perform `getReferenceIdentityAttribute`
     * @type {string}
     * @memberof GetReferenceIdentityAttribute
     */
    'operation': string;
    /**
     * This is the SailPoint User Name (uid) value of the identity whose attribute is desired  As a convenience feature, you can use the `manager` keyword to dynamically look up the user\'s manager and then get that manager\'s identity attribute. 
     * @type {string}
     * @memberof GetReferenceIdentityAttribute
     */
    'uid': string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof GetReferenceIdentityAttribute
     */
    'requiresPeriodicRefresh'?: boolean;
}
/**
 * OAuth2 Grant Type
 * @export
 * @enum {string}
 */

export const GrantType = {
    ClientCredentials: 'CLIENT_CREDENTIALS',
    AuthorizationCode: 'AUTHORIZATION_CODE',
    RefreshToken: 'REFRESH_TOKEN'
} as const;

export type GrantType = typeof GrantType[keyof typeof GrantType];


/**
 * 
 * @export
 * @interface ISO3166
 */
export interface ISO3166 {
    /**
     * An optional value to denote which ISO 3166 format to return. Valid values are:   `alpha2` - Two-character country code (e.g., \"US\"); this is the default value if no format is supplied   `alpha3` - Three-character country code (e.g., \"USA\")   `numeric` - The numeric country code (e.g., \"840\") 
     * @type {string}
     * @memberof ISO3166
     */
    'format'?: string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof ISO3166
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof ISO3166
     */
    'input'?: { [key: string]: any; };
}
/**
 * @type IdentityAccess
 * @export
 */
export type IdentityAccess = AccessProfileEntitlement | AccessProfileRole | AccessProfileSummary;

/**
 * 
 * @export
 * @interface IdentityAttribute
 */
export interface IdentityAttribute {
    /**
     * The system (camel-cased) name of the identity attribute to bring in
     * @type {string}
     * @memberof IdentityAttribute
     */
    'name': string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof IdentityAttribute
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof IdentityAttribute
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface IdentityAttribute1
 */
export interface IdentityAttribute1 {
    /**
     * The attribute key
     * @type {string}
     * @memberof IdentityAttribute1
     */
    'key'?: string;
    /**
     * Human-readable display name of the attribute
     * @type {string}
     * @memberof IdentityAttribute1
     */
    'name'?: string;
    /**
     * The attribute value
     * @type {string}
     * @memberof IdentityAttribute1
     */
    'value'?: string;
}
/**
 * Defines all the identity attribute mapping configurations. This defines how to generate or collect data for each identity attributes in identity refresh process.
 * @export
 * @interface IdentityAttributeConfig
 */
export interface IdentityAttributeConfig {
    /**
     * The backend will only promote values if the profile/mapping is enabled.
     * @type {boolean}
     * @memberof IdentityAttributeConfig
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {Array<IdentityAttributeTransform>}
     * @memberof IdentityAttributeConfig
     */
    'attributeTransforms'?: Array<IdentityAttributeTransform>;
}
/**
 * Defines a transformation definition for an identity attribute.
 * @export
 * @interface IdentityAttributeTransform
 */
export interface IdentityAttributeTransform {
    /**
     * Name of the identity attribute.
     * @type {string}
     * @memberof IdentityAttributeTransform
     */
    'identityAttributeName'?: string;
    /**
     * 
     * @type {TransformDefinition}
     * @memberof IdentityAttributeTransform
     */
    'transformDefinition'?: TransformDefinition;
}
/**
 * 
 * @export
 * @interface IdentityCertDecisionSummary
 */
export interface IdentityCertDecisionSummary {
    /**
     * Number of entitlement decisions that have been made
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'entitlementDecisionsMade'?: number;
    /**
     * Number of access profile decisions that have been made
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'accessProfileDecisionsMade'?: number;
    /**
     * Number of role decisions that have been made
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'roleDecisionsMade'?: number;
    /**
     * Number of account decisions that have been made
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'accountDecisionsMade'?: number;
    /**
     * The total number of entitlement decisions on the certification, both complete and incomplete
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'entitlementDecisionsTotal'?: number;
    /**
     * The total number of access profile decisions on the certification, both complete and incomplete
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'accessProfileDecisionsTotal'?: number;
    /**
     * The total number of role decisions on the certification, both complete and incomplete
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'roleDecisionsTotal'?: number;
    /**
     * The total number of account decisions on the certification, both complete and incomplete
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'accountDecisionsTotal'?: number;
    /**
     * The number of entitlement decisions that have been made which were approved
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'entitlementsApproved'?: number;
    /**
     * The number of entitlement decisions that have been made which were revoked
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'entitlementsRevoked'?: number;
    /**
     * The number of access profile decisions that have been made which were approved
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'accessProfilesApproved'?: number;
    /**
     * The number of access profile decisions that have been made which were revoked
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'accessProfilesRevoked'?: number;
    /**
     * The number of role decisions that have been made which were approved
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'rolesApproved'?: number;
    /**
     * The number of role decisions that have been made which were revoked
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'rolesRevoked'?: number;
    /**
     * The number of account decisions that have been made which were approved
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'accountsApproved'?: number;
    /**
     * The number of account decisions that have been made which were revoked
     * @type {number}
     * @memberof IdentityCertDecisionSummary
     */
    'accountsRevoked'?: number;
}
/**
 * 
 * @export
 * @interface IdentityCertificationDto
 */
export interface IdentityCertificationDto {
    /**
     * id of the certification
     * @type {string}
     * @memberof IdentityCertificationDto
     */
    'id'?: string;
    /**
     * name of the certification
     * @type {string}
     * @memberof IdentityCertificationDto
     */
    'name'?: string;
    /**
     * 
     * @type {CampaignReference}
     * @memberof IdentityCertificationDto
     */
    'campaign'?: CampaignReference;
    /**
     * Have all decisions been made?
     * @type {boolean}
     * @memberof IdentityCertificationDto
     */
    'completed'?: boolean;
    /**
     * The number of identities for whom all decisions have been made and are complete.
     * @type {number}
     * @memberof IdentityCertificationDto
     */
    'identitiesCompleted'?: number;
    /**
     * The total number of identities in the Certification, both complete and incomplete.
     * @type {number}
     * @memberof IdentityCertificationDto
     */
    'identitiesTotal'?: number;
    /**
     * created date
     * @type {string}
     * @memberof IdentityCertificationDto
     */
    'created'?: string;
    /**
     * modified date
     * @type {string}
     * @memberof IdentityCertificationDto
     */
    'modified'?: string;
    /**
     * The number of approve/revoke/acknowledge decisions that have been made.
     * @type {number}
     * @memberof IdentityCertificationDto
     */
    'decisionsMade'?: number;
    /**
     * The total number of approve/revoke/acknowledge decisions.
     * @type {number}
     * @memberof IdentityCertificationDto
     */
    'decisionsTotal'?: number;
    /**
     * The due date of the certification.
     * @type {string}
     * @memberof IdentityCertificationDto
     */
    'due'?: string;
    /**
     * The date the reviewer signed off on the Certification.
     * @type {string}
     * @memberof IdentityCertificationDto
     */
    'signed'?: string | null;
    /**
     * 
     * @type {Reviewer}
     * @memberof IdentityCertificationDto
     */
    'reviewer'?: Reviewer;
    /**
     * 
     * @type {Reassignment}
     * @memberof IdentityCertificationDto
     */
    'reassignment'?: Reassignment | null;
    /**
     * Identifies if the certification has an error
     * @type {boolean}
     * @memberof IdentityCertificationDto
     */
    'hasErrors'?: boolean;
    /**
     * Description of the certification error
     * @type {string}
     * @memberof IdentityCertificationDto
     */
    'errorMessage'?: string | null;
    /**
     * 
     * @type {CertificationPhase}
     * @memberof IdentityCertificationDto
     */
    'phase'?: CertificationPhase;
}
/**
 * Identity
 * @export
 * @interface IdentityDocument
 */
export interface IdentityDocument {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof IdentityDocument
     */
    'id': string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof IdentityDocument
     */
    'name': string;
    /**
     * 
     * @type {DocumentType}
     * @memberof IdentityDocument
     */
    '_type': DocumentType;
    /**
     * The display name of the identity
     * @type {string}
     * @memberof IdentityDocument
     */
    'displayName'?: string;
    /**
     * The first name of the identity
     * @type {string}
     * @memberof IdentityDocument
     */
    'firstName'?: string;
    /**
     * The last name of the identity
     * @type {string}
     * @memberof IdentityDocument
     */
    'lastName'?: string;
    /**
     * The identity\'s primary email address
     * @type {string}
     * @memberof IdentityDocument
     */
    'email'?: string;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof IdentityDocument
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof IdentityDocument
     */
    'modified'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof IdentityDocument
     */
    'synced'?: string | null;
    /**
     * The phone number of the identity
     * @type {string}
     * @memberof IdentityDocument
     */
    'phone'?: string;
    /**
     * Indicates if the identity is inactive
     * @type {boolean}
     * @memberof IdentityDocument
     */
    'inactive'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof IdentityDocument
     */
    'protected'?: boolean;
    /**
     * The identity\'s status in SailPoint
     * @type {string}
     * @memberof IdentityDocument
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof IdentityDocument
     */
    'employeeNumber'?: string;
    /**
     * 
     * @type {DisplayReference}
     * @memberof IdentityDocument
     */
    'manager'?: DisplayReference;
    /**
     * Indicates if this identity is a manager of other identities
     * @type {boolean}
     * @memberof IdentityDocument
     */
    'isManager'?: boolean;
    /**
     * 
     * @type {Reference1}
     * @memberof IdentityDocument
     */
    'identityProfile'?: Reference1;
    /**
     * 
     * @type {Reference1}
     * @memberof IdentityDocument
     */
    'source'?: Reference1;
    /**
     * a map or dictionary of key/value pairs
     * @type {{ [key: string]: any; }}
     * @memberof IdentityDocument
     */
    'attributes'?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof IdentityDocument
     */
    'processingState'?: string | null;
    /**
     * 
     * @type {ProcessingDetails}
     * @memberof IdentityDocument
     */
    'processingDetails'?: ProcessingDetails;
    /**
     * List of accounts associated with the identity
     * @type {Array<BaseAccount>}
     * @memberof IdentityDocument
     */
    'accounts'?: Array<BaseAccount>;
    /**
     * Number of accounts associated with the identity
     * @type {number}
     * @memberof IdentityDocument
     */
    'accountCount'?: number;
    /**
     * The list of applications the identity has access to
     * @type {Array<App>}
     * @memberof IdentityDocument
     */
    'apps'?: Array<App>;
    /**
     * The number of applications the identity has access to
     * @type {number}
     * @memberof IdentityDocument
     */
    'appCount'?: number;
    /**
     * The list of access items assigned to the identity
     * @type {Array<IdentityAccess>}
     * @memberof IdentityDocument
     */
    'access'?: Array<IdentityAccess>;
    /**
     * The number of access items assigned to the identity
     * @type {number}
     * @memberof IdentityDocument
     */
    'accessCount'?: number;
    /**
     * The number of access profiles assigned to the identity
     * @type {number}
     * @memberof IdentityDocument
     */
    'accessProfileCount'?: number;
    /**
     * The number of entitlements assigned to the identity
     * @type {number}
     * @memberof IdentityDocument
     */
    'entitlementCount'?: number;
    /**
     * The number of roles assigned to the identity
     * @type {number}
     * @memberof IdentityDocument
     */
    'roleCount'?: number;
    /**
     * 
     * @type {Owns}
     * @memberof IdentityDocument
     */
    'owns'?: Owns;
    /**
     * 
     * @type {Array<string>}
     * @memberof IdentityDocument
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface IdentityDocumentAllOf
 */
export interface IdentityDocumentAllOf {
    /**
     * The first name of the identity
     * @type {string}
     * @memberof IdentityDocumentAllOf
     */
    'firstName'?: string;
    /**
     * The last name of the identity
     * @type {string}
     * @memberof IdentityDocumentAllOf
     */
    'lastName'?: string;
    /**
     * The display name of the identity
     * @type {string}
     * @memberof IdentityDocumentAllOf
     */
    'displayName'?: string;
    /**
     * The identity\'s primary email address
     * @type {string}
     * @memberof IdentityDocumentAllOf
     */
    'email'?: string;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof IdentityDocumentAllOf
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof IdentityDocumentAllOf
     */
    'modified'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof IdentityDocumentAllOf
     */
    'synced'?: string | null;
    /**
     * The phone number of the identity
     * @type {string}
     * @memberof IdentityDocumentAllOf
     */
    'phone'?: string;
    /**
     * Indicates if the identity is inactive
     * @type {boolean}
     * @memberof IdentityDocumentAllOf
     */
    'inactive'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof IdentityDocumentAllOf
     */
    'protected'?: boolean;
    /**
     * The identity\'s status in SailPoint
     * @type {string}
     * @memberof IdentityDocumentAllOf
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof IdentityDocumentAllOf
     */
    'employeeNumber'?: string;
    /**
     * 
     * @type {DisplayReference}
     * @memberof IdentityDocumentAllOf
     */
    'manager'?: DisplayReference;
    /**
     * Indicates if this identity is a manager of other identities
     * @type {boolean}
     * @memberof IdentityDocumentAllOf
     */
    'isManager'?: boolean;
    /**
     * 
     * @type {Reference1}
     * @memberof IdentityDocumentAllOf
     */
    'identityProfile'?: Reference1;
    /**
     * 
     * @type {Reference1}
     * @memberof IdentityDocumentAllOf
     */
    'source'?: Reference1;
    /**
     * a map or dictionary of key/value pairs
     * @type {{ [key: string]: any; }}
     * @memberof IdentityDocumentAllOf
     */
    'attributes'?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof IdentityDocumentAllOf
     */
    'processingState'?: string | null;
    /**
     * 
     * @type {ProcessingDetails}
     * @memberof IdentityDocumentAllOf
     */
    'processingDetails'?: ProcessingDetails;
    /**
     * List of accounts associated with the identity
     * @type {Array<BaseAccount>}
     * @memberof IdentityDocumentAllOf
     */
    'accounts'?: Array<BaseAccount>;
    /**
     * Number of accounts associated with the identity
     * @type {number}
     * @memberof IdentityDocumentAllOf
     */
    'accountCount'?: number;
    /**
     * The list of applications the identity has access to
     * @type {Array<App>}
     * @memberof IdentityDocumentAllOf
     */
    'apps'?: Array<App>;
    /**
     * The number of applications the identity has access to
     * @type {number}
     * @memberof IdentityDocumentAllOf
     */
    'appCount'?: number;
    /**
     * The list of access items assigned to the identity
     * @type {Array<IdentityAccess>}
     * @memberof IdentityDocumentAllOf
     */
    'access'?: Array<IdentityAccess>;
    /**
     * The number of access items assigned to the identity
     * @type {number}
     * @memberof IdentityDocumentAllOf
     */
    'accessCount'?: number;
    /**
     * The number of access profiles assigned to the identity
     * @type {number}
     * @memberof IdentityDocumentAllOf
     */
    'accessProfileCount'?: number;
    /**
     * The number of entitlements assigned to the identity
     * @type {number}
     * @memberof IdentityDocumentAllOf
     */
    'entitlementCount'?: number;
    /**
     * The number of roles assigned to the identity
     * @type {number}
     * @memberof IdentityDocumentAllOf
     */
    'roleCount'?: number;
    /**
     * 
     * @type {Owns}
     * @memberof IdentityDocumentAllOf
     */
    'owns'?: Owns;
    /**
     * 
     * @type {Array<string>}
     * @memberof IdentityDocumentAllOf
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface IdentityExceptionReportReference
 */
export interface IdentityExceptionReportReference {
    /**
     * The id of the task result.
     * @type {string}
     * @memberof IdentityExceptionReportReference
     */
    'taskResultId'?: string;
    /**
     * The name of the report.
     * @type {string}
     * @memberof IdentityExceptionReportReference
     */
    'reportName'?: string;
}
/**
 * 
 * @export
 * @interface IdentityProfile
 */
export interface IdentityProfile {
    /**
     * System-generated unique ID of the Object
     * @type {string}
     * @memberof IdentityProfile
     */
    'id'?: string;
    /**
     * Name of the Object
     * @type {string}
     * @memberof IdentityProfile
     */
    'name': string;
    /**
     * Creation date of the Object
     * @type {string}
     * @memberof IdentityProfile
     */
    'created'?: string;
    /**
     * Last modification date of the Object
     * @type {string}
     * @memberof IdentityProfile
     */
    'modified'?: string;
    /**
     * The description of the Identity Profile.
     * @type {string}
     * @memberof IdentityProfile
     */
    'description'?: string | null;
    /**
     * 
     * @type {IdentityProfileAllOfOwner}
     * @memberof IdentityProfile
     */
    'owner'?: IdentityProfileAllOfOwner | null;
    /**
     * The priority for an Identity Profile.
     * @type {number}
     * @memberof IdentityProfile
     */
    'priority'?: number;
    /**
     * 
     * @type {IdentityProfileAllOfAuthoritativeSource}
     * @memberof IdentityProfile
     */
    'authoritativeSource': IdentityProfileAllOfAuthoritativeSource;
    /**
     * True if a identity refresh is needed. Typically triggered when a change on the source has been made.
     * @type {boolean}
     * @memberof IdentityProfile
     */
    'identityRefreshRequired'?: boolean;
    /**
     * The number of identities that belong to the Identity Profile.
     * @type {number}
     * @memberof IdentityProfile
     */
    'identityCount'?: number;
    /**
     * 
     * @type {IdentityAttributeConfig}
     * @memberof IdentityProfile
     */
    'identityAttributeConfig'?: IdentityAttributeConfig;
    /**
     * 
     * @type {IdentityExceptionReportReference}
     * @memberof IdentityProfile
     */
    'identityExceptionReportReference'?: IdentityExceptionReportReference | null;
    /**
     * Indicates the value of requiresPeriodicRefresh attribute for the Identity Profile.
     * @type {boolean}
     * @memberof IdentityProfile
     */
    'hasTimeBasedAttr'?: boolean;
}
/**
 * 
 * @export
 * @interface IdentityProfileAllOf
 */
export interface IdentityProfileAllOf {
    /**
     * The description of the Identity Profile.
     * @type {string}
     * @memberof IdentityProfileAllOf
     */
    'description'?: string | null;
    /**
     * 
     * @type {IdentityProfileAllOfOwner}
     * @memberof IdentityProfileAllOf
     */
    'owner'?: IdentityProfileAllOfOwner | null;
    /**
     * The priority for an Identity Profile.
     * @type {number}
     * @memberof IdentityProfileAllOf
     */
    'priority'?: number;
    /**
     * 
     * @type {IdentityProfileAllOfAuthoritativeSource}
     * @memberof IdentityProfileAllOf
     */
    'authoritativeSource': IdentityProfileAllOfAuthoritativeSource;
    /**
     * True if a identity refresh is needed. Typically triggered when a change on the source has been made.
     * @type {boolean}
     * @memberof IdentityProfileAllOf
     */
    'identityRefreshRequired'?: boolean;
    /**
     * The number of identities that belong to the Identity Profile.
     * @type {number}
     * @memberof IdentityProfileAllOf
     */
    'identityCount'?: number;
    /**
     * 
     * @type {IdentityAttributeConfig}
     * @memberof IdentityProfileAllOf
     */
    'identityAttributeConfig'?: IdentityAttributeConfig;
    /**
     * 
     * @type {IdentityExceptionReportReference}
     * @memberof IdentityProfileAllOf
     */
    'identityExceptionReportReference'?: IdentityExceptionReportReference | null;
    /**
     * Indicates the value of requiresPeriodicRefresh attribute for the Identity Profile.
     * @type {boolean}
     * @memberof IdentityProfileAllOf
     */
    'hasTimeBasedAttr'?: boolean;
}
/**
 * 
 * @export
 * @interface IdentityProfileAllOfAuthoritativeSource
 */
export interface IdentityProfileAllOfAuthoritativeSource {
    /**
     * Type of the object to which this reference applies
     * @type {string}
     * @memberof IdentityProfileAllOfAuthoritativeSource
     */
    'type'?: IdentityProfileAllOfAuthoritativeSourceTypeEnum;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof IdentityProfileAllOfAuthoritativeSource
     */
    'id'?: string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof IdentityProfileAllOfAuthoritativeSource
     */
    'name'?: string;
}

export const IdentityProfileAllOfAuthoritativeSourceTypeEnum = {
    Source: 'SOURCE'
} as const;

export type IdentityProfileAllOfAuthoritativeSourceTypeEnum = typeof IdentityProfileAllOfAuthoritativeSourceTypeEnum[keyof typeof IdentityProfileAllOfAuthoritativeSourceTypeEnum];

/**
 * The owner of the Identity Profile.
 * @export
 * @interface IdentityProfileAllOfOwner
 */
export interface IdentityProfileAllOfOwner {
    /**
     * Type of the object to which this reference applies
     * @type {string}
     * @memberof IdentityProfileAllOfOwner
     */
    'type'?: IdentityProfileAllOfOwnerTypeEnum;
    /**
     * ID of the object to which this reference applies
     * @type {string}
     * @memberof IdentityProfileAllOfOwner
     */
    'id'?: string;
    /**
     * Human-readable display name of the object to which this reference applies
     * @type {string}
     * @memberof IdentityProfileAllOfOwner
     */
    'name'?: string;
}

export const IdentityProfileAllOfOwnerTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type IdentityProfileAllOfOwnerTypeEnum = typeof IdentityProfileAllOfOwnerTypeEnum[keyof typeof IdentityProfileAllOfOwnerTypeEnum];

/**
 * Identity Profile exported object
 * @export
 * @interface IdentityProfileExportedObject
 */
export interface IdentityProfileExportedObject {
    /**
     * Version or object from the target service.
     * @type {number}
     * @memberof IdentityProfileExportedObject
     */
    'version'?: number;
    /**
     * 
     * @type {BaseReferenceDto}
     * @memberof IdentityProfileExportedObject
     */
    'self'?: BaseReferenceDto;
    /**
     * 
     * @type {IdentityProfile}
     * @memberof IdentityProfileExportedObject
     */
    'object'?: IdentityProfile;
}
/**
 * The manager for the identity.
 * @export
 * @interface IdentityReference
 */
export interface IdentityReference {
    /**
     * 
     * @type {DtoType}
     * @memberof IdentityReference
     */
    'type'?: DtoType;
    /**
     * Identity id
     * @type {string}
     * @memberof IdentityReference
     */
    'id'?: string;
    /**
     * Human-readable display name of identity.
     * @type {string}
     * @memberof IdentityReference
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface IdentityReferenceWithNameAndEmail
 */
export interface IdentityReferenceWithNameAndEmail {
    /**
     * The type can only be IDENTITY. This is read-only
     * @type {string}
     * @memberof IdentityReferenceWithNameAndEmail
     */
    'type'?: string;
    /**
     * Identity id.
     * @type {string}
     * @memberof IdentityReferenceWithNameAndEmail
     */
    'id'?: string;
    /**
     * Human-readable display name of identity. This is read-only
     * @type {string}
     * @memberof IdentityReferenceWithNameAndEmail
     */
    'name'?: string;
    /**
     * Email address of identity. This is read-only
     * @type {string}
     * @memberof IdentityReferenceWithNameAndEmail
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface IdentitySummary
 */
export interface IdentitySummary {
    /**
     * ID of this identity summary
     * @type {string}
     * @memberof IdentitySummary
     */
    'id'?: string;
    /**
     * Human-readable display name of identity
     * @type {string}
     * @memberof IdentitySummary
     */
    'name'?: string;
    /**
     * ID of the identity that this summary represents
     * @type {string}
     * @memberof IdentitySummary
     */
    'identityId'?: string;
    /**
     * Indicates if all access items for this summary have been decided on
     * @type {boolean}
     * @memberof IdentitySummary
     */
    'completed'?: boolean;
}
/**
 * Enum representing the currently supported indices. Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */

export const Index = {
    Accessprofiles: 'accessprofiles',
    Accountactivities: 'accountactivities',
    Entitlements: 'entitlements',
    Events: 'events',
    Identities: 'identities',
    Roles: 'roles',
    Star: '*'
} as const;

export type Index = typeof Index[keyof typeof Index];


/**
 * 
 * @export
 * @interface IndexOf
 */
export interface IndexOf {
    /**
     * A substring to search for, searches the entire calling string, and returns the index of the first occurrence of the specified substring.
     * @type {string}
     * @memberof IndexOf
     */
    'substring': string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof IndexOf
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof IndexOf
     */
    'input'?: { [key: string]: any; };
}
/**
 * Inner Hit query object that will cause the specified nested type to be returned as the result matching the supplied query.
 * @export
 * @interface InnerHit
 */
export interface InnerHit {
    /**
     * The search query using the Elasticsearch [Query String Query](https://www.elastic.co/guide/en/elasticsearch/reference/5.2/query-dsl-query-string-query.html#query-string) syntax from the Query DSL extended by SailPoint to support Nested queries.
     * @type {string}
     * @memberof InnerHit
     */
    'query': string;
    /**
     * The nested type to use in the inner hits query.  The nested type [Nested Type](https://www.elastic.co/guide/en/elasticsearch/reference/current/nested.html) refers to a document \"nested\" within another document. For example, an identity can have nested documents for access, accounts, and apps.
     * @type {string}
     * @memberof InnerHit
     */
    'type': string;
}
/**
 * A JSONPatch document as defined by [RFC 6902 - JSON Patch](https://tools.ietf.org/html/rfc6902)
 * @export
 * @interface JsonPatch
 */
export interface JsonPatch {
    /**
     * Operations to be applied
     * @type {Array<JsonPatchOperation>}
     * @memberof JsonPatch
     */
    'operations'?: Array<JsonPatchOperation>;
}
/**
 * A JSONPatch Operation as defined by [RFC 6902 - JSON Patch](https://tools.ietf.org/html/rfc6902)
 * @export
 * @interface JsonPatchOperation
 */
export interface JsonPatchOperation {
    /**
     * The operation to be performed
     * @type {string}
     * @memberof JsonPatchOperation
     */
    'op': JsonPatchOperationOpEnum;
    /**
     * A string JSON Pointer representing the target path to an element to be affected by the operation
     * @type {string}
     * @memberof JsonPatchOperation
     */
    'path': string;
    /**
     * 
     * @type {JsonPatchOperationValue}
     * @memberof JsonPatchOperation
     */
    'value'?: JsonPatchOperationValue;
}

export const JsonPatchOperationOpEnum = {
    Add: 'add',
    Remove: 'remove',
    Replace: 'replace',
    Move: 'move',
    Copy: 'copy',
    Test: 'test'
} as const;

export type JsonPatchOperationOpEnum = typeof JsonPatchOperationOpEnum[keyof typeof JsonPatchOperationOpEnum];

/**
 * The value to be used for the operation, required for \"add\" and \"replace\" operations
 * @export
 * @interface JsonPatchOperationValue
 */
export interface JsonPatchOperationValue {
}
/**
 * 
 * @export
 * @interface JsonPatchOperationValueAnyOfInner
 */
export interface JsonPatchOperationValueAnyOfInner {
}
/**
 * 
 * @export
 * @interface LeftPad
 */
export interface LeftPad {
    /**
     * An integer value for the desired length of the final output string
     * @type {string}
     * @memberof LeftPad
     */
    'length': string;
    /**
     * A string value representing the character that the incoming data should be padded with to get to the desired length   If not provided, the transform will default to a single space (\" \") character for padding 
     * @type {string}
     * @memberof LeftPad
     */
    'padding'?: string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof LeftPad
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof LeftPad
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface LifecycleState
 */
export interface LifecycleState {
    /**
     * System-generated unique ID of the Object
     * @type {string}
     * @memberof LifecycleState
     */
    'id'?: string;
    /**
     * Name of the Object
     * @type {string}
     * @memberof LifecycleState
     */
    'name': string;
    /**
     * Creation date of the Object
     * @type {string}
     * @memberof LifecycleState
     */
    'created'?: string;
    /**
     * Last modification date of the Object
     * @type {string}
     * @memberof LifecycleState
     */
    'modified'?: string;
    /**
     * Whether the lifecycle state is enabled or disabled.
     * @type {boolean}
     * @memberof LifecycleState
     */
    'enabled'?: boolean;
    /**
     * The technical name for lifecycle state. This is for internal use.
     * @type {string}
     * @memberof LifecycleState
     */
    'technicalName': string;
    /**
     * Lifecycle state description.
     * @type {string}
     * @memberof LifecycleState
     */
    'description'?: string;
    /**
     * Number of identities that have the lifecycle state.
     * @type {number}
     * @memberof LifecycleState
     */
    'identityCount'?: number;
    /**
     * 
     * @type {EmailNotificationOption}
     * @memberof LifecycleState
     */
    'emailNotificationOption'?: EmailNotificationOption;
    /**
     * 
     * @type {Array<AccountAction>}
     * @memberof LifecycleState
     */
    'accountActions'?: Array<AccountAction>;
    /**
     * List of unique access-profile IDs that are associated with the lifecycle state.
     * @type {Set<string>}
     * @memberof LifecycleState
     */
    'accessProfileIds'?: Set<string>;
}
/**
 * 
 * @export
 * @interface LifecycleStateAllOf
 */
export interface LifecycleStateAllOf {
    /**
     * Whether the lifecycle state is enabled or disabled.
     * @type {boolean}
     * @memberof LifecycleStateAllOf
     */
    'enabled'?: boolean;
    /**
     * The technical name for lifecycle state. This is for internal use.
     * @type {string}
     * @memberof LifecycleStateAllOf
     */
    'technicalName': string;
    /**
     * Lifecycle state description.
     * @type {string}
     * @memberof LifecycleStateAllOf
     */
    'description'?: string;
    /**
     * Number of identities that have the lifecycle state.
     * @type {number}
     * @memberof LifecycleStateAllOf
     */
    'identityCount'?: number;
    /**
     * 
     * @type {EmailNotificationOption}
     * @memberof LifecycleStateAllOf
     */
    'emailNotificationOption'?: EmailNotificationOption;
    /**
     * 
     * @type {Array<AccountAction>}
     * @memberof LifecycleStateAllOf
     */
    'accountActions'?: Array<AccountAction>;
    /**
     * List of unique access-profile IDs that are associated with the lifecycle state.
     * @type {Set<string>}
     * @memberof LifecycleStateAllOf
     */
    'accessProfileIds'?: Set<string>;
}
/**
 * An indicator of how the locale was selected. *DEFAULT* means the locale is the system default. *REQUEST* means the locale was selected from the request context (i.e., best match based on the *Accept-Language* header). Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */

export const LocaleOrigin = {
    Default: 'DEFAULT',
    Request: 'REQUEST'
} as const;

export type LocaleOrigin = typeof LocaleOrigin[keyof typeof LocaleOrigin];


/**
 * 
 * @export
 * @interface Lookup
 */
export interface Lookup {
    /**
     * This is a JSON object of key-value pairs. The key is the string that will attempt to be matched to the input, and the value is the output string that should be returned if the key is matched   >**Note** the use of the optional default key value here; if none of the three countries in the above example match the input string, the transform will return \"Unknown Region\" for the attribute that is mapped to this transform. 
     * @type {{ [key: string]: any; }}
     * @memberof Lookup
     */
    'table': { [key: string]: any; };
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Lookup
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Lookup
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface Lower
 */
export interface Lower {
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Lower
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Lower
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface ManagerCorrelationMapping
 */
export interface ManagerCorrelationMapping {
    /**
     * Name of the attribute to use for manager correlation. The value found on the account attribute will be used to lookup the manager\'s identity.
     * @type {string}
     * @memberof ManagerCorrelationMapping
     */
    'accountAttribute'?: string;
    /**
     * Name of the identity attribute to search when trying to find a manager using the value from the accountAttribute.
     * @type {string}
     * @memberof ManagerCorrelationMapping
     */
    'identityAttribute'?: string;
}
/**
 * 
 * @export
 * @interface ManualWorkItemDetails
 */
export interface ManualWorkItemDetails {
    /**
     * True if the request for this item was forwarded from one owner to another.
     * @type {boolean}
     * @memberof ManualWorkItemDetails
     */
    'forwarded'?: boolean;
    /**
     * 
     * @type {BaseReferenceDto}
     * @memberof ManualWorkItemDetails
     */
    'originalOwner'?: BaseReferenceDto;
    /**
     * 
     * @type {BaseReferenceDto}
     * @memberof ManualWorkItemDetails
     */
    'currentOwner'?: BaseReferenceDto;
    /**
     * Time at which item was modified.
     * @type {string}
     * @memberof ManualWorkItemDetails
     */
    'modified'?: string;
    /**
     * 
     * @type {ManualWorkItemState}
     * @memberof ManualWorkItemDetails
     */
    'status'?: ManualWorkItemState;
}
/**
 * Indicates the state of the request processing for this item: * PENDING: The request for this item is awaiting processing. * APPROVED: The request for this item has been approved. * REJECTED: The request for this item was rejected. * EXPIRED: The request for this item expired with no action taken. * CANCELLED: The request for this item was cancelled with no user action. * ARCHIVED: The request for this item has been archived after completion.
 * @export
 * @enum {string}
 */

export const ManualWorkItemState = {
    Pending: 'PENDING',
    Approved: 'APPROVED',
    Rejected: 'REJECTED',
    Expired: 'EXPIRED',
    Cancelled: 'CANCELLED',
    Archived: 'ARCHIVED'
} as const;

export type ManualWorkItemState = typeof ManualWorkItemState[keyof typeof ManualWorkItemState];


/**
 * The calculation done on the results of the query
 * @export
 * @interface MetricAggregation
 */
export interface MetricAggregation {
    /**
     * The name of the metric aggregate to be included in the result. If the metric aggregation is omitted, the resulting aggregation will be a count of the documents in the search results.
     * @type {string}
     * @memberof MetricAggregation
     */
    'name': string;
    /**
     * 
     * @type {MetricType}
     * @memberof MetricAggregation
     */
    'type'?: MetricType;
    /**
     * The field the calculation is performed on.  Prefix the field name with \'@\' to reference a nested object. 
     * @type {string}
     * @memberof MetricAggregation
     */
    'field': string;
}
/**
 * Enum representing the currently supported metric aggregation types. Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */

export const MetricType = {
    Count: 'COUNT',
    UniqueCount: 'UNIQUE_COUNT',
    Avg: 'AVG',
    Sum: 'SUM',
    Median: 'MEDIAN',
    Min: 'MIN',
    Max: 'MAX'
} as const;

export type MetricType = typeof MetricType[keyof typeof MetricType];


/**
 * 
 * @export
 * @interface NameNormalizer
 */
export interface NameNormalizer {
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof NameNormalizer
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof NameNormalizer
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface NameType
 */
export interface NameType {
    /**
     * the actor or target name
     * @type {string}
     * @memberof NameType
     */
    'name'?: string;
    /**
     * 
     * @type {DtoType}
     * @memberof NameType
     */
    'type'?: DtoType;
}
/**
 * | Construct       | Date Time Pattern | Description | | ---------       | ----------------- | ----------- | | ISO8601         | `yyyy-MM-dd\'T\'HH:mm:ss.SSSX` | The ISO8601 standard. |           | LDAP            | `yyyyMMddHHmmss.Z`           | The LDAP standard.    | | PEOPLE_SOFT     | `MM/dd/yyyy`                 | The date format People Soft uses. | | EPOCH_TIME_JAVA | # ms from midnight, January 1st, 1970 | The incoming date value as elapsed time in milliseconds from midnight, January 1st, 1970. | | EPOCH_TIME_WIN32| # intervals of 100ns from midnight, January 1st, 1601 | The incoming date value as elapsed time in 100-nanosecond intervals from midnight, January 1st, 1601. | 
 * @export
 * @enum {string}
 */

export const NamedConstructs = {
    Iso8601: 'ISO8601',
    Ldap: 'LDAP',
    PeopleSoft: 'PEOPLE_SOFT',
    EpochTimeJava: 'EPOCH_TIME_JAVA',
    EpochTimeWin32: 'EPOCH_TIME_WIN32'
} as const;

export type NamedConstructs = typeof NamedConstructs[keyof typeof NamedConstructs];


/**
 * The nested aggregation object.
 * @export
 * @interface NestedAggregation
 */
export interface NestedAggregation {
    /**
     * The name of the nested aggregate to be included in the result.
     * @type {string}
     * @memberof NestedAggregation
     */
    'name': string;
    /**
     * The type of the nested object.
     * @type {string}
     * @memberof NestedAggregation
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface NonEmployeeApprovalDecision
 */
export interface NonEmployeeApprovalDecision {
    /**
     * Comment on the approval item.
     * @type {string}
     * @memberof NonEmployeeApprovalDecision
     */
    'comment'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeApprovalItem
 */
export interface NonEmployeeApprovalItem {
    /**
     * Non-Employee approval item id
     * @type {string}
     * @memberof NonEmployeeApprovalItem
     */
    'id'?: string;
    /**
     * 
     * @type {NonEmployeeIdentityReferenceWithId}
     * @memberof NonEmployeeApprovalItem
     */
    'approver'?: NonEmployeeIdentityReferenceWithId;
    /**
     * Requested identity account name
     * @type {string}
     * @memberof NonEmployeeApprovalItem
     */
    'accountName'?: string;
    /**
     * 
     * @type {ApprovalStatus}
     * @memberof NonEmployeeApprovalItem
     */
    'approvalStatus'?: ApprovalStatus;
    /**
     * Approval order
     * @type {number}
     * @memberof NonEmployeeApprovalItem
     */
    'approvalOrder'?: number;
    /**
     * comment of approver
     * @type {string}
     * @memberof NonEmployeeApprovalItem
     */
    'comment'?: string;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeApprovalItem
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeApprovalItem
     */
    'created'?: string;
    /**
     * 
     * @type {NonEmployeeRequestLite}
     * @memberof NonEmployeeApprovalItem
     */
    'nonEmployeeRequest'?: NonEmployeeRequestLite;
}
/**
 * 
 * @export
 * @interface NonEmployeeApprovalItemAllOf
 */
export interface NonEmployeeApprovalItemAllOf {
    /**
     * 
     * @type {NonEmployeeRequestLite}
     * @memberof NonEmployeeApprovalItemAllOf
     */
    'nonEmployeeRequest'?: NonEmployeeRequestLite;
}
/**
 * 
 * @export
 * @interface NonEmployeeApprovalItemBase
 */
export interface NonEmployeeApprovalItemBase {
    /**
     * Non-Employee approval item id
     * @type {string}
     * @memberof NonEmployeeApprovalItemBase
     */
    'id'?: string;
    /**
     * 
     * @type {NonEmployeeIdentityReferenceWithId}
     * @memberof NonEmployeeApprovalItemBase
     */
    'approver'?: NonEmployeeIdentityReferenceWithId;
    /**
     * Requested identity account name
     * @type {string}
     * @memberof NonEmployeeApprovalItemBase
     */
    'accountName'?: string;
    /**
     * 
     * @type {ApprovalStatus}
     * @memberof NonEmployeeApprovalItemBase
     */
    'approvalStatus'?: ApprovalStatus;
    /**
     * Approval order
     * @type {number}
     * @memberof NonEmployeeApprovalItemBase
     */
    'approvalOrder'?: number;
    /**
     * comment of approver
     * @type {string}
     * @memberof NonEmployeeApprovalItemBase
     */
    'comment'?: string;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeApprovalItemBase
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeApprovalItemBase
     */
    'created'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeApprovalItemDetail
 */
export interface NonEmployeeApprovalItemDetail {
    /**
     * Non-Employee approval item id
     * @type {string}
     * @memberof NonEmployeeApprovalItemDetail
     */
    'id'?: string;
    /**
     * 
     * @type {NonEmployeeIdentityReferenceWithId}
     * @memberof NonEmployeeApprovalItemDetail
     */
    'approver'?: NonEmployeeIdentityReferenceWithId;
    /**
     * Requested identity account name
     * @type {string}
     * @memberof NonEmployeeApprovalItemDetail
     */
    'accountName'?: string;
    /**
     * 
     * @type {ApprovalStatus}
     * @memberof NonEmployeeApprovalItemDetail
     */
    'approvalStatus'?: ApprovalStatus;
    /**
     * Approval order
     * @type {number}
     * @memberof NonEmployeeApprovalItemDetail
     */
    'approvalOrder'?: number;
    /**
     * comment of approver
     * @type {string}
     * @memberof NonEmployeeApprovalItemDetail
     */
    'comment'?: string;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeApprovalItemDetail
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeApprovalItemDetail
     */
    'created'?: string;
    /**
     * 
     * @type {NonEmployeeRequestWithoutApprovalItem}
     * @memberof NonEmployeeApprovalItemDetail
     */
    'nonEmployeeRequest'?: NonEmployeeRequestWithoutApprovalItem;
}
/**
 * 
 * @export
 * @interface NonEmployeeApprovalItemDetailAllOf
 */
export interface NonEmployeeApprovalItemDetailAllOf {
    /**
     * 
     * @type {NonEmployeeRequestWithoutApprovalItem}
     * @memberof NonEmployeeApprovalItemDetailAllOf
     */
    'nonEmployeeRequest'?: NonEmployeeRequestWithoutApprovalItem;
}
/**
 * 
 * @export
 * @interface NonEmployeeApprovalSummary
 */
export interface NonEmployeeApprovalSummary {
    /**
     * The number of approved non-employee approval requests.
     * @type {number}
     * @memberof NonEmployeeApprovalSummary
     */
    'approved'?: number;
    /**
     * The number of pending non-employee approval requests.
     * @type {number}
     * @memberof NonEmployeeApprovalSummary
     */
    'pending'?: number;
    /**
     * The number of rejected non-employee approval requests.
     * @type {number}
     * @memberof NonEmployeeApprovalSummary
     */
    'rejected'?: number;
}
/**
 * 
 * @export
 * @interface NonEmployeeBulkUploadJob
 */
export interface NonEmployeeBulkUploadJob {
    /**
     * The bulk upload job\'s ID. (UUID)
     * @type {string}
     * @memberof NonEmployeeBulkUploadJob
     */
    'id'?: string;
    /**
     * The ID of the source to bulk-upload non-employees to. (UUID)
     * @type {string}
     * @memberof NonEmployeeBulkUploadJob
     */
    'sourceId'?: string;
    /**
     * The date-time the job was submitted.
     * @type {string}
     * @memberof NonEmployeeBulkUploadJob
     */
    'created'?: string;
    /**
     * The date-time that the job was last updated.
     * @type {string}
     * @memberof NonEmployeeBulkUploadJob
     */
    'modified'?: string;
    /**
     * Returns the following values indicating the progress or result of the bulk upload job. \"PENDING\" means the job is queued and waiting to be processed. \"IN_PROGRESS\" means the job is currently being processed. \"COMPLETED\" means the job has been completed without any errors. \"ERROR\" means the job failed to process with errors. 
     * @type {string}
     * @memberof NonEmployeeBulkUploadJob
     */
    'status'?: NonEmployeeBulkUploadJobStatusEnum;
}

export const NonEmployeeBulkUploadJobStatusEnum = {
    Pending: 'PENDING',
    InProgress: 'IN_PROGRESS',
    Completed: 'COMPLETED',
    Error: 'ERROR'
} as const;

export type NonEmployeeBulkUploadJobStatusEnum = typeof NonEmployeeBulkUploadJobStatusEnum[keyof typeof NonEmployeeBulkUploadJobStatusEnum];

/**
 * 
 * @export
 * @interface NonEmployeeBulkUploadStatus
 */
export interface NonEmployeeBulkUploadStatus {
    /**
     * Returns the following values indicating the progress or result of the bulk upload job. \"PENDING\" means the job is queued and waiting to be processed. \"IN_PROGRESS\" means the job is currently being processed. \"COMPLETED\" means the job has been completed without any errors. \"ERROR\" means the job failed to process with errors. null means job has been submitted to the source. 
     * @type {string}
     * @memberof NonEmployeeBulkUploadStatus
     */
    'status'?: NonEmployeeBulkUploadStatusStatusEnum;
}

export const NonEmployeeBulkUploadStatusStatusEnum = {
    Pending: 'PENDING',
    InProgress: 'IN_PROGRESS',
    Completed: 'COMPLETED',
    Error: 'ERROR'
} as const;

export type NonEmployeeBulkUploadStatusStatusEnum = typeof NonEmployeeBulkUploadStatusStatusEnum[keyof typeof NonEmployeeBulkUploadStatusStatusEnum];

/**
 * Identifies if the identity is a normal identity or a governance group
 * @export
 * @enum {string}
 */

export const NonEmployeeIdentityDtoType = {
    GovernanceGroup: 'GOVERNANCE_GROUP',
    Identity: 'IDENTITY'
} as const;

export type NonEmployeeIdentityDtoType = typeof NonEmployeeIdentityDtoType[keyof typeof NonEmployeeIdentityDtoType];


/**
 * 
 * @export
 * @interface NonEmployeeIdentityReferenceWithId
 */
export interface NonEmployeeIdentityReferenceWithId {
    /**
     * 
     * @type {NonEmployeeIdentityDtoType}
     * @memberof NonEmployeeIdentityReferenceWithId
     */
    'type'?: NonEmployeeIdentityDtoType;
    /**
     * Identity id
     * @type {string}
     * @memberof NonEmployeeIdentityReferenceWithId
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeIdnUserRequest
 */
export interface NonEmployeeIdnUserRequest {
    /**
     * Identity id.
     * @type {string}
     * @memberof NonEmployeeIdnUserRequest
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface NonEmployeeRecord
 */
export interface NonEmployeeRecord {
    /**
     * Non-Employee record id.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'id'?: string;
    /**
     * Requested identity account name.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'accountName'?: string;
    /**
     * Non-Employee\'s first name.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'firstName'?: string;
    /**
     * Non-Employee\'s last name.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'lastName'?: string;
    /**
     * Non-Employee\'s email.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'email'?: string;
    /**
     * Non-Employee\'s phone.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'phone'?: string;
    /**
     * The account ID of a valid identity to serve as this non-employee\'s manager.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'manager'?: string;
    /**
     * Non-Employee\'s source id.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'sourceId'?: string;
    /**
     * Attribute blob/bag for a non-employee.
     * @type {{ [key: string]: string; }}
     * @memberof NonEmployeeRecord
     */
    'data'?: { [key: string]: string; };
    /**
     * Non-Employee employment start date.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'startDate'?: string;
    /**
     * Non-Employee employment end date.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'endDate'?: string;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeRecord
     */
    'created'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeRecordBulkDeleteRequest
 */
export interface NonEmployeeRecordBulkDeleteRequest {
    /**
     * List of non-employee ids.
     * @type {Array<string>}
     * @memberof NonEmployeeRecordBulkDeleteRequest
     */
    'ids': Array<string>;
}
/**
 * 
 * @export
 * @interface NonEmployeeRecordsBulkUploadRequest
 */
export interface NonEmployeeRecordsBulkUploadRequest {
    /**
     * 
     * @type {string}
     * @memberof NonEmployeeRecordsBulkUploadRequest
     */
    'data': string;
}
/**
 * 
 * @export
 * @interface NonEmployeeRejectApprovalDecision
 */
export interface NonEmployeeRejectApprovalDecision {
    /**
     * Comment on the approval item.
     * @type {string}
     * @memberof NonEmployeeRejectApprovalDecision
     */
    'comment': string;
}
/**
 * 
 * @export
 * @interface NonEmployeeRequest
 */
export interface NonEmployeeRequest {
    /**
     * Non-Employee source id.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'id'?: string;
    /**
     * Source Id associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'sourceId'?: string;
    /**
     * Source name associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'name'?: string;
    /**
     * Source description associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'description'?: string;
    /**
     * Requested identity account name.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'accountName'?: string;
    /**
     * Non-Employee\'s first name.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'firstName'?: string;
    /**
     * Non-Employee\'s last name.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'lastName'?: string;
    /**
     * Non-Employee\'s email.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'email'?: string;
    /**
     * Non-Employee\'s phone.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'phone'?: string;
    /**
     * The account ID of a valid identity to serve as this non-employee\'s manager.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'manager'?: string;
    /**
     * 
     * @type {NonEmployeeSourceLite}
     * @memberof NonEmployeeRequest
     */
    'nonEmployeeSource'?: NonEmployeeSourceLite;
    /**
     * Attribute blob/bag for a non-employee.
     * @type {{ [key: string]: string; }}
     * @memberof NonEmployeeRequest
     */
    'data'?: { [key: string]: string; };
    /**
     * List of approval item for the request
     * @type {Array<NonEmployeeApprovalItemBase>}
     * @memberof NonEmployeeRequest
     */
    'approvalItems'?: Array<NonEmployeeApprovalItemBase>;
    /**
     * 
     * @type {ApprovalStatus}
     * @memberof NonEmployeeRequest
     */
    'approvalStatus'?: ApprovalStatus;
    /**
     * comment of requester
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'comment'?: string;
    /**
     * When the request was completely approved.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'completionDate'?: string;
    /**
     * Non-Employee employment start date.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'startDate'?: string;
    /**
     * Non-Employee employment end date.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'endDate'?: string;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeRequest
     */
    'created'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeRequestAllOf
 */
export interface NonEmployeeRequestAllOf {
    /**
     * Requested identity account name.
     * @type {string}
     * @memberof NonEmployeeRequestAllOf
     */
    'accountName'?: string;
    /**
     * Non-Employee\'s first name.
     * @type {string}
     * @memberof NonEmployeeRequestAllOf
     */
    'firstName'?: string;
    /**
     * Non-Employee\'s last name.
     * @type {string}
     * @memberof NonEmployeeRequestAllOf
     */
    'lastName'?: string;
    /**
     * Non-Employee\'s email.
     * @type {string}
     * @memberof NonEmployeeRequestAllOf
     */
    'email'?: string;
    /**
     * Non-Employee\'s phone.
     * @type {string}
     * @memberof NonEmployeeRequestAllOf
     */
    'phone'?: string;
    /**
     * The account ID of a valid identity to serve as this non-employee\'s manager.
     * @type {string}
     * @memberof NonEmployeeRequestAllOf
     */
    'manager'?: string;
    /**
     * 
     * @type {NonEmployeeSourceLite}
     * @memberof NonEmployeeRequestAllOf
     */
    'nonEmployeeSource'?: NonEmployeeSourceLite;
    /**
     * Attribute blob/bag for a non-employee.
     * @type {{ [key: string]: string; }}
     * @memberof NonEmployeeRequestAllOf
     */
    'data'?: { [key: string]: string; };
    /**
     * List of approval item for the request
     * @type {Array<NonEmployeeApprovalItemBase>}
     * @memberof NonEmployeeRequestAllOf
     */
    'approvalItems'?: Array<NonEmployeeApprovalItemBase>;
    /**
     * 
     * @type {ApprovalStatus}
     * @memberof NonEmployeeRequestAllOf
     */
    'approvalStatus'?: ApprovalStatus;
    /**
     * comment of requester
     * @type {string}
     * @memberof NonEmployeeRequestAllOf
     */
    'comment'?: string;
    /**
     * When the request was completely approved.
     * @type {string}
     * @memberof NonEmployeeRequestAllOf
     */
    'completionDate'?: string;
    /**
     * Non-Employee employment start date.
     * @type {string}
     * @memberof NonEmployeeRequestAllOf
     */
    'startDate'?: string;
    /**
     * Non-Employee employment end date.
     * @type {string}
     * @memberof NonEmployeeRequestAllOf
     */
    'endDate'?: string;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeRequestAllOf
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeRequestAllOf
     */
    'created'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeRequestBody
 */
export interface NonEmployeeRequestBody {
    /**
     * Requested identity account name.
     * @type {string}
     * @memberof NonEmployeeRequestBody
     */
    'accountName': string;
    /**
     * Non-Employee\'s first name.
     * @type {string}
     * @memberof NonEmployeeRequestBody
     */
    'firstName': string;
    /**
     * Non-Employee\'s last name.
     * @type {string}
     * @memberof NonEmployeeRequestBody
     */
    'lastName': string;
    /**
     * Non-Employee\'s email.
     * @type {string}
     * @memberof NonEmployeeRequestBody
     */
    'email': string;
    /**
     * Non-Employee\'s phone.
     * @type {string}
     * @memberof NonEmployeeRequestBody
     */
    'phone': string;
    /**
     * The account ID of a valid identity to serve as this non-employee\'s manager.
     * @type {string}
     * @memberof NonEmployeeRequestBody
     */
    'manager': string;
    /**
     * Non-Employee\'s source id.
     * @type {string}
     * @memberof NonEmployeeRequestBody
     */
    'sourceId': string;
    /**
     * Attribute blob/bag for a non-employee, 10 attributes is the maximum size supported.
     * @type {{ [key: string]: string; }}
     * @memberof NonEmployeeRequestBody
     */
    'data'?: { [key: string]: string; };
    /**
     * Non-Employee employment start date.
     * @type {string}
     * @memberof NonEmployeeRequestBody
     */
    'startDate': string;
    /**
     * Non-Employee employment end date.
     * @type {string}
     * @memberof NonEmployeeRequestBody
     */
    'endDate': string;
}
/**
 * 
 * @export
 * @interface NonEmployeeRequestLite
 */
export interface NonEmployeeRequestLite {
    /**
     * Non-Employee request id.
     * @type {string}
     * @memberof NonEmployeeRequestLite
     */
    'id'?: string;
    /**
     * 
     * @type {NonEmployeeIdentityReferenceWithId}
     * @memberof NonEmployeeRequestLite
     */
    'requester'?: NonEmployeeIdentityReferenceWithId;
}
/**
 * 
 * @export
 * @interface NonEmployeeRequestSummary
 */
export interface NonEmployeeRequestSummary {
    /**
     * The number of approved non-employee requests on all sources that *requested-for* user manages.
     * @type {number}
     * @memberof NonEmployeeRequestSummary
     */
    'approved'?: number;
    /**
     * The number of rejected non-employee requests on all sources that *requested-for* user manages.
     * @type {number}
     * @memberof NonEmployeeRequestSummary
     */
    'rejected'?: number;
    /**
     * The number of pending non-employee requests on all sources that *requested-for* user manages.
     * @type {number}
     * @memberof NonEmployeeRequestSummary
     */
    'pending'?: number;
    /**
     * The number of non-employee records on all sources that *requested-for* user manages.
     * @type {number}
     * @memberof NonEmployeeRequestSummary
     */
    'nonEmployeeCount'?: number;
}
/**
 * 
 * @export
 * @interface NonEmployeeRequestWithoutApprovalItem
 */
export interface NonEmployeeRequestWithoutApprovalItem {
    /**
     * Non-Employee request id.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'id'?: string;
    /**
     * 
     * @type {NonEmployeeIdentityReferenceWithId}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'requester'?: NonEmployeeIdentityReferenceWithId;
    /**
     * Requested identity account name.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'accountName'?: string;
    /**
     * Non-Employee\'s first name.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'firstName'?: string;
    /**
     * Non-Employee\'s last name.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'lastName'?: string;
    /**
     * Non-Employee\'s email.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'email'?: string;
    /**
     * Non-Employee\'s phone.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'phone'?: string;
    /**
     * The account ID of a valid identity to serve as this non-employee\'s manager.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'manager'?: string;
    /**
     * 
     * @type {NonEmployeeSourceLiteWithSchemaAttributes}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'nonEmployeeSource'?: NonEmployeeSourceLiteWithSchemaAttributes;
    /**
     * Attribute blob/bag for a non-employee.
     * @type {{ [key: string]: string; }}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'data'?: { [key: string]: string; };
    /**
     * 
     * @type {ApprovalStatus}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'approvalStatus'?: ApprovalStatus;
    /**
     * comment of requester
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'comment'?: string;
    /**
     * When the request was completely approved.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'completionDate'?: string;
    /**
     * Non-Employee employment start date.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'startDate'?: string;
    /**
     * Non-Employee employment end date.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'endDate'?: string;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItem
     */
    'created'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeRequestWithoutApprovalItemAllOf
 */
export interface NonEmployeeRequestWithoutApprovalItemAllOf {
    /**
     * Requested identity account name.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOf
     */
    'accountName'?: string;
    /**
     * Non-Employee\'s first name.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOf
     */
    'firstName'?: string;
    /**
     * Non-Employee\'s last name.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOf
     */
    'lastName'?: string;
    /**
     * Non-Employee\'s email.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOf
     */
    'email'?: string;
    /**
     * Non-Employee\'s phone.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOf
     */
    'phone'?: string;
    /**
     * The account ID of a valid identity to serve as this non-employee\'s manager.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOf
     */
    'manager'?: string;
    /**
     * 
     * @type {NonEmployeeSourceLiteWithSchemaAttributes}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOf
     */
    'nonEmployeeSource'?: NonEmployeeSourceLiteWithSchemaAttributes;
    /**
     * Attribute blob/bag for a non-employee.
     * @type {{ [key: string]: string; }}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOf
     */
    'data'?: { [key: string]: string; };
    /**
     * 
     * @type {ApprovalStatus}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOf
     */
    'approvalStatus'?: ApprovalStatus;
    /**
     * comment of requester
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOf
     */
    'comment'?: string;
    /**
     * When the request was completely approved.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOf
     */
    'completionDate'?: string;
    /**
     * Non-Employee employment start date.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOf
     */
    'startDate'?: string;
    /**
     * Non-Employee employment end date.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOf
     */
    'endDate'?: string;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOf
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeRequestWithoutApprovalItemAllOf
     */
    'created'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeSchemaAttribute
 */
export interface NonEmployeeSchemaAttribute {
    /**
     * Schema Attribute Id
     * @type {string}
     * @memberof NonEmployeeSchemaAttribute
     */
    'id'?: string;
    /**
     * True if this schema attribute is mandatory on all non-employees sources.
     * @type {boolean}
     * @memberof NonEmployeeSchemaAttribute
     */
    'system'?: boolean;
    /**
     * When the schema attribute was last modified.
     * @type {string}
     * @memberof NonEmployeeSchemaAttribute
     */
    'modified'?: string;
    /**
     * When the schema attribute was created.
     * @type {string}
     * @memberof NonEmployeeSchemaAttribute
     */
    'created'?: string;
    /**
     * 
     * @type {NonEmployeeSchemaAttributeType}
     * @memberof NonEmployeeSchemaAttribute
     */
    'type': NonEmployeeSchemaAttributeType;
    /**
     * Label displayed on the UI for this schema attribute.
     * @type {string}
     * @memberof NonEmployeeSchemaAttribute
     */
    'label': string;
    /**
     * The technical name of the attribute. Must be unique per source.
     * @type {string}
     * @memberof NonEmployeeSchemaAttribute
     */
    'technicalName': string;
    /**
     * help text displayed by UI.
     * @type {string}
     * @memberof NonEmployeeSchemaAttribute
     */
    'helpText'?: string;
    /**
     * Hint text that fills UI box.
     * @type {string}
     * @memberof NonEmployeeSchemaAttribute
     */
    'placeholder'?: string;
    /**
     * If true, the schema attribute is required for all non-employees in the source
     * @type {boolean}
     * @memberof NonEmployeeSchemaAttribute
     */
    'required'?: boolean;
}
/**
 * 
 * @export
 * @interface NonEmployeeSchemaAttributeBody
 */
export interface NonEmployeeSchemaAttributeBody {
    /**
     * Type of the attribute. Only type \'TEXT\' is supported for custom attributes.
     * @type {string}
     * @memberof NonEmployeeSchemaAttributeBody
     */
    'type': string;
    /**
     * Label displayed on the UI for this schema attribute.
     * @type {string}
     * @memberof NonEmployeeSchemaAttributeBody
     */
    'label': string;
    /**
     * The technical name of the attribute. Must be unique per source.
     * @type {string}
     * @memberof NonEmployeeSchemaAttributeBody
     */
    'technicalName': string;
    /**
     * help text displayed by UI.
     * @type {string}
     * @memberof NonEmployeeSchemaAttributeBody
     */
    'helpText'?: string;
    /**
     * Hint text that fills UI box.
     * @type {string}
     * @memberof NonEmployeeSchemaAttributeBody
     */
    'placeholder'?: string;
    /**
     * If true, the schema attribute is required for all non-employees in the source
     * @type {boolean}
     * @memberof NonEmployeeSchemaAttributeBody
     */
    'required'?: boolean;
}
/**
 * Enum representing the type of data a schema attribute accepts.
 * @export
 * @enum {string}
 */

export const NonEmployeeSchemaAttributeType = {
    Text: 'TEXT',
    Date: 'DATE',
    Identity: 'IDENTITY'
} as const;

export type NonEmployeeSchemaAttributeType = typeof NonEmployeeSchemaAttributeType[keyof typeof NonEmployeeSchemaAttributeType];


/**
 * 
 * @export
 * @interface NonEmployeeSource
 */
export interface NonEmployeeSource {
    /**
     * Non-Employee source id.
     * @type {string}
     * @memberof NonEmployeeSource
     */
    'id'?: string;
    /**
     * Source Id associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSource
     */
    'sourceId'?: string;
    /**
     * Source name associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSource
     */
    'name'?: string;
    /**
     * Source description associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSource
     */
    'description'?: string;
    /**
     * List of approvers
     * @type {Array<NonEmployeeIdentityReferenceWithId>}
     * @memberof NonEmployeeSource
     */
    'approvers'?: Array<NonEmployeeIdentityReferenceWithId>;
    /**
     * List of account managers
     * @type {Array<NonEmployeeIdentityReferenceWithId>}
     * @memberof NonEmployeeSource
     */
    'accountManagers'?: Array<NonEmployeeIdentityReferenceWithId>;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeSource
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeSource
     */
    'created'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeSourceAllOf
 */
export interface NonEmployeeSourceAllOf {
    /**
     * List of approvers
     * @type {Array<NonEmployeeIdentityReferenceWithId>}
     * @memberof NonEmployeeSourceAllOf
     */
    'approvers'?: Array<NonEmployeeIdentityReferenceWithId>;
    /**
     * List of account managers
     * @type {Array<NonEmployeeIdentityReferenceWithId>}
     * @memberof NonEmployeeSourceAllOf
     */
    'accountManagers'?: Array<NonEmployeeIdentityReferenceWithId>;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeSourceAllOf
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeSourceAllOf
     */
    'created'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeSourceLite
 */
export interface NonEmployeeSourceLite {
    /**
     * Non-Employee source id.
     * @type {string}
     * @memberof NonEmployeeSourceLite
     */
    'id'?: string;
    /**
     * Source Id associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceLite
     */
    'sourceId'?: string;
    /**
     * Source name associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceLite
     */
    'name'?: string;
    /**
     * Source description associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceLite
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeSourceLiteWithSchemaAttributes
 */
export interface NonEmployeeSourceLiteWithSchemaAttributes {
    /**
     * Non-Employee source id.
     * @type {string}
     * @memberof NonEmployeeSourceLiteWithSchemaAttributes
     */
    'id'?: string;
    /**
     * Source Id associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceLiteWithSchemaAttributes
     */
    'sourceId'?: string;
    /**
     * Source name associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceLiteWithSchemaAttributes
     */
    'name'?: string;
    /**
     * Source description associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceLiteWithSchemaAttributes
     */
    'description'?: string;
    /**
     * List of schema attributes associated with this non-employee source.
     * @type {Array<NonEmployeeSchemaAttribute>}
     * @memberof NonEmployeeSourceLiteWithSchemaAttributes
     */
    'schemaAttributes'?: Array<NonEmployeeSchemaAttribute>;
}
/**
 * 
 * @export
 * @interface NonEmployeeSourceLiteWithSchemaAttributesAllOf
 */
export interface NonEmployeeSourceLiteWithSchemaAttributesAllOf {
    /**
     * List of schema attributes associated with this non-employee source.
     * @type {Array<NonEmployeeSchemaAttribute>}
     * @memberof NonEmployeeSourceLiteWithSchemaAttributesAllOf
     */
    'schemaAttributes'?: Array<NonEmployeeSchemaAttribute>;
}
/**
 * 
 * @export
 * @interface NonEmployeeSourceRequestBody
 */
export interface NonEmployeeSourceRequestBody {
    /**
     * Name of non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceRequestBody
     */
    'name': string;
    /**
     * Description of non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceRequestBody
     */
    'description': string;
    /**
     * 
     * @type {NonEmployeeIdnUserRequest}
     * @memberof NonEmployeeSourceRequestBody
     */
    'owner': NonEmployeeIdnUserRequest;
    /**
     * The ID for the management workgroup that contains source sub-admins
     * @type {string}
     * @memberof NonEmployeeSourceRequestBody
     */
    'managementWorkgroup'?: string;
    /**
     * List of approvers.
     * @type {Array<NonEmployeeIdnUserRequest>}
     * @memberof NonEmployeeSourceRequestBody
     */
    'approvers'?: Array<NonEmployeeIdnUserRequest>;
    /**
     * List of account managers.
     * @type {Array<NonEmployeeIdnUserRequest>}
     * @memberof NonEmployeeSourceRequestBody
     */
    'accountManagers'?: Array<NonEmployeeIdnUserRequest>;
}
/**
 * 
 * @export
 * @interface NonEmployeeSourceWithCloudExternalId
 */
export interface NonEmployeeSourceWithCloudExternalId {
    /**
     * Non-Employee source id.
     * @type {string}
     * @memberof NonEmployeeSourceWithCloudExternalId
     */
    'id'?: string;
    /**
     * Source Id associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceWithCloudExternalId
     */
    'sourceId'?: string;
    /**
     * Source name associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceWithCloudExternalId
     */
    'name'?: string;
    /**
     * Source description associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceWithCloudExternalId
     */
    'description'?: string;
    /**
     * List of approvers
     * @type {Array<NonEmployeeIdentityReferenceWithId>}
     * @memberof NonEmployeeSourceWithCloudExternalId
     */
    'approvers'?: Array<NonEmployeeIdentityReferenceWithId>;
    /**
     * List of account managers
     * @type {Array<NonEmployeeIdentityReferenceWithId>}
     * @memberof NonEmployeeSourceWithCloudExternalId
     */
    'accountManagers'?: Array<NonEmployeeIdentityReferenceWithId>;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeSourceWithCloudExternalId
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeSourceWithCloudExternalId
     */
    'created'?: string;
    /**
     * Legacy ID used for sources from the V1 API. This attribute will be removed from a future version of the API and will not be considered a breaking change. No clients should rely on this ID always being present.
     * @type {string}
     * @memberof NonEmployeeSourceWithCloudExternalId
     */
    'cloudExternalId'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeSourceWithCloudExternalIdAllOf
 */
export interface NonEmployeeSourceWithCloudExternalIdAllOf {
    /**
     * Legacy ID used for sources from the V1 API. This attribute will be removed from a future version of the API and will not be considered a breaking change. No clients should rely on this ID always being present.
     * @type {string}
     * @memberof NonEmployeeSourceWithCloudExternalIdAllOf
     */
    'cloudExternalId'?: string;
}
/**
 * 
 * @export
 * @interface NonEmployeeSourceWithNECount
 */
export interface NonEmployeeSourceWithNECount {
    /**
     * Non-Employee source id.
     * @type {string}
     * @memberof NonEmployeeSourceWithNECount
     */
    'id'?: string;
    /**
     * Source Id associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceWithNECount
     */
    'sourceId'?: string;
    /**
     * Source name associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceWithNECount
     */
    'name'?: string;
    /**
     * Source description associated with this non-employee source.
     * @type {string}
     * @memberof NonEmployeeSourceWithNECount
     */
    'description'?: string;
    /**
     * List of approvers
     * @type {Array<NonEmployeeIdentityReferenceWithId>}
     * @memberof NonEmployeeSourceWithNECount
     */
    'approvers'?: Array<NonEmployeeIdentityReferenceWithId>;
    /**
     * List of account managers
     * @type {Array<NonEmployeeIdentityReferenceWithId>}
     * @memberof NonEmployeeSourceWithNECount
     */
    'accountManagers'?: Array<NonEmployeeIdentityReferenceWithId>;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof NonEmployeeSourceWithNECount
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof NonEmployeeSourceWithNECount
     */
    'created'?: string;
    /**
     * Number of non-employee records associated with this source.
     * @type {number}
     * @memberof NonEmployeeSourceWithNECount
     */
    'nonEmployeeCount'?: number;
}
/**
 * 
 * @export
 * @interface NonEmployeeSourceWithNECountAllOf
 */
export interface NonEmployeeSourceWithNECountAllOf {
    /**
     * Number of non-employee records associated with this source.
     * @type {number}
     * @memberof NonEmployeeSourceWithNECountAllOf
     */
    'nonEmployeeCount'?: number;
}
/**
 * Response model for import of a single object.
 * @export
 * @interface ObjectImportResult
 */
export interface ObjectImportResult {
    /**
     * Informational messages returned from the target service on import.
     * @type {Array<SpConfigMessage>}
     * @memberof ObjectImportResult
     */
    'infos': Array<SpConfigMessage>;
    /**
     * Warning messages returned from the target service on import.
     * @type {Array<SpConfigMessage>}
     * @memberof ObjectImportResult
     */
    'warnings': Array<SpConfigMessage>;
    /**
     * Error messages returned from the target service on import.
     * @type {Array<SpConfigMessage>}
     * @memberof ObjectImportResult
     */
    'errors': Array<SpConfigMessage>;
    /**
     * References to objects that were created or updated by the import.
     * @type {Array<BaseReferenceDto>}
     * @memberof ObjectImportResult
     */
    'importedObjects': Array<BaseReferenceDto>;
}
/**
 * 
 * @export
 * @interface OriginalRequest
 */
export interface OriginalRequest {
    /**
     * the account id
     * @type {string}
     * @memberof OriginalRequest
     */
    'accountId'?: string;
    /**
     * 
     * @type {Array<AttributeRequest>}
     * @memberof OriginalRequest
     */
    'attributeRequests'?: Array<AttributeRequest>;
    /**
     * the operation that was used
     * @type {string}
     * @memberof OriginalRequest
     */
    'op'?: string;
    /**
     * 
     * @type {AccountSource}
     * @memberof OriginalRequest
     */
    'source'?: AccountSource;
}
/**
 * 
 * @export
 * @interface Owner
 */
export interface Owner {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof Owner
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof Owner
     */
    'name'?: string;
    /**
     * 
     * @type {DtoType}
     * @memberof Owner
     */
    'type'?: DtoType;
    /**
     * The email of the identity
     * @type {string}
     * @memberof Owner
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface OwnerAllOf
 */
export interface OwnerAllOf {
    /**
     * The email of the identity
     * @type {string}
     * @memberof OwnerAllOf
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface Owns
 */
export interface Owns {
    /**
     * 
     * @type {Array<Reference1>}
     * @memberof Owns
     */
    'sources'?: Array<Reference1>;
    /**
     * 
     * @type {Array<Reference1>}
     * @memberof Owns
     */
    'entitlements'?: Array<Reference1>;
    /**
     * 
     * @type {Array<Reference1>}
     * @memberof Owns
     */
    'accessProfiles'?: Array<Reference1>;
    /**
     * 
     * @type {Array<Reference1>}
     * @memberof Owns
     */
    'roles'?: Array<Reference1>;
    /**
     * 
     * @type {Array<Reference1>}
     * @memberof Owns
     */
    'apps'?: Array<Reference1>;
    /**
     * 
     * @type {Array<Reference1>}
     * @memberof Owns
     */
    'governanceGroups'?: Array<Reference1>;
    /**
     * 
     * @type {boolean}
     * @memberof Owns
     */
    'fallbackApprover'?: boolean;
}
/**
 * 
 * @export
 * @interface PasswordChangeRequest
 */
export interface PasswordChangeRequest {
    /**
     * The identity ID that requested the password change
     * @type {string}
     * @memberof PasswordChangeRequest
     */
    'identityId'?: string;
    /**
     * The RSA encrypted password
     * @type {string}
     * @memberof PasswordChangeRequest
     */
    'encryptedPassword'?: string;
    /**
     * The encryption key ID
     * @type {string}
     * @memberof PasswordChangeRequest
     */
    'publicKeyId'?: string;
    /**
     * Account ID of the account This is specified per account schema in the source configuration. It is used to distinguish accounts. More info can be found here https://community.sailpoint.com/t5/IdentityNow-Connectors/How-do-I-designate-an-account-attribute-as-the-Account-ID-for-a/ta-p/80350
     * @type {string}
     * @memberof PasswordChangeRequest
     */
    'accountId'?: string;
    /**
     * The ID of the source for which identity is requesting the password change
     * @type {string}
     * @memberof PasswordChangeRequest
     */
    'sourceId'?: string;
}
/**
 * 
 * @export
 * @interface PasswordChangeResponse
 */
export interface PasswordChangeResponse {
    /**
     * The password change request ID
     * @type {string}
     * @memberof PasswordChangeResponse
     */
    'requestId'?: string | null;
    /**
     * Password change state
     * @type {string}
     * @memberof PasswordChangeResponse
     */
    'state'?: PasswordChangeResponseStateEnum;
}

export const PasswordChangeResponseStateEnum = {
    InProgress: 'IN_PROGRESS',
    Finished: 'FINISHED',
    Failed: 'FAILED'
} as const;

export type PasswordChangeResponseStateEnum = typeof PasswordChangeResponseStateEnum[keyof typeof PasswordChangeResponseStateEnum];

/**
 * 
 * @export
 * @interface PasswordInfo
 */
export interface PasswordInfo {
    /**
     * Identity ID
     * @type {string}
     * @memberof PasswordInfo
     */
    'identityId'?: string;
    /**
     * source ID
     * @type {string}
     * @memberof PasswordInfo
     */
    'sourceId'?: string;
    /**
     * public key ID
     * @type {string}
     * @memberof PasswordInfo
     */
    'publicKeyId'?: string;
    /**
     * User\'s public key with Base64 encoding
     * @type {string}
     * @memberof PasswordInfo
     */
    'publicKey'?: string;
    /**
     * Account info related to queried identity and source
     * @type {Array<PasswordInfoAccount>}
     * @memberof PasswordInfo
     */
    'accounts'?: Array<PasswordInfoAccount>;
    /**
     * Password constraints
     * @type {Array<string>}
     * @memberof PasswordInfo
     */
    'policies'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PasswordInfoAccount
 */
export interface PasswordInfoAccount {
    /**
     * Account ID of the account. This is specified per account schema in the source configuration. It is used to distinguish accounts. More info can be found here https://community.sailpoint.com/t5/IdentityNow-Connectors/How-do-I-designate-an-account-attribute-as-the-Account-ID-for-a/ta-p/80350
     * @type {string}
     * @memberof PasswordInfoAccount
     */
    'accountId'?: string;
    /**
     * Display name of the account. This is specified per account schema in the source configuration. It is used to display name of the account. More info can be found here https://community.sailpoint.com/t5/IdentityNow-Connectors/How-do-I-designate-an-account-attribute-as-the-Account-Name-for/ta-p/74008
     * @type {string}
     * @memberof PasswordInfoAccount
     */
    'accountName'?: string;
}
/**
 * 
 * @export
 * @interface PasswordInfoQueryDTO
 */
export interface PasswordInfoQueryDTO {
    /**
     * The login name of the user
     * @type {string}
     * @memberof PasswordInfoQueryDTO
     */
    'userName'?: string;
    /**
     * The display name of the source
     * @type {string}
     * @memberof PasswordInfoQueryDTO
     */
    'sourceName'?: string;
}
/**
 * 
 * @export
 * @interface PasswordStatus
 */
export interface PasswordStatus {
    /**
     * The password change request ID
     * @type {string}
     * @memberof PasswordStatus
     */
    'requestId'?: string | null;
    /**
     * Password change state
     * @type {string}
     * @memberof PasswordStatus
     */
    'state'?: PasswordStatusStateEnum;
    /**
     * The errors during the password change request
     * @type {Array<string>}
     * @memberof PasswordStatus
     */
    'errors'?: Array<string>;
    /**
     * List of source IDs in the password change request
     * @type {Array<string>}
     * @memberof PasswordStatus
     */
    'sourceIds'?: Array<string>;
}

export const PasswordStatusStateEnum = {
    InProgress: 'IN_PROGRESS',
    Finished: 'FINISHED',
    Failed: 'FAILED'
} as const;

export type PasswordStatusStateEnum = typeof PasswordStatusStateEnum[keyof typeof PasswordStatusStateEnum];

/**
 * 
 * @export
 * @interface PendingApproval
 */
export interface PendingApproval {
    /**
     * The approval id.
     * @type {string}
     * @memberof PendingApproval
     */
    'id'?: string;
    /**
     * The name of the approval.
     * @type {string}
     * @memberof PendingApproval
     */
    'name'?: string;
    /**
     * When the approval was created.
     * @type {string}
     * @memberof PendingApproval
     */
    'created'?: string;
    /**
     * When the approval was modified last time.
     * @type {string}
     * @memberof PendingApproval
     */
    'modified'?: string;
    /**
     * When the access-request was created.
     * @type {string}
     * @memberof PendingApproval
     */
    'requestCreated'?: string;
    /**
     * 
     * @type {AccessRequestType}
     * @memberof PendingApproval
     */
    'requestType'?: AccessRequestType;
    /**
     * 
     * @type {BaseReferenceDto}
     * @memberof PendingApproval
     */
    'requester'?: BaseReferenceDto;
    /**
     * 
     * @type {BaseReferenceDto}
     * @memberof PendingApproval
     */
    'requestedFor'?: BaseReferenceDto;
    /**
     * 
     * @type {BaseReferenceDto}
     * @memberof PendingApproval
     */
    'owner'?: BaseReferenceDto;
    /**
     * 
     * @type {RequestableObjectReference}
     * @memberof PendingApproval
     */
    'requestedObject'?: RequestableObjectReference;
    /**
     * 
     * @type {CommentDto}
     * @memberof PendingApproval
     */
    'requesterComment'?: CommentDto;
    /**
     * The history of the previous reviewers comments.
     * @type {Array<CommentDto>}
     * @memberof PendingApproval
     */
    'previousReviewersComments'?: Array<CommentDto>;
    /**
     * The history of approval forward action.
     * @type {Array<ApprovalForwardHistory>}
     * @memberof PendingApproval
     */
    'forwardHistory'?: Array<ApprovalForwardHistory>;
    /**
     * When true the rejector has to provide comments when rejecting
     * @type {boolean}
     * @memberof PendingApproval
     */
    'commentRequiredWhenRejected'?: boolean;
    /**
     * 
     * @type {PendingApprovalAction}
     * @memberof PendingApproval
     */
    'actionInProcess'?: PendingApprovalAction;
    /**
     * The date the role or access profile is no longer assigned to the specified identity.
     * @type {string}
     * @memberof PendingApproval
     */
    'removeDate'?: string;
    /**
     * If true, then the request is to change the remove date or sunset date.
     * @type {boolean}
     * @memberof PendingApproval
     */
    'removeDateUpdateRequested'?: boolean;
    /**
     * The remove date or sunset date that was assigned at the time of the request.
     * @type {string}
     * @memberof PendingApproval
     */
    'currentRemoveDate'?: string;
    /**
     * 
     * @type {SodViolationContextCheckCompleted}
     * @memberof PendingApproval
     */
    'sodViolationContext'?: SodViolationContextCheckCompleted;
}
/**
 * Enum represents action that is being processed on an approval.
 * @export
 * @enum {string}
 */

export const PendingApprovalAction = {
    Approved: 'APPROVED',
    Rejected: 'REJECTED',
    Forwarded: 'FORWARDED'
} as const;

export type PendingApprovalAction = typeof PendingApprovalAction[keyof typeof PendingApprovalAction];


/**
 * Provides additional details about the pre-approval trigger for this request.
 * @export
 * @interface PreApprovalTriggerDetails
 */
export interface PreApprovalTriggerDetails {
    /**
     * Comment left for the pre-approval decision
     * @type {string}
     * @memberof PreApprovalTriggerDetails
     */
    'comment'?: string;
    /**
     * The reviewer of the pre-approval decision
     * @type {string}
     * @memberof PreApprovalTriggerDetails
     */
    'reviewer'?: string;
    /**
     * The decision of the pre-approval trigger
     * @type {string}
     * @memberof PreApprovalTriggerDetails
     */
    'decision'?: PreApprovalTriggerDetailsDecisionEnum;
}

export const PreApprovalTriggerDetailsDecisionEnum = {
    Approved: 'APPROVED',
    Rejected: 'REJECTED'
} as const;

export type PreApprovalTriggerDetailsDecisionEnum = typeof PreApprovalTriggerDetailsDecisionEnum[keyof typeof PreApprovalTriggerDetailsDecisionEnum];

/**
 * 
 * @export
 * @interface ProcessingDetails
 */
export interface ProcessingDetails {
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof ProcessingDetails
     */
    'date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProcessingDetails
     */
    'stage'?: string;
    /**
     * 
     * @type {number}
     * @memberof ProcessingDetails
     */
    'retryCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProcessingDetails
     */
    'stackTrace'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessingDetails
     */
    'message'?: string;
}
/**
 * Specification of a Service Desk integration provisioning configuration.
 * @export
 * @interface ProvisioningConfig
 */
export interface ProvisioningConfig {
    /**
     * Specifies whether this configuration is used to manage provisioning requests for all sources from the org.  If true, no managedResourceRefs are allowed.
     * @type {boolean}
     * @memberof ProvisioningConfig
     */
    'universalManager'?: boolean;
    /**
     * References to sources for the Service Desk integration template.  May only be specified if universalManager is false.
     * @type {Array<ProvisioningConfigManagedResourceRefsInner>}
     * @memberof ProvisioningConfig
     */
    'managedResourceRefs'?: Array<ProvisioningConfigManagedResourceRefsInner>;
    /**
     * 
     * @type {ProvisioningConfigPlanInitializerScript}
     * @memberof ProvisioningConfig
     */
    'planInitializerScript'?: ProvisioningConfigPlanInitializerScript;
}
/**
 * 
 * @export
 * @interface ProvisioningConfigManagedResourceRefsInner
 */
export interface ProvisioningConfigManagedResourceRefsInner {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof ProvisioningConfigManagedResourceRefsInner
     */
    'type'?: ProvisioningConfigManagedResourceRefsInnerTypeEnum;
    /**
     * ID of the source
     * @type {string}
     * @memberof ProvisioningConfigManagedResourceRefsInner
     */
    'id'?: string;
    /**
     * Human-readable display name of the source
     * @type {string}
     * @memberof ProvisioningConfigManagedResourceRefsInner
     */
    'name'?: string;
}

export const ProvisioningConfigManagedResourceRefsInnerTypeEnum = {
    Source: 'SOURCE'
} as const;

export type ProvisioningConfigManagedResourceRefsInnerTypeEnum = typeof ProvisioningConfigManagedResourceRefsInnerTypeEnum[keyof typeof ProvisioningConfigManagedResourceRefsInnerTypeEnum];

/**
 * This is a reference to a plan initializer script.
 * @export
 * @interface ProvisioningConfigPlanInitializerScript
 */
export interface ProvisioningConfigPlanInitializerScript {
    /**
     * This is a Rule that allows provisioning instruction changes.
     * @type {string}
     * @memberof ProvisioningConfigPlanInitializerScript
     */
    'source'?: string;
}
/**
 * Provides additional details about provisioning for this request.
 * @export
 * @interface ProvisioningDetails
 */
export interface ProvisioningDetails {
    /**
     * Ordered CSV of sub phase references to objects that contain more information about provisioning. For example, this can contain \"manualWorkItemDetails\" which indicate that there is further information in that object for this phase.
     * @type {string}
     * @memberof ProvisioningDetails
     */
    'orderedSubPhaseReferences'?: string;
}
/**
 * 
 * @export
 * @interface ProvisioningPolicy
 */
export interface ProvisioningPolicy {
    /**
     * the provisioning policy name
     * @type {string}
     * @memberof ProvisioningPolicy
     */
    'name': string;
    /**
     * the description of the provisioning policy
     * @type {string}
     * @memberof ProvisioningPolicy
     */
    'description'?: string;
    /**
     * 
     * @type {UsageType}
     * @memberof ProvisioningPolicy
     */
    'usageType'?: UsageType;
    /**
     * 
     * @type {Array<FieldDetailsDto>}
     * @memberof ProvisioningPolicy
     */
    'fields'?: Array<FieldDetailsDto>;
}
/**
 * 
 * @export
 * @interface ProvisioningPolicyDto
 */
export interface ProvisioningPolicyDto {
    /**
     * the provisioning policy name
     * @type {string}
     * @memberof ProvisioningPolicyDto
     */
    'name': string;
    /**
     * the description of the provisioning policy
     * @type {string}
     * @memberof ProvisioningPolicyDto
     */
    'description'?: string;
    /**
     * 
     * @type {UsageType}
     * @memberof ProvisioningPolicyDto
     */
    'usageType'?: UsageType;
    /**
     * 
     * @type {Array<FieldDetailsDto>}
     * @memberof ProvisioningPolicyDto
     */
    'fields'?: Array<FieldDetailsDto>;
}
/**
 * Provisioning state of an account activity item
 * @export
 * @enum {string}
 */

export const ProvisioningState = {
    Pending: 'PENDING',
    Finished: 'FINISHED',
    Unverifiable: 'UNVERIFIABLE',
    Commited: 'COMMITED',
    Failed: 'FAILED',
    Retry: 'RETRY'
} as const;

export type ProvisioningState = typeof ProvisioningState[keyof typeof ProvisioningState];


/**
 * Details about a public identity
 * @export
 * @interface PublicIdentity
 */
export interface PublicIdentity {
    /**
     * Identity id
     * @type {string}
     * @memberof PublicIdentity
     */
    'id'?: string;
    /**
     * Human-readable display name of identity.
     * @type {string}
     * @memberof PublicIdentity
     */
    'name'?: string;
    /**
     * Alternate unique identifier for the identity.
     * @type {string}
     * @memberof PublicIdentity
     */
    'alias'?: string;
    /**
     * Email address of identity.
     * @type {string}
     * @memberof PublicIdentity
     */
    'email'?: string | null;
    /**
     * The lifecycle status for the identity
     * @type {string}
     * @memberof PublicIdentity
     */
    'status'?: string | null;
    /**
     * 
     * @type {IdentityReference}
     * @memberof PublicIdentity
     */
    'manager'?: IdentityReference | null;
    /**
     * The public identity attributes of the identity
     * @type {Array<IdentityAttribute1>}
     * @memberof PublicIdentity
     */
    'attributes'?: Array<IdentityAttribute1>;
}
/**
 * Used to map an attribute key for an Identity to its display name.
 * @export
 * @interface PublicIdentityAttributeConfig
 */
export interface PublicIdentityAttributeConfig {
    /**
     * The attribute key
     * @type {string}
     * @memberof PublicIdentityAttributeConfig
     */
    'key'?: string;
    /**
     * The attribute display name
     * @type {string}
     * @memberof PublicIdentityAttributeConfig
     */
    'name'?: string;
}
/**
 * Details of up to 5 Identity attributes that will be publicly accessible for all Identities to anyone in the org.
 * @export
 * @interface PublicIdentityConfig
 */
export interface PublicIdentityConfig {
    /**
     * Up to 5 identity attributes that will be available to everyone in the org for all users in the org.
     * @type {Array<PublicIdentityAttributeConfig>}
     * @memberof PublicIdentityConfig
     */
    'attributes'?: Array<PublicIdentityAttributeConfig>;
    /**
     * When this configuration was last modified.
     * @type {string}
     * @memberof PublicIdentityConfig
     */
    'modified'?: string | null;
    /**
     * 
     * @type {IdentityReference}
     * @memberof PublicIdentityConfig
     */
    'modifiedBy'?: IdentityReference | null;
}
/**
 * Query parameters used to construct an Elasticsearch query object.
 * @export
 * @interface Query
 */
export interface Query {
    /**
     * The query using the Elasticsearch [Query String Query](https://www.elastic.co/guide/en/elasticsearch/reference/5.2/query-dsl-query-string-query.html#query-string) syntax from the Query DSL extended by SailPoint to support Nested queries.
     * @type {string}
     * @memberof Query
     */
    'query'?: string;
    /**
     * The fields to which the specified query will be applied.  The available fields are dependent on the indice(s) being searched on.  Please refer to the response schema of this API for a list of available fields.
     * @type {Array<string>}
     * @memberof Query
     */
    'fields'?: Array<string>;
    /**
     * The time zone to be applied to any range query related to dates.
     * @type {string}
     * @memberof Query
     */
    'timeZone'?: string;
    /**
     * 
     * @type {InnerHit}
     * @memberof Query
     */
    'innerHit'?: InnerHit;
}
/**
 * Allows the query results to be filtered by specifying a list of fields to include and/or exclude from the result documents.
 * @export
 * @interface QueryResultFilter
 */
export interface QueryResultFilter {
    /**
     * The list of field names to include in the result documents.
     * @type {Array<string>}
     * @memberof QueryResultFilter
     */
    'includes'?: Array<string>;
    /**
     * The list of field names to exclude from the result documents.
     * @type {Array<string>}
     * @memberof QueryResultFilter
     */
    'excludes'?: Array<string>;
}
/**
 * The type of query to use.  By default, the `SAILPOINT` query type is used, which requires the `query` object to be defined in the request body. To use the `queryDsl` or `typeAheadQuery` objects in the request, you must set the type to `DSL` or `TYPEAHEAD` accordingly. Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */

export const QueryType = {
    Dsl: 'DSL',
    Sailpoint: 'SAILPOINT',
    Typeahead: 'TYPEAHEAD'
} as const;

export type QueryType = typeof QueryType[keyof typeof QueryType];


/**
 * Configuration of maximum number days and interval for checking Service Desk integration queue status
 * @export
 * @interface QueuedCheckConfigDetails
 */
export interface QueuedCheckConfigDetails {
    /**
     * interval in minutes between status checks
     * @type {string}
     * @memberof QueuedCheckConfigDetails
     */
    'provisioningStatusCheckIntervalMinutes': string;
    /**
     * maximum number of days to check
     * @type {string}
     * @memberof QueuedCheckConfigDetails
     */
    'provisioningMaxStatusCheckDays': string;
}
/**
 * 
 * @export
 * @interface RandomAlphaNumeric
 */
export interface RandomAlphaNumeric {
    /**
     * This is an integer value specifying the size/number of characters the random string must contain   * This value must be a positive number and cannot be blank   * If no length is provided, the transform will default to a value of `32`   * Due to identity attribute data constraints, the maximum allowable value is `450` characters 
     * @type {string}
     * @memberof RandomAlphaNumeric
     */
    'length'?: string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof RandomAlphaNumeric
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof RandomAlphaNumeric
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface RandomNumeric
 */
export interface RandomNumeric {
    /**
     * This is an integer value specifying the size/number of characters the random string must contain   * This value must be a positive number and cannot be blank   * If no length is provided, the transform will default to a value of `32`   * Due to identity attribute data constraints, the maximum allowable value is `450` characters 
     * @type {string}
     * @memberof RandomNumeric
     */
    'length'?: string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof RandomNumeric
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof RandomNumeric
     */
    'input'?: { [key: string]: any; };
}
/**
 * The range of values to be filtered.
 * @export
 * @interface Range
 */
export interface Range {
    /**
     * 
     * @type {Bound}
     * @memberof Range
     */
    'lower'?: Bound;
    /**
     * 
     * @type {Bound}
     * @memberof Range
     */
    'upper'?: Bound;
}
/**
 * 
 * @export
 * @interface ReassignReference
 */
export interface ReassignReference {
    /**
     * The ID of item or identity being reassigned.
     * @type {string}
     * @memberof ReassignReference
     */
    'id': string;
    /**
     * The type of item or identity being reassigned.
     * @type {string}
     * @memberof ReassignReference
     */
    'type': ReassignReferenceTypeEnum;
}

export const ReassignReferenceTypeEnum = {
    TargetSummary: 'TARGET_SUMMARY',
    Item: 'ITEM',
    IdentitySummary: 'IDENTITY_SUMMARY'
} as const;

export type ReassignReferenceTypeEnum = typeof ReassignReferenceTypeEnum[keyof typeof ReassignReferenceTypeEnum];

/**
 * 
 * @export
 * @interface Reassignment
 */
export interface Reassignment {
    /**
     * 
     * @type {CertificationReference}
     * @memberof Reassignment
     */
    'from'?: CertificationReference;
    /**
     * The comment entered when the Certification was reassigned
     * @type {string}
     * @memberof Reassignment
     */
    'comment'?: string;
}
/**
 * 
 * @export
 * @interface ReassignmentReference
 */
export interface ReassignmentReference {
    /**
     * The ID of item or identity being reassigned.
     * @type {string}
     * @memberof ReassignmentReference
     */
    'id': string;
    /**
     * The type of item or identity being reassigned.
     * @type {string}
     * @memberof ReassignmentReference
     */
    'type': ReassignmentReferenceTypeEnum;
}

export const ReassignmentReferenceTypeEnum = {
    TargetSummary: 'TARGET_SUMMARY',
    Item: 'ITEM',
    IdentitySummary: 'IDENTITY_SUMMARY'
} as const;

export type ReassignmentReferenceTypeEnum = typeof ReassignmentReferenceTypeEnum[keyof typeof ReassignmentReferenceTypeEnum];

/**
 * 
 * @export
 * @interface Reference
 */
export interface Reference {
    /**
     * This ID specifies the name of the pre-existing transform which you want to use within your current transform
     * @type {string}
     * @memberof Reference
     */
    'id': string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Reference
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Reference
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface Reference1
 */
export interface Reference1 {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof Reference1
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof Reference1
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface RemediationItemDetails
 */
export interface RemediationItemDetails {
    /**
     * The ID of the certification
     * @type {string}
     * @memberof RemediationItemDetails
     */
    'id'?: string;
    /**
     * The ID of the certification target
     * @type {string}
     * @memberof RemediationItemDetails
     */
    'targetId'?: string;
    /**
     * The name of the certification target
     * @type {string}
     * @memberof RemediationItemDetails
     */
    'targetName'?: string;
    /**
     * The display name of the certification target
     * @type {string}
     * @memberof RemediationItemDetails
     */
    'targetDisplayName'?: string;
    /**
     * The name of the application/source
     * @type {string}
     * @memberof RemediationItemDetails
     */
    'applicationName'?: string;
    /**
     * The name of the attribute being certified
     * @type {string}
     * @memberof RemediationItemDetails
     */
    'attributeName'?: string;
    /**
     * The operation of the certification on the attribute
     * @type {string}
     * @memberof RemediationItemDetails
     */
    'attributeOperation'?: string;
    /**
     * The value of the attribute being certified
     * @type {string}
     * @memberof RemediationItemDetails
     */
    'attributeValue'?: string;
    /**
     * The native identity of the target
     * @type {string}
     * @memberof RemediationItemDetails
     */
    'nativeIdentity'?: string;
}
/**
 * 
 * @export
 * @interface RemediationItems
 */
export interface RemediationItems {
    /**
     * The ID of the certification
     * @type {string}
     * @memberof RemediationItems
     */
    'id'?: string;
    /**
     * The ID of the certification target
     * @type {string}
     * @memberof RemediationItems
     */
    'targetId'?: string;
    /**
     * The name of the certification target
     * @type {string}
     * @memberof RemediationItems
     */
    'targetName'?: string;
    /**
     * The display name of the certification target
     * @type {string}
     * @memberof RemediationItems
     */
    'targetDisplayName'?: string;
    /**
     * The name of the application/source
     * @type {string}
     * @memberof RemediationItems
     */
    'applicationName'?: string;
    /**
     * The name of the attribute being certified
     * @type {string}
     * @memberof RemediationItems
     */
    'attributeName'?: string;
    /**
     * The operation of the certification on the attribute
     * @type {string}
     * @memberof RemediationItems
     */
    'attributeOperation'?: string;
    /**
     * The value of the attribute being certified
     * @type {string}
     * @memberof RemediationItems
     */
    'attributeValue'?: string;
    /**
     * The native identity of the target
     * @type {string}
     * @memberof RemediationItems
     */
    'nativeIdentity'?: string;
}
/**
 * 
 * @export
 * @interface Replace
 */
export interface Replace {
    /**
     * This can be a string or a regex pattern in which you want to replace.
     * @type {string}
     * @memberof Replace
     */
    'regex': string;
    /**
     * This is the replacement string that should be substituded wherever the string or pattern is found.
     * @type {string}
     * @memberof Replace
     */
    'replacement': string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Replace
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Replace
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface ReplaceAll
 */
export interface ReplaceAll {
    /**
     * An attribute of key-value pairs. Each pair identifies the pattern to search for as its key, and the replacement string as its value.
     * @type {{ [key: string]: any; }}
     * @memberof ReplaceAll
     */
    'table': { [key: string]: any; };
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof ReplaceAll
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof ReplaceAll
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface RequestOnBehalfOfConfig
 */
export interface RequestOnBehalfOfConfig {
    /**
     * If anyone can request access for anyone.
     * @type {boolean}
     * @memberof RequestOnBehalfOfConfig
     */
    'allowRequestOnBehalfOfAnyoneByAnyone'?: boolean;
    /**
     * If a manager can request access for his/her direct reports.
     * @type {boolean}
     * @memberof RequestOnBehalfOfConfig
     */
    'allowRequestOnBehalfOfEmployeeByManager'?: boolean;
}
/**
 * 
 * @export
 * @interface RequestableObject
 */
export interface RequestableObject {
    /**
     * Id of the requestable object itself
     * @type {string}
     * @memberof RequestableObject
     */
    'id'?: string;
    /**
     * Human-readable display name of the requestable object
     * @type {string}
     * @memberof RequestableObject
     */
    'name'?: string;
    /**
     * The time when the requestable object was created
     * @type {string}
     * @memberof RequestableObject
     */
    'created'?: string;
    /**
     * The time when the requestable object was last modified
     * @type {string}
     * @memberof RequestableObject
     */
    'modified'?: string | null;
    /**
     * Description of the requestable object.
     * @type {string}
     * @memberof RequestableObject
     */
    'description'?: string;
    /**
     * 
     * @type {RequestableObjectType}
     * @memberof RequestableObject
     */
    'type'?: RequestableObjectType;
    /**
     * 
     * @type {RequestableObjectRequestStatus}
     * @memberof RequestableObject
     */
    'requestStatus'?: RequestableObjectRequestStatus;
    /**
     * If *requestStatus* is *PENDING*, indicates the id of the associated account activity.
     * @type {string}
     * @memberof RequestableObject
     */
    'identityRequestId'?: string | null;
    /**
     * 
     * @type {IdentityReferenceWithNameAndEmail}
     * @memberof RequestableObject
     */
    'ownerRef'?: IdentityReferenceWithNameAndEmail | null;
    /**
     * Whether the requester must provide comments when requesting the object.
     * @type {boolean}
     * @memberof RequestableObject
     */
    'requestCommentsRequired'?: boolean;
}
/**
 * 
 * @export
 * @interface RequestableObjectReference
 */
export interface RequestableObjectReference {
    /**
     * Id of the object.
     * @type {string}
     * @memberof RequestableObjectReference
     */
    'id'?: string;
    /**
     * Name of the object.
     * @type {string}
     * @memberof RequestableObjectReference
     */
    'name'?: string;
    /**
     * Description of the object.
     * @type {string}
     * @memberof RequestableObjectReference
     */
    'description'?: string;
    /**
     * Type of the object.
     * @type {string}
     * @memberof RequestableObjectReference
     */
    'type'?: RequestableObjectReferenceTypeEnum;
}

export const RequestableObjectReferenceTypeEnum = {
    AccessProfile: 'ACCESS_PROFILE',
    Role: 'ROLE',
    Entitlement: 'ENTITLEMENT'
} as const;

export type RequestableObjectReferenceTypeEnum = typeof RequestableObjectReferenceTypeEnum[keyof typeof RequestableObjectReferenceTypeEnum];

/**
 * Status indicating the ability of an access request for the object to be made by or on behalf of the identity specified by *identity-id*. *AVAILABLE* indicates the object is available to request. *PENDING* indicates the object is unavailable because the identity has a pending request in flight. *ASSIGNED* indicates the object is unavailable because the identity already has the indicated role or access profile. If *identity-id* is not specified (allowed only for admin users), then status will be *AVAILABLE* for all results.
 * @export
 * @enum {string}
 */

export const RequestableObjectRequestStatus = {
    Available: 'AVAILABLE',
    Pending: 'PENDING',
    Assigned: 'ASSIGNED'
} as const;

export type RequestableObjectRequestStatus = typeof RequestableObjectRequestStatus[keyof typeof RequestableObjectRequestStatus];


/**
 * Enum represented the currently supported requestable object types. Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */

export const RequestableObjectType = {
    AccessProfile: 'ACCESS_PROFILE',
    Role: 'ROLE',
    Entitlement: 'ENTITLEMENT'
} as const;

export type RequestableObjectType = typeof RequestableObjectType[keyof typeof RequestableObjectType];


/**
 * 
 * @export
 * @interface RequestedItemStatus
 */
export interface RequestedItemStatus {
    /**
     * Human-readable display name of the item being requested.
     * @type {string}
     * @memberof RequestedItemStatus
     */
    'name'?: string;
    /**
     * Type of requested object.
     * @type {string}
     * @memberof RequestedItemStatus
     */
    'type'?: RequestedItemStatusTypeEnum;
    /**
     * 
     * @type {CancelledRequestDetails}
     * @memberof RequestedItemStatus
     */
    'cancelledRequestDetails'?: CancelledRequestDetails;
    /**
     * List of list of localized error messages, if any, encountered during the approval/provisioning process.
     * @type {Array<Array<ErrorMessageDto>>}
     * @memberof RequestedItemStatus
     */
    'errorMessages'?: Array<Array<ErrorMessageDto>> | null;
    /**
     * 
     * @type {RequestedItemStatusRequestState}
     * @memberof RequestedItemStatus
     */
    'state'?: RequestedItemStatusRequestState;
    /**
     * Approval details for each item.
     * @type {Array<ApprovalStatusDto>}
     * @memberof RequestedItemStatus
     */
    'approvalDetails'?: Array<ApprovalStatusDto>;
    /**
     * Manual work items created for provisioning the item.
     * @type {Array<ManualWorkItemDetails>}
     * @memberof RequestedItemStatus
     */
    'manualWorkItemDetails'?: Array<ManualWorkItemDetails> | null;
    /**
     * Id of associated account activity item.
     * @type {string}
     * @memberof RequestedItemStatus
     */
    'accountActivityItemId'?: string;
    /**
     * 
     * @type {AccessRequestType}
     * @memberof RequestedItemStatus
     */
    'requestType'?: AccessRequestType;
    /**
     * When the request was last modified.
     * @type {string}
     * @memberof RequestedItemStatus
     */
    'modified'?: string;
    /**
     * When the request was created.
     * @type {string}
     * @memberof RequestedItemStatus
     */
    'created'?: string;
    /**
     * 
     * @type {BaseReferenceDto}
     * @memberof RequestedItemStatus
     */
    'requester'?: BaseReferenceDto;
    /**
     * 
     * @type {BaseReferenceDto}
     * @memberof RequestedItemStatus
     */
    'requestedFor'?: BaseReferenceDto;
    /**
     * 
     * @type {CommentDto}
     * @memberof RequestedItemStatus
     */
    'requesterComment'?: CommentDto;
    /**
     * 
     * @type {SodViolationContextCheckCompleted}
     * @memberof RequestedItemStatus
     */
    'sodViolationContext'?: SodViolationContextCheckCompleted;
    /**
     * 
     * @type {ProvisioningDetails}
     * @memberof RequestedItemStatus
     */
    'provisioningDetails'?: ProvisioningDetails;
    /**
     * 
     * @type {PreApprovalTriggerDetails}
     * @memberof RequestedItemStatus
     */
    'preApprovalTriggerDetails'?: PreApprovalTriggerDetails;
    /**
     * A list of Phases that the Access Request has gone through in order, to help determine the status of the request.
     * @type {Array<AccessRequestPhases>}
     * @memberof RequestedItemStatus
     */
    'accessRequestPhases'?: Array<AccessRequestPhases>;
    /**
     * Description associated to the requested object.
     * @type {string}
     * @memberof RequestedItemStatus
     */
    'description'?: string;
    /**
     * When the role access is scheduled for removal.
     * @type {string}
     * @memberof RequestedItemStatus
     */
    'removeDate'?: string | null;
    /**
     * True if the request can be canceled.
     * @type {boolean}
     * @memberof RequestedItemStatus
     */
    'cancelable'?: boolean;
    /**
     * This is the account activity id.
     * @type {string}
     * @memberof RequestedItemStatus
     */
    'accessRequestId'?: string;
    /**
     * Arbitrary key-value pairs, if any were included in the corresponding access request
     * @type {{ [key: string]: string; }}
     * @memberof RequestedItemStatus
     */
    'clientMetadata'?: { [key: string]: string; } | null;
}

export const RequestedItemStatusTypeEnum = {
    AccessProfile: 'ACCESS_PROFILE',
    Role: 'ROLE',
    Entitlement: 'ENTITLEMENT'
} as const;

export type RequestedItemStatusTypeEnum = typeof RequestedItemStatusTypeEnum[keyof typeof RequestedItemStatusTypeEnum];

/**
 * Indicates the state of an access request: * EXECUTING: The request is executing, which indicates the system is doing some processing. * REQUEST_COMPLETED: Indicates the request  has been completed. * CANCELLED: The request was cancelled with no user input. * TERMINATED: The request has been terminated before it was able to complete. * PROVISIONING_VERIFICATION_PENDING: The request has finished any approval steps and provisioning is waiting to be verified. * REJECTED: The request was rejected. * PROVISIONING_FAILED: The request has failed to complete. * NOT_ALL_ITEMS_PROVISIONED: One or more of the requested items failed to complete, but there were one or more  successes. * ERROR: An error occurred during request processing.
 * @export
 * @enum {string}
 */

export const RequestedItemStatusRequestState = {
    Executing: 'EXECUTING',
    RequestCompleted: 'REQUEST_COMPLETED',
    Cancelled: 'CANCELLED',
    Terminated: 'TERMINATED',
    ProvisioningVerificationPending: 'PROVISIONING_VERIFICATION_PENDING',
    Rejected: 'REJECTED',
    ProvisioningFailed: 'PROVISIONING_FAILED',
    NotAllItemsProvisioned: 'NOT_ALL_ITEMS_PROVISIONED',
    Error: 'ERROR'
} as const;

export type RequestedItemStatusRequestState = typeof RequestedItemStatusRequestState[keyof typeof RequestedItemStatusRequestState];


/**
 * 
 * @export
 * @interface ReviewDecision
 */
export interface ReviewDecision {
    /**
     * The id of the review decision
     * @type {string}
     * @memberof ReviewDecision
     */
    'id': string;
    /**
     * 
     * @type {CertificationDecision}
     * @memberof ReviewDecision
     */
    'decision': CertificationDecision;
    /**
     * The date at which a user\'s access should be taken away. Should only be set for `REVOKE` decisions.
     * @type {string}
     * @memberof ReviewDecision
     */
    'proposedEndDate'?: string;
    /**
     * Indicates whether decision should be marked as part of a larger bulk decision
     * @type {boolean}
     * @memberof ReviewDecision
     */
    'bulk': boolean;
    /**
     * 
     * @type {ReviewRecommendation}
     * @memberof ReviewDecision
     */
    'recommendation'?: ReviewRecommendation;
    /**
     * Comments recorded when the decision was made
     * @type {string}
     * @memberof ReviewDecision
     */
    'comments'?: string;
}
/**
 * 
 * @export
 * @interface ReviewReassign
 */
export interface ReviewReassign {
    /**
     * 
     * @type {Array<ReassignReference>}
     * @memberof ReviewReassign
     */
    'reassign': Array<ReassignReference>;
    /**
     * The ID of the identity to which the certification is reassigned
     * @type {string}
     * @memberof ReviewReassign
     */
    'reassignTo': string;
    /**
     * The reason comment for why the reassign was made
     * @type {string}
     * @memberof ReviewReassign
     */
    'reason': string;
}
/**
 * 
 * @export
 * @interface ReviewRecommendation
 */
export interface ReviewRecommendation {
    /**
     * The recommendation from IAI at the time of the decision. This field will be null if no recommendation was made.
     * @type {string}
     * @memberof ReviewRecommendation
     */
    'recommendation'?: string | null;
    /**
     * A list of reasons for the recommendation.
     * @type {Array<string>}
     * @memberof ReviewRecommendation
     */
    'reasons'?: Array<string>;
    /**
     * The time at which the recommendation was recorded.
     * @type {string}
     * @memberof ReviewRecommendation
     */
    'timestamp'?: string;
}
/**
 * 
 * @export
 * @interface ReviewableAccessProfile
 */
export interface ReviewableAccessProfile {
    /**
     * The id of the Access Profile
     * @type {string}
     * @memberof ReviewableAccessProfile
     */
    'id'?: string;
    /**
     * Name of the Access Profile
     * @type {string}
     * @memberof ReviewableAccessProfile
     */
    'name'?: string;
    /**
     * Information about the Access Profile
     * @type {string}
     * @memberof ReviewableAccessProfile
     */
    'description'?: string;
    /**
     * Indicates if the entitlement is a privileged entitlement
     * @type {boolean}
     * @memberof ReviewableAccessProfile
     */
    'privileged'?: boolean;
    /**
     * True if the entitlement is cloud governed
     * @type {boolean}
     * @memberof ReviewableAccessProfile
     */
    'cloudGoverned'?: boolean;
    /**
     * The date at which a user\'s access expires
     * @type {string}
     * @memberof ReviewableAccessProfile
     */
    'endDate'?: string | null;
    /**
     * 
     * @type {IdentityReferenceWithNameAndEmail}
     * @memberof ReviewableAccessProfile
     */
    'owner'?: IdentityReferenceWithNameAndEmail | null;
    /**
     * A list of entitlements associated with this Access Profile
     * @type {Array<ReviewableEntitlement>}
     * @memberof ReviewableAccessProfile
     */
    'entitlements'?: Array<ReviewableEntitlement>;
    /**
     * Date the Access Profile was created.
     * @type {string}
     * @memberof ReviewableAccessProfile
     */
    'created'?: string;
    /**
     * Date the Access Profile was last modified.
     * @type {string}
     * @memberof ReviewableAccessProfile
     */
    'modified'?: string;
}
/**
 * 
 * @export
 * @interface ReviewableEntitlement
 */
export interface ReviewableEntitlement {
    /**
     * The id for the entitlement
     * @type {string}
     * @memberof ReviewableEntitlement
     */
    'id'?: string;
    /**
     * The name of the entitlement
     * @type {string}
     * @memberof ReviewableEntitlement
     */
    'name'?: string;
    /**
     * Information about the entitlement
     * @type {string}
     * @memberof ReviewableEntitlement
     */
    'description'?: string | null;
    /**
     * Indicates if the entitlement is a privileged entitlement
     * @type {boolean}
     * @memberof ReviewableEntitlement
     */
    'privileged'?: boolean;
    /**
     * 
     * @type {IdentityReferenceWithNameAndEmail}
     * @memberof ReviewableEntitlement
     */
    'owner'?: IdentityReferenceWithNameAndEmail | null;
    /**
     * The name of the attribute on the source
     * @type {string}
     * @memberof ReviewableEntitlement
     */
    'attributeName'?: string;
    /**
     * The value of the attribute on the source
     * @type {string}
     * @memberof ReviewableEntitlement
     */
    'attributeValue'?: string;
    /**
     * The schema object type on the source used to represent the entitlement and its attributes
     * @type {string}
     * @memberof ReviewableEntitlement
     */
    'sourceSchemaObjectType'?: string;
    /**
     * The name of the source for which this entitlement belongs
     * @type {string}
     * @memberof ReviewableEntitlement
     */
    'sourceName'?: string;
    /**
     * The type of the source for which the entitlement belongs
     * @type {string}
     * @memberof ReviewableEntitlement
     */
    'sourceType'?: string;
    /**
     * Indicates if the entitlement has permissions
     * @type {boolean}
     * @memberof ReviewableEntitlement
     */
    'hasPermissions'?: boolean;
    /**
     * Indicates if the entitlement is a representation of an account permission
     * @type {boolean}
     * @memberof ReviewableEntitlement
     */
    'isPermission'?: boolean;
    /**
     * Indicates whether the entitlement can be revoked
     * @type {boolean}
     * @memberof ReviewableEntitlement
     */
    'revocable'?: boolean;
    /**
     * True if the entitlement is cloud governed
     * @type {boolean}
     * @memberof ReviewableEntitlement
     */
    'cloudGoverned'?: boolean;
    /**
     * 
     * @type {ReviewableEntitlementAccount}
     * @memberof ReviewableEntitlement
     */
    'account'?: ReviewableEntitlementAccount | null;
}
/**
 * Information about the status of the entitlement
 * @export
 * @interface ReviewableEntitlementAccount
 */
export interface ReviewableEntitlementAccount {
    /**
     * The native identity for this account
     * @type {string}
     * @memberof ReviewableEntitlementAccount
     */
    'nativeIdentity'?: string;
    /**
     * Indicates whether this account is currently disabled
     * @type {boolean}
     * @memberof ReviewableEntitlementAccount
     */
    'disabled'?: boolean;
    /**
     * Indicates whether this account is currently locked
     * @type {boolean}
     * @memberof ReviewableEntitlementAccount
     */
    'locked'?: boolean;
    /**
     * 
     * @type {DtoType}
     * @memberof ReviewableEntitlementAccount
     */
    'type'?: DtoType;
    /**
     * The id associated with the account
     * @type {string}
     * @memberof ReviewableEntitlementAccount
     */
    'id'?: string | null;
    /**
     * The account name
     * @type {string}
     * @memberof ReviewableEntitlementAccount
     */
    'name'?: string | null;
    /**
     * When the account was created
     * @type {string}
     * @memberof ReviewableEntitlementAccount
     */
    'created'?: string | null;
    /**
     * When the account was last modified
     * @type {string}
     * @memberof ReviewableEntitlementAccount
     */
    'modified'?: string | null;
}
/**
 * 
 * @export
 * @interface ReviewableRole
 */
export interface ReviewableRole {
    /**
     * The id for the Role
     * @type {string}
     * @memberof ReviewableRole
     */
    'id'?: string;
    /**
     * The name of the Role
     * @type {string}
     * @memberof ReviewableRole
     */
    'name'?: string;
    /**
     * Information about the Role
     * @type {string}
     * @memberof ReviewableRole
     */
    'description'?: string;
    /**
     * Indicates if the entitlement is a privileged entitlement
     * @type {boolean}
     * @memberof ReviewableRole
     */
    'privileged'?: boolean;
    /**
     * 
     * @type {IdentityReferenceWithNameAndEmail}
     * @memberof ReviewableRole
     */
    'owner'?: IdentityReferenceWithNameAndEmail | null;
    /**
     * Indicates whether the Role can be revoked or requested
     * @type {boolean}
     * @memberof ReviewableRole
     */
    'revocable'?: boolean;
    /**
     * The date when a user\'s access expires.
     * @type {string}
     * @memberof ReviewableRole
     */
    'endDate'?: string;
    /**
     * The list of Access Profiles associated with this Role
     * @type {Array<ReviewableAccessProfile>}
     * @memberof ReviewableRole
     */
    'accessProfiles'?: Array<ReviewableAccessProfile>;
}
/**
 * 
 * @export
 * @interface Reviewer
 */
export interface Reviewer {
    /**
     * The id of the reviewer.
     * @type {string}
     * @memberof Reviewer
     */
    'id'?: string;
    /**
     * The name of the reviewer.
     * @type {string}
     * @memberof Reviewer
     */
    'name'?: string;
    /**
     * The email of the reviewing identity.
     * @type {string}
     * @memberof Reviewer
     */
    'email'?: string;
    /**
     * The type of the reviewing identity.
     * @type {string}
     * @memberof Reviewer
     */
    'type'?: ReviewerTypeEnum;
    /**
     * The created date of the reviewing identity.
     * @type {string}
     * @memberof Reviewer
     */
    'created'?: string | null;
    /**
     * The modified date of the reviewing identity.
     * @type {string}
     * @memberof Reviewer
     */
    'modified'?: string | null;
}

export const ReviewerTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type ReviewerTypeEnum = typeof ReviewerTypeEnum[keyof typeof ReviewerTypeEnum];

/**
 * 
 * @export
 * @interface RightPad
 */
export interface RightPad {
    /**
     * An integer value for the desired length of the final output string
     * @type {string}
     * @memberof RightPad
     */
    'length': string;
    /**
     * A string value representing the character that the incoming data should be padded with to get to the desired length   If not provided, the transform will default to a single space (\" \") character for padding 
     * @type {string}
     * @memberof RightPad
     */
    'padding'?: string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof RightPad
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof RightPad
     */
    'input'?: { [key: string]: any; };
}
/**
 * Role
 * @export
 * @interface RoleDocument
 */
export interface RoleDocument {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof RoleDocument
     */
    'id': string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof RoleDocument
     */
    'name': string;
    /**
     * 
     * @type {DocumentType}
     * @memberof RoleDocument
     */
    '_type': DocumentType;
    /**
     * The description of the access item
     * @type {string}
     * @memberof RoleDocument
     */
    'description'?: string;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof RoleDocument
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof RoleDocument
     */
    'modified'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof RoleDocument
     */
    'synced'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof RoleDocument
     */
    'enabled'?: boolean;
    /**
     * Indicates if the access can be requested
     * @type {boolean}
     * @memberof RoleDocument
     */
    'requestable'?: boolean;
    /**
     * Indicates if comments are required when requesting access
     * @type {boolean}
     * @memberof RoleDocument
     */
    'requestCommentsRequired'?: boolean;
    /**
     * 
     * @type {Owner}
     * @memberof RoleDocument
     */
    'owner'?: Owner;
    /**
     * 
     * @type {Array<Reference1>}
     * @memberof RoleDocument
     */
    'accessProfiles'?: Array<Reference1>;
    /**
     * 
     * @type {number}
     * @memberof RoleDocument
     */
    'accessProfileCount'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof RoleDocument
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface RoleDocumentAllOf
 */
export interface RoleDocumentAllOf {
    /**
     * 
     * @type {Array<Reference1>}
     * @memberof RoleDocumentAllOf
     */
    'accessProfiles'?: Array<Reference1>;
    /**
     * 
     * @type {number}
     * @memberof RoleDocumentAllOf
     */
    'accessProfileCount'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof RoleDocumentAllOf
     */
    'tags'?: Array<string>;
}
/**
 * Role
 * @export
 * @interface RoleSummary
 */
export interface RoleSummary {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof RoleSummary
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof RoleSummary
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof RoleSummary
     */
    'displayName'?: string;
    /**
     * 
     * @type {DtoType}
     * @memberof RoleSummary
     */
    'type'?: DtoType;
    /**
     * 
     * @type {string}
     * @memberof RoleSummary
     */
    'description'?: string | null;
    /**
     * 
     * @type {DisplayReference}
     * @memberof RoleSummary
     */
    'owner'?: DisplayReference;
    /**
     * 
     * @type {boolean}
     * @memberof RoleSummary
     */
    'disabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RoleSummary
     */
    'revocable'?: boolean;
}
/**
 * 
 * @export
 * @interface RoleSummaryAllOf
 */
export interface RoleSummaryAllOf {
    /**
     * 
     * @type {DisplayReference}
     * @memberof RoleSummaryAllOf
     */
    'owner'?: DisplayReference;
    /**
     * 
     * @type {boolean}
     * @memberof RoleSummaryAllOf
     */
    'disabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RoleSummaryAllOf
     */
    'revocable'?: boolean;
}
/**
 * @type Rule
 * @export
 */
export type Rule = GenerateRandomString | GenericRule | GetReferenceIdentityAttribute;

/**
 * 
 * @export
 * @interface SavedSearch
 */
export interface SavedSearch {
    /**
     * The saved search ID. 
     * @type {string}
     * @memberof SavedSearch
     */
    'id'?: string;
    /**
     * 
     * @type {TypedReference}
     * @memberof SavedSearch
     */
    'owner'?: TypedReference;
    /**
     * The name of the saved search. 
     * @type {string}
     * @memberof SavedSearch
     */
    'name'?: string;
    /**
     * The description of the saved search. 
     * @type {string}
     * @memberof SavedSearch
     */
    'description'?: string | null;
    /**
     * Indicates if the saved search is public. 
     * @type {boolean}
     * @memberof SavedSearch
     */
    'public'?: boolean;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof SavedSearch
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof SavedSearch
     */
    'modified'?: string | null;
    /**
     * The names of the Elasticsearch indices in which to search. 
     * @type {Array<Index>}
     * @memberof SavedSearch
     */
    'indices': Array<Index>;
    /**
     * The columns to be returned (specifies the order in which they will be presented) for each document type.  The currently supported document types are: _accessprofile_, _accountactivity_, _account_, _aggregation_, _entitlement_, _event_, _identity_, and _role_. 
     * @type {{ [key: string]: Array<Column>; }}
     * @memberof SavedSearch
     */
    'columns'?: { [key: string]: Array<Column>; };
    /**
     * The search query using Elasticsearch [Query String Query](https://www.elastic.co/guide/en/elasticsearch/reference/5.2/query-dsl-query-string-query.html#query-string) syntax from the Query DSL. 
     * @type {string}
     * @memberof SavedSearch
     */
    'query': string;
    /**
     * The fields to be searched against in a multi-field query. 
     * @type {Array<string>}
     * @memberof SavedSearch
     */
    'fields'?: Array<string> | null;
    /**
     * The fields to be used to sort the search results. 
     * @type {Array<string>}
     * @memberof SavedSearch
     */
    'sort'?: Array<string>;
    /**
     * 
     * @type {SavedSearchDetailFilters}
     * @memberof SavedSearch
     */
    'filters'?: SavedSearchDetailFilters | null;
}
/**
 * 
 * @export
 * @interface SavedSearchAllOf
 */
export interface SavedSearchAllOf {
    /**
     * The saved search ID. 
     * @type {string}
     * @memberof SavedSearchAllOf
     */
    'id'?: string;
    /**
     * 
     * @type {TypedReference}
     * @memberof SavedSearchAllOf
     */
    'owner'?: TypedReference;
}
/**
 * 
 * @export
 * @interface SavedSearchCreateRequest
 */
export interface SavedSearchCreateRequest {
    /**
     * The name of the saved search. 
     * @type {string}
     * @memberof SavedSearchCreateRequest
     */
    'name'?: string;
    /**
     * The description of the saved search. 
     * @type {string}
     * @memberof SavedSearchCreateRequest
     */
    'description'?: string | null;
    /**
     * Indicates if the saved search is public. 
     * @type {boolean}
     * @memberof SavedSearchCreateRequest
     */
    'public'?: boolean;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof SavedSearchCreateRequest
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof SavedSearchCreateRequest
     */
    'modified'?: string | null;
    /**
     * The names of the Elasticsearch indices in which to search. 
     * @type {Array<Index>}
     * @memberof SavedSearchCreateRequest
     */
    'indices': Array<Index>;
    /**
     * The columns to be returned (specifies the order in which they will be presented) for each document type.  The currently supported document types are: _accessprofile_, _accountactivity_, _account_, _aggregation_, _entitlement_, _event_, _identity_, and _role_. 
     * @type {{ [key: string]: Array<Column>; }}
     * @memberof SavedSearchCreateRequest
     */
    'columns'?: { [key: string]: Array<Column>; };
    /**
     * The search query using Elasticsearch [Query String Query](https://www.elastic.co/guide/en/elasticsearch/reference/5.2/query-dsl-query-string-query.html#query-string) syntax from the Query DSL. 
     * @type {string}
     * @memberof SavedSearchCreateRequest
     */
    'query': string;
    /**
     * The fields to be searched against in a multi-field query. 
     * @type {Array<string>}
     * @memberof SavedSearchCreateRequest
     */
    'fields'?: Array<string> | null;
    /**
     * The fields to be used to sort the search results. 
     * @type {Array<string>}
     * @memberof SavedSearchCreateRequest
     */
    'sort'?: Array<string>;
    /**
     * 
     * @type {SavedSearchDetailFilters}
     * @memberof SavedSearchCreateRequest
     */
    'filters'?: SavedSearchDetailFilters | null;
}
/**
 * 
 * @export
 * @interface SavedSearchDetail
 */
export interface SavedSearchDetail {
    /**
     * Indicates if the saved search is public. 
     * @type {boolean}
     * @memberof SavedSearchDetail
     */
    'public'?: boolean;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof SavedSearchDetail
     */
    'created'?: string | null;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof SavedSearchDetail
     */
    'modified'?: string | null;
    /**
     * The names of the Elasticsearch indices in which to search. 
     * @type {Array<Index>}
     * @memberof SavedSearchDetail
     */
    'indices': Array<Index>;
    /**
     * The columns to be returned (specifies the order in which they will be presented) for each document type.  The currently supported document types are: _accessprofile_, _accountactivity_, _account_, _aggregation_, _entitlement_, _event_, _identity_, and _role_. 
     * @type {{ [key: string]: Array<Column>; }}
     * @memberof SavedSearchDetail
     */
    'columns'?: { [key: string]: Array<Column>; };
    /**
     * The search query using Elasticsearch [Query String Query](https://www.elastic.co/guide/en/elasticsearch/reference/5.2/query-dsl-query-string-query.html#query-string) syntax from the Query DSL. 
     * @type {string}
     * @memberof SavedSearchDetail
     */
    'query': string;
    /**
     * The fields to be searched against in a multi-field query. 
     * @type {Array<string>}
     * @memberof SavedSearchDetail
     */
    'fields'?: Array<string> | null;
    /**
     * The fields to be used to sort the search results. 
     * @type {Array<string>}
     * @memberof SavedSearchDetail
     */
    'sort'?: Array<string>;
    /**
     * 
     * @type {SavedSearchDetailFilters}
     * @memberof SavedSearchDetail
     */
    'filters'?: SavedSearchDetailFilters | null;
}
/**
 * 
 * @export
 * @interface SavedSearchDetailFilters
 */
export interface SavedSearchDetailFilters {
    /**
     * 
     * @type {FilterType}
     * @memberof SavedSearchDetailFilters
     */
    'type'?: FilterType;
    /**
     * 
     * @type {Range}
     * @memberof SavedSearchDetailFilters
     */
    'range'?: Range;
    /**
     * The terms to be filtered.
     * @type {Array<string>}
     * @memberof SavedSearchDetailFilters
     */
    'terms'?: Array<string>;
    /**
     * Indicates if the filter excludes results.
     * @type {boolean}
     * @memberof SavedSearchDetailFilters
     */
    'exclude'?: boolean;
}
/**
 * 
 * @export
 * @interface SavedSearchName
 */
export interface SavedSearchName {
    /**
     * The name of the saved search. 
     * @type {string}
     * @memberof SavedSearchName
     */
    'name'?: string;
    /**
     * The description of the saved search. 
     * @type {string}
     * @memberof SavedSearchName
     */
    'description'?: string | null;
}
/**
 * The schedule information.
 * @export
 * @interface Schedule
 */
export interface Schedule {
    /**
     * 
     * @type {ScheduleType}
     * @memberof Schedule
     */
    'type': ScheduleType;
    /**
     * 
     * @type {ScheduleDays}
     * @memberof Schedule
     */
    'days'?: ScheduleDays;
    /**
     * 
     * @type {ScheduleHours}
     * @memberof Schedule
     */
    'hours': ScheduleHours;
    /**
     * A date-time in ISO-8601 format
     * @type {string}
     * @memberof Schedule
     */
    'expiration'?: string | null;
    /**
     * The GMT formatted timezone the schedule will run in (ex. GMT-06:00).  If no timezone is specified, the org\'s default timezone is used.
     * @type {string}
     * @memberof Schedule
     */
    'timeZoneId'?: string | null;
}
/**
 * 
 * @export
 * @interface ScheduleDays
 */
export interface ScheduleDays {
    /**
     * 
     * @type {SelectorType}
     * @memberof ScheduleDays
     */
    'type': SelectorType;
    /**
     * The selected values. 
     * @type {Array<string>}
     * @memberof ScheduleDays
     */
    'values': Array<string>;
    /**
     * The selected interval for RANGE selectors. 
     * @type {number}
     * @memberof ScheduleDays
     */
    'interval'?: number | null;
}
/**
 * 
 * @export
 * @interface ScheduleHours
 */
export interface ScheduleHours {
    /**
     * 
     * @type {SelectorType}
     * @memberof ScheduleHours
     */
    'type': SelectorType;
    /**
     * The selected values. 
     * @type {Array<string>}
     * @memberof ScheduleHours
     */
    'values': Array<string>;
    /**
     * The selected interval for RANGE selectors. 
     * @type {number}
     * @memberof ScheduleHours
     */
    'interval'?: number | null;
}
/**
 * Enum representing the currently supported schedule types.  Additional values may be added in the future without notice. 
 * @export
 * @enum {string}
 */

export const ScheduleType = {
    Daily: 'DAILY',
    Weekly: 'WEEKLY',
    Monthly: 'MONTHLY',
    Calendar: 'CALENDAR'
} as const;

export type ScheduleType = typeof ScheduleType[keyof typeof ScheduleType];


/**
 * 
 * @export
 * @interface ScheduledSearch
 */
export interface ScheduledSearch {
    /**
     * The scheduled search ID.
     * @type {string}
     * @memberof ScheduledSearch
     */
    'id': string;
    /**
     * 
     * @type {ScheduledSearchAllOfOwner}
     * @memberof ScheduledSearch
     */
    'owner': ScheduledSearchAllOfOwner;
    /**
     * The ID of the scheduled search owner.  Please use the `id` in the `owner` object instead. 
     * @type {string}
     * @memberof ScheduledSearch
     * @deprecated
     */
    'ownerId': string;
    /**
     * The name of the scheduled search. 
     * @type {string}
     * @memberof ScheduledSearch
     */
    'name'?: string | null;
    /**
     * The description of the scheduled search. 
     * @type {string}
     * @memberof ScheduledSearch
     */
    'description'?: string | null;
    /**
     * The ID of the saved search that will be executed.
     * @type {string}
     * @memberof ScheduledSearch
     */
    'savedSearchId': string;
    /**
     * The date the scheduled search was initially created.
     * @type {string}
     * @memberof ScheduledSearch
     */
    'created'?: string;
    /**
     * The last date the scheduled search was modified.
     * @type {string}
     * @memberof ScheduledSearch
     */
    'modified'?: string;
    /**
     * 
     * @type {Schedule}
     * @memberof ScheduledSearch
     */
    'schedule': Schedule;
    /**
     * A list of identities that should receive the scheduled search report via email.
     * @type {Array<SearchScheduleRecipientsInner>}
     * @memberof ScheduledSearch
     */
    'recipients': Array<SearchScheduleRecipientsInner>;
    /**
     * Indicates if the scheduled search is enabled. 
     * @type {boolean}
     * @memberof ScheduledSearch
     */
    'enabled'?: boolean;
    /**
     * Indicates if email generation should not be suppressed if search returns no results. 
     * @type {boolean}
     * @memberof ScheduledSearch
     */
    'emailEmptyResults'?: boolean;
    /**
     * Indicates if the generated email should include the query and search results preview (which could include PII). 
     * @type {boolean}
     * @memberof ScheduledSearch
     */
    'displayQueryDetails'?: boolean;
}
/**
 * 
 * @export
 * @interface ScheduledSearchAllOf
 */
export interface ScheduledSearchAllOf {
    /**
     * The scheduled search ID.
     * @type {string}
     * @memberof ScheduledSearchAllOf
     */
    'id'?: string;
    /**
     * 
     * @type {ScheduledSearchAllOfOwner}
     * @memberof ScheduledSearchAllOf
     */
    'owner'?: ScheduledSearchAllOfOwner;
    /**
     * The ID of the scheduled search owner.  Please use the `id` in the `owner` object instead. 
     * @type {string}
     * @memberof ScheduledSearchAllOf
     * @deprecated
     */
    'ownerId'?: string;
}
/**
 * The owner of the scheduled search
 * @export
 * @interface ScheduledSearchAllOfOwner
 */
export interface ScheduledSearchAllOfOwner {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof ScheduledSearchAllOfOwner
     */
    'type': ScheduledSearchAllOfOwnerTypeEnum;
    /**
     * The ID of the referenced object
     * @type {string}
     * @memberof ScheduledSearchAllOfOwner
     */
    'id': string;
}

export const ScheduledSearchAllOfOwnerTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type ScheduledSearchAllOfOwnerTypeEnum = typeof ScheduledSearchAllOfOwnerTypeEnum[keyof typeof ScheduledSearchAllOfOwnerTypeEnum];

/**
 * 
 * @export
 * @interface ScheduledSearchCreateRequest
 */
export interface ScheduledSearchCreateRequest {
    /**
     * The name of the scheduled search. 
     * @type {string}
     * @memberof ScheduledSearchCreateRequest
     */
    'name'?: string | null;
    /**
     * The description of the scheduled search. 
     * @type {string}
     * @memberof ScheduledSearchCreateRequest
     */
    'description'?: string | null;
    /**
     * The ID of the saved search that will be executed.
     * @type {string}
     * @memberof ScheduledSearchCreateRequest
     */
    'savedSearchId': string;
    /**
     * The date the scheduled search was initially created.
     * @type {string}
     * @memberof ScheduledSearchCreateRequest
     */
    'created'?: string;
    /**
     * The last date the scheduled search was modified.
     * @type {string}
     * @memberof ScheduledSearchCreateRequest
     */
    'modified'?: string;
    /**
     * 
     * @type {Schedule}
     * @memberof ScheduledSearchCreateRequest
     */
    'schedule': Schedule;
    /**
     * A list of identities that should receive the scheduled search report via email.
     * @type {Array<SearchScheduleRecipientsInner>}
     * @memberof ScheduledSearchCreateRequest
     */
    'recipients': Array<SearchScheduleRecipientsInner>;
    /**
     * Indicates if the scheduled search is enabled. 
     * @type {boolean}
     * @memberof ScheduledSearchCreateRequest
     */
    'enabled'?: boolean;
    /**
     * Indicates if email generation should not be suppressed if search returns no results. 
     * @type {boolean}
     * @memberof ScheduledSearchCreateRequest
     */
    'emailEmptyResults'?: boolean;
    /**
     * Indicates if the generated email should include the query and search results preview (which could include PII). 
     * @type {boolean}
     * @memberof ScheduledSearchCreateRequest
     */
    'displayQueryDetails'?: boolean;
}
/**
 * 
 * @export
 * @interface ScheduledSearchName
 */
export interface ScheduledSearchName {
    /**
     * The name of the scheduled search. 
     * @type {string}
     * @memberof ScheduledSearchName
     */
    'name'?: string | null;
    /**
     * The description of the scheduled search. 
     * @type {string}
     * @memberof ScheduledSearchName
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface Schema
 */
export interface Schema {
    /**
     * The id of the Schema.
     * @type {string}
     * @memberof Schema
     */
    'id'?: string;
    /**
     * The name of the Schema.
     * @type {string}
     * @memberof Schema
     */
    'name'?: string;
    /**
     * The name of the object type on the native system that the schema represents.
     * @type {string}
     * @memberof Schema
     */
    'nativeObjectType'?: string;
    /**
     * The name of the attribute used to calculate the unique identifier for an object in the schema.
     * @type {string}
     * @memberof Schema
     */
    'identityAttribute'?: string;
    /**
     * The name of the attribute used to calculate the display value for an object in the schema.
     * @type {string}
     * @memberof Schema
     */
    'displayAttribute'?: string;
    /**
     * The name of the attribute whose values represent other objects in a hierarchy. Only relevant to group schemas.
     * @type {string}
     * @memberof Schema
     */
    'hierarchyAttribute'?: string;
    /**
     * Flag indicating whether or not the include permissions with the object data when aggregating the schema.
     * @type {boolean}
     * @memberof Schema
     */
    'includePermissions'?: boolean;
    /**
     * The features that the schema supports.
     * @type {Array<SourceFeature>}
     * @memberof Schema
     */
    'features'?: Array<SourceFeature>;
    /**
     * Holds any extra configuration data that the schema may require.
     * @type {object}
     * @memberof Schema
     */
    'configuration'?: object;
    /**
     * The attribute definitions which form the schema.
     * @type {Array<AttributeDefinition>}
     * @memberof Schema
     */
    'attributes'?: Array<AttributeDefinition>;
    /**
     * The date the Schema was created.
     * @type {string}
     * @memberof Schema
     */
    'created'?: string;
    /**
     * The date the Schema was last modified.
     * @type {string}
     * @memberof Schema
     */
    'modified'?: string;
}
/**
 * 
 * @export
 * @interface Search
 */
export interface Search {
    /**
     * The names of the Elasticsearch indices in which to search. If none are provided, then all indices will be searched.
     * @type {Array<Index>}
     * @memberof Search
     */
    'indices'?: Array<Index>;
    /**
     * 
     * @type {QueryType}
     * @memberof Search
     */
    'queryType'?: QueryType;
    /**
     * 
     * @type {string}
     * @memberof Search
     */
    'queryVersion'?: string;
    /**
     * 
     * @type {Query}
     * @memberof Search
     */
    'query'?: Query;
    /**
     * The search query using the Elasticsearch [Query DSL](https://www.elastic.co/guide/en/elasticsearch/reference/7.10/query-dsl.html) syntax.
     * @type {object}
     * @memberof Search
     */
    'queryDsl'?: object;
    /**
     * 
     * @type {TypeAheadQuery}
     * @memberof Search
     */
    'typeAheadQuery'?: TypeAheadQuery;
    /**
     * Indicates whether nested objects from returned search results should be included.
     * @type {boolean}
     * @memberof Search
     */
    'includeNested'?: boolean;
    /**
     * 
     * @type {QueryResultFilter}
     * @memberof Search
     */
    'queryResultFilter'?: QueryResultFilter;
    /**
     * 
     * @type {AggregationType}
     * @memberof Search
     */
    'aggregationType'?: AggregationType;
    /**
     * 
     * @type {string}
     * @memberof Search
     */
    'aggregationsVersion'?: string;
    /**
     * The aggregation search query using Elasticsearch [Aggregations](https://www.elastic.co/guide/en/elasticsearch/reference/5.2/search-aggregations.html) syntax.
     * @type {object}
     * @memberof Search
     */
    'aggregationsDsl'?: object;
    /**
     * 
     * @type {SearchAggregationSpecification}
     * @memberof Search
     */
    'aggregations'?: SearchAggregationSpecification;
    /**
     * The fields to be used to sort the search results. Use + or - to specify the sort direction.
     * @type {Array<string>}
     * @memberof Search
     */
    'sort'?: Array<string>;
    /**
     * Used to begin the search window at the values specified. This parameter consists of the last values of the sorted fields in the current record set. This is used to expand the Elasticsearch limit of 10K records by shifting the 10K window to begin at this value. It is recommended that you always include the ID of the object in addition to any other fields on this parameter in order to ensure you don\'t get duplicate results while paging. For example, when searching for identities, if you are sorting by displayName you will also want to include ID, for example [\"displayName\", \"id\"].  If the last identity ID in the search result is 2c91808375d8e80a0175e1f88a575221 and the last displayName is \"John Doe\", then using that displayName and ID will start a new search after this identity. The searchAfter value will look like [\"John Doe\",\"2c91808375d8e80a0175e1f88a575221\"]
     * @type {Array<string>}
     * @memberof Search
     */
    'searchAfter'?: Array<string>;
    /**
     * The filters to be applied for each filtered field name.
     * @type {{ [key: string]: Filter; }}
     * @memberof Search
     */
    'filters'?: { [key: string]: Filter; };
}
/**
 * 
 * @export
 * @interface SearchAggregationSpecification
 */
export interface SearchAggregationSpecification {
    /**
     * 
     * @type {NestedAggregation}
     * @memberof SearchAggregationSpecification
     */
    'nested'?: NestedAggregation;
    /**
     * 
     * @type {MetricAggregation}
     * @memberof SearchAggregationSpecification
     */
    'metric'?: MetricAggregation;
    /**
     * 
     * @type {FilterAggregation}
     * @memberof SearchAggregationSpecification
     */
    'filter'?: FilterAggregation;
    /**
     * 
     * @type {BucketAggregation}
     * @memberof SearchAggregationSpecification
     */
    'bucket'?: BucketAggregation;
    /**
     * 
     * @type {SubSearchAggregationSpecification}
     * @memberof SearchAggregationSpecification
     */
    'subAggregation'?: SubSearchAggregationSpecification;
}
/**
 * 
 * @export
 * @interface SearchAggregationSpecificationAllOf
 */
export interface SearchAggregationSpecificationAllOf {
    /**
     * 
     * @type {SubSearchAggregationSpecification}
     * @memberof SearchAggregationSpecificationAllOf
     */
    'subAggregation'?: SubSearchAggregationSpecification;
}
/**
 * 
 * @export
 * @interface SearchArguments
 */
export interface SearchArguments {
    /**
     * The ID of the scheduled search that triggered the saved search execution. 
     * @type {string}
     * @memberof SearchArguments
     */
    'scheduleId'?: string;
    /**
     * 
     * @type {SearchArgumentsOwner}
     * @memberof SearchArguments
     */
    'owner'?: SearchArgumentsOwner;
    /**
     * The email recipients of the scheduled search being tested. 
     * @type {Array<TypedReference>}
     * @memberof SearchArguments
     */
    'recipients'?: Array<TypedReference>;
}
/**
 * The owner of the scheduled search being tested. 
 * @export
 * @interface SearchArgumentsOwner
 */
export interface SearchArgumentsOwner {
    /**
     * 
     * @type {DtoType}
     * @memberof SearchArgumentsOwner
     */
    'type': DtoType;
    /**
     * The id of the object. 
     * @type {string}
     * @memberof SearchArgumentsOwner
     */
    'id': string;
}
/**
 * @type SearchDocument
 * @export
 */
export type SearchDocument = AccessProfileDocument | AccountActivityDocument | AccountDocument | AggregationDocument | EntitlementDocument | EventDocument | IdentityDocument | RoleDocument;

/**
 * Enum representing the currently supported filter aggregation types. Additional values may be added in the future without notice.
 * @export
 * @enum {string}
 */

export const SearchFilterType = {
    Term: 'TERM'
} as const;

export type SearchFilterType = typeof SearchFilterType[keyof typeof SearchFilterType];


/**
 * 
 * @export
 * @interface SearchIdentityReference
 */
export interface SearchIdentityReference {
    /**
     * The unique ID of the referenced object.
     * @type {string}
     * @memberof SearchIdentityReference
     */
    'id'?: string;
    /**
     * The human readable name of the referenced object.
     * @type {string}
     * @memberof SearchIdentityReference
     */
    'name'?: string;
    /**
     * 
     * @type {DtoType}
     * @memberof SearchIdentityReference
     */
    'type'?: DtoType;
}
/**
 * 
 * @export
 * @interface SearchIdentityReferenceAllOf
 */
export interface SearchIdentityReferenceAllOf {
    /**
     * 
     * @type {DtoType}
     * @memberof SearchIdentityReferenceAllOf
     */
    'type'?: DtoType;
}
/**
 * 
 * @export
 * @interface SearchSchedule
 */
export interface SearchSchedule {
    /**
     * The ID of the saved search that will be executed.
     * @type {string}
     * @memberof SearchSchedule
     */
    'savedSearchId': string;
    /**
     * The date the scheduled search was initially created.
     * @type {string}
     * @memberof SearchSchedule
     */
    'created'?: string;
    /**
     * The last date the scheduled search was modified.
     * @type {string}
     * @memberof SearchSchedule
     */
    'modified'?: string;
    /**
     * 
     * @type {Schedule}
     * @memberof SearchSchedule
     */
    'schedule': Schedule;
    /**
     * A list of identities that should receive the scheduled search report via email.
     * @type {Array<SearchScheduleRecipientsInner>}
     * @memberof SearchSchedule
     */
    'recipients': Array<SearchScheduleRecipientsInner>;
    /**
     * Indicates if the scheduled search is enabled. 
     * @type {boolean}
     * @memberof SearchSchedule
     */
    'enabled'?: boolean;
    /**
     * Indicates if email generation should not be suppressed if search returns no results. 
     * @type {boolean}
     * @memberof SearchSchedule
     */
    'emailEmptyResults'?: boolean;
    /**
     * Indicates if the generated email should include the query and search results preview (which could include PII). 
     * @type {boolean}
     * @memberof SearchSchedule
     */
    'displayQueryDetails'?: boolean;
}
/**
 * 
 * @export
 * @interface SearchScheduleRecipientsInner
 */
export interface SearchScheduleRecipientsInner {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof SearchScheduleRecipientsInner
     */
    'type': SearchScheduleRecipientsInnerTypeEnum;
    /**
     * The ID of the referenced object
     * @type {string}
     * @memberof SearchScheduleRecipientsInner
     */
    'id': string;
}

export const SearchScheduleRecipientsInnerTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type SearchScheduleRecipientsInnerTypeEnum = typeof SearchScheduleRecipientsInnerTypeEnum[keyof typeof SearchScheduleRecipientsInnerTypeEnum];

/**
 * 
 * @export
 * @interface SectionDetails
 */
export interface SectionDetails {
    /**
     * Name of the FormItem
     * @type {string}
     * @memberof SectionDetails
     */
    'name'?: string;
    /**
     * Label of the section
     * @type {string}
     * @memberof SectionDetails
     */
    'label'?: string;
    /**
     * List of FormItems. FormItems can be SectionDetails and/or FieldDetails
     * @type {Array<object>}
     * @memberof SectionDetails
     */
    'formItems'?: Array<object>;
}
/**
 * 
 * @export
 * @interface SectionDetailsAllOf
 */
export interface SectionDetailsAllOf {
    /**
     * Label of the section
     * @type {string}
     * @memberof SectionDetailsAllOf
     */
    'label'?: string;
    /**
     * List of FormItems. FormItems can be SectionDetails and/or FieldDetails
     * @type {Array<object>}
     * @memberof SectionDetailsAllOf
     */
    'formItems'?: Array<object>;
}
/**
 * 
 * @export
 * @interface Selector
 */
export interface Selector {
    /**
     * 
     * @type {SelectorType}
     * @memberof Selector
     */
    'type': SelectorType;
    /**
     * The selected values. 
     * @type {Array<string>}
     * @memberof Selector
     */
    'values': Array<string>;
    /**
     * The selected interval for RANGE selectors. 
     * @type {number}
     * @memberof Selector
     */
    'interval'?: number | null;
}
/**
 * Enum representing the currently supported selector types.  LIST - the *values* array contains one or more distinct values.  RANGE - the *values* array contains two values: the start and end of the range, inclusive.  Additional values may be added in the future without notice. 
 * @export
 * @enum {string}
 */

export const SelectorType = {
    List: 'LIST',
    Range: 'RANGE'
} as const;

export type SelectorType = typeof SelectorType[keyof typeof SelectorType];


/**
 * 
 * @export
 * @interface ServiceDeskIntegrationDto
 */
export interface ServiceDeskIntegrationDto {
    /**
     * System-generated unique ID of the Object
     * @type {string}
     * @memberof ServiceDeskIntegrationDto
     */
    'id'?: string;
    /**
     * Name of the Object
     * @type {string}
     * @memberof ServiceDeskIntegrationDto
     */
    'name': string;
    /**
     * Creation date of the Object
     * @type {string}
     * @memberof ServiceDeskIntegrationDto
     */
    'created'?: string;
    /**
     * Last modification date of the Object
     * @type {string}
     * @memberof ServiceDeskIntegrationDto
     */
    'modified'?: string;
    /**
     * Description of the Service Desk integration
     * @type {string}
     * @memberof ServiceDeskIntegrationDto
     */
    'description': string;
    /**
     * Service Desk integration types  - ServiceNowSDIM - ServiceNow 
     * @type {string}
     * @memberof ServiceDeskIntegrationDto
     */
    'type': string;
    /**
     * 
     * @type {ServiceDeskIntegrationDtoAllOfOwnerRef}
     * @memberof ServiceDeskIntegrationDto
     */
    'ownerRef'?: ServiceDeskIntegrationDtoAllOfOwnerRef;
    /**
     * 
     * @type {ServiceDeskIntegrationDtoAllOfClusterRef}
     * @memberof ServiceDeskIntegrationDto
     */
    'clusterRef'?: ServiceDeskIntegrationDtoAllOfClusterRef;
    /**
     * ID of the cluster for the Service Desk integration (replaced by clusterRef, retained for backward compatibility)
     * @type {string}
     * @memberof ServiceDeskIntegrationDto
     * @deprecated
     */
    'cluster'?: string;
    /**
     * Source IDs for the Service Desk integration (replaced by provisioningConfig.managedSResourceRefs, but retained here for backward compatibility)
     * @type {Array<string>}
     * @memberof ServiceDeskIntegrationDto
     * @deprecated
     */
    'managedSources'?: Array<string>;
    /**
     * 
     * @type {ProvisioningConfig}
     * @memberof ServiceDeskIntegrationDto
     */
    'provisioningConfig'?: ProvisioningConfig;
    /**
     * Attributes of the Service Desk integration.  Validation constraints enforced by the implementation.
     * @type {{ [key: string]: any; }}
     * @memberof ServiceDeskIntegrationDto
     */
    'attributes': { [key: string]: any; };
    /**
     * 
     * @type {ServiceDeskIntegrationDtoAllOfBeforeProvisioningRule}
     * @memberof ServiceDeskIntegrationDto
     */
    'beforeProvisioningRule'?: ServiceDeskIntegrationDtoAllOfBeforeProvisioningRule;
}
/**
 * Specification of a Service Desk integration
 * @export
 * @interface ServiceDeskIntegrationDtoAllOf
 */
export interface ServiceDeskIntegrationDtoAllOf {
    /**
     * Description of the Service Desk integration
     * @type {string}
     * @memberof ServiceDeskIntegrationDtoAllOf
     */
    'description': string;
    /**
     * Service Desk integration types  - ServiceNowSDIM - ServiceNow 
     * @type {string}
     * @memberof ServiceDeskIntegrationDtoAllOf
     */
    'type': string;
    /**
     * 
     * @type {ServiceDeskIntegrationDtoAllOfOwnerRef}
     * @memberof ServiceDeskIntegrationDtoAllOf
     */
    'ownerRef'?: ServiceDeskIntegrationDtoAllOfOwnerRef;
    /**
     * 
     * @type {ServiceDeskIntegrationDtoAllOfClusterRef}
     * @memberof ServiceDeskIntegrationDtoAllOf
     */
    'clusterRef'?: ServiceDeskIntegrationDtoAllOfClusterRef;
    /**
     * ID of the cluster for the Service Desk integration (replaced by clusterRef, retained for backward compatibility)
     * @type {string}
     * @memberof ServiceDeskIntegrationDtoAllOf
     * @deprecated
     */
    'cluster'?: string;
    /**
     * Source IDs for the Service Desk integration (replaced by provisioningConfig.managedSResourceRefs, but retained here for backward compatibility)
     * @type {Array<string>}
     * @memberof ServiceDeskIntegrationDtoAllOf
     * @deprecated
     */
    'managedSources'?: Array<string>;
    /**
     * 
     * @type {ProvisioningConfig}
     * @memberof ServiceDeskIntegrationDtoAllOf
     */
    'provisioningConfig'?: ProvisioningConfig;
    /**
     * Attributes of the Service Desk integration.  Validation constraints enforced by the implementation.
     * @type {{ [key: string]: any; }}
     * @memberof ServiceDeskIntegrationDtoAllOf
     */
    'attributes': { [key: string]: any; };
    /**
     * 
     * @type {ServiceDeskIntegrationDtoAllOfBeforeProvisioningRule}
     * @memberof ServiceDeskIntegrationDtoAllOf
     */
    'beforeProvisioningRule'?: ServiceDeskIntegrationDtoAllOfBeforeProvisioningRule;
}
/**
 * Reference to beforeProvisioningRule for this Service Desk integration
 * @export
 * @interface ServiceDeskIntegrationDtoAllOfBeforeProvisioningRule
 */
export interface ServiceDeskIntegrationDtoAllOfBeforeProvisioningRule {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof ServiceDeskIntegrationDtoAllOfBeforeProvisioningRule
     */
    'type'?: ServiceDeskIntegrationDtoAllOfBeforeProvisioningRuleTypeEnum;
    /**
     * ID of the rule
     * @type {string}
     * @memberof ServiceDeskIntegrationDtoAllOfBeforeProvisioningRule
     */
    'id'?: string;
    /**
     * Human-readable display name of the rule
     * @type {string}
     * @memberof ServiceDeskIntegrationDtoAllOfBeforeProvisioningRule
     */
    'name'?: string;
}

export const ServiceDeskIntegrationDtoAllOfBeforeProvisioningRuleTypeEnum = {
    Rule: 'RULE'
} as const;

export type ServiceDeskIntegrationDtoAllOfBeforeProvisioningRuleTypeEnum = typeof ServiceDeskIntegrationDtoAllOfBeforeProvisioningRuleTypeEnum[keyof typeof ServiceDeskIntegrationDtoAllOfBeforeProvisioningRuleTypeEnum];

/**
 * Reference to the source cluster for this Service Desk integration
 * @export
 * @interface ServiceDeskIntegrationDtoAllOfClusterRef
 */
export interface ServiceDeskIntegrationDtoAllOfClusterRef {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof ServiceDeskIntegrationDtoAllOfClusterRef
     */
    'type'?: ServiceDeskIntegrationDtoAllOfClusterRefTypeEnum;
    /**
     * ID of the cluster
     * @type {string}
     * @memberof ServiceDeskIntegrationDtoAllOfClusterRef
     */
    'id'?: string;
    /**
     * Human-readable display name of the cluster
     * @type {string}
     * @memberof ServiceDeskIntegrationDtoAllOfClusterRef
     */
    'name'?: string;
}

export const ServiceDeskIntegrationDtoAllOfClusterRefTypeEnum = {
    Cluster: 'CLUSTER'
} as const;

export type ServiceDeskIntegrationDtoAllOfClusterRefTypeEnum = typeof ServiceDeskIntegrationDtoAllOfClusterRefTypeEnum[keyof typeof ServiceDeskIntegrationDtoAllOfClusterRefTypeEnum];

/**
 * Reference to the identity that is the owner of this Service Desk integration
 * @export
 * @interface ServiceDeskIntegrationDtoAllOfOwnerRef
 */
export interface ServiceDeskIntegrationDtoAllOfOwnerRef {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof ServiceDeskIntegrationDtoAllOfOwnerRef
     */
    'type'?: ServiceDeskIntegrationDtoAllOfOwnerRefTypeEnum;
    /**
     * ID of the identity
     * @type {string}
     * @memberof ServiceDeskIntegrationDtoAllOfOwnerRef
     */
    'id'?: string;
    /**
     * Human-readable display name of the identity
     * @type {string}
     * @memberof ServiceDeskIntegrationDtoAllOfOwnerRef
     */
    'name'?: string;
}

export const ServiceDeskIntegrationDtoAllOfOwnerRefTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type ServiceDeskIntegrationDtoAllOfOwnerRefTypeEnum = typeof ServiceDeskIntegrationDtoAllOfOwnerRefTypeEnum[keyof typeof ServiceDeskIntegrationDtoAllOfOwnerRefTypeEnum];

/**
 * 
 * @export
 * @interface ServiceDeskIntegrationTemplateDto
 */
export interface ServiceDeskIntegrationTemplateDto {
    /**
     * System-generated unique ID of the Object
     * @type {string}
     * @memberof ServiceDeskIntegrationTemplateDto
     */
    'id'?: string;
    /**
     * Name of the Object
     * @type {string}
     * @memberof ServiceDeskIntegrationTemplateDto
     */
    'name': string;
    /**
     * Creation date of the Object
     * @type {string}
     * @memberof ServiceDeskIntegrationTemplateDto
     */
    'created'?: string;
    /**
     * Last modification date of the Object
     * @type {string}
     * @memberof ServiceDeskIntegrationTemplateDto
     */
    'modified'?: string;
    /**
     * The \'type\' property specifies the type of the Service Desk integration template.
     * @type {string}
     * @memberof ServiceDeskIntegrationTemplateDto
     */
    'type': string;
    /**
     * The \'attributes\' property value is a map of attributes available for integrations using this Service Desk integration template.
     * @type {{ [key: string]: any; }}
     * @memberof ServiceDeskIntegrationTemplateDto
     */
    'attributes': { [key: string]: any; };
    /**
     * 
     * @type {ProvisioningConfig}
     * @memberof ServiceDeskIntegrationTemplateDto
     */
    'provisioningConfig': ProvisioningConfig;
}
/**
 * This is the model for a Service Desk integration template, used to create and edit Service Desk Integrations.
 * @export
 * @interface ServiceDeskIntegrationTemplateDtoAllOf
 */
export interface ServiceDeskIntegrationTemplateDtoAllOf {
    /**
     * The \'type\' property specifies the type of the Service Desk integration template.
     * @type {string}
     * @memberof ServiceDeskIntegrationTemplateDtoAllOf
     */
    'type': string;
    /**
     * The \'attributes\' property value is a map of attributes available for integrations using this Service Desk integration template.
     * @type {{ [key: string]: any; }}
     * @memberof ServiceDeskIntegrationTemplateDtoAllOf
     */
    'attributes': { [key: string]: any; };
    /**
     * 
     * @type {ProvisioningConfig}
     * @memberof ServiceDeskIntegrationTemplateDtoAllOf
     */
    'provisioningConfig': ProvisioningConfig;
}
/**
 * This represents a Service Desk Integration template type.
 * @export
 * @interface ServiceDeskIntegrationTemplateType
 */
export interface ServiceDeskIntegrationTemplateType {
    /**
     * This is the name of the type.
     * @type {string}
     * @memberof ServiceDeskIntegrationTemplateType
     */
    'name'?: string;
    /**
     * This is the type value for the type.
     * @type {string}
     * @memberof ServiceDeskIntegrationTemplateType
     */
    'type': string;
    /**
     * This is the scriptName attribute value for the type.
     * @type {string}
     * @memberof ServiceDeskIntegrationTemplateType
     */
    'scriptName': string;
}
/**
 * 
 * @export
 * @interface SetLifecycleState200Response
 */
export interface SetLifecycleState200Response {
    /**
     * The ID of the IdentityRequest object that was generated when the workflow launches
     * @type {string}
     * @memberof SetLifecycleState200Response
     */
    'accountActivityId'?: string;
}
/**
 * 
 * @export
 * @interface SetLifecycleStateRequest
 */
export interface SetLifecycleStateRequest {
    /**
     * The ID of the lifecycle state to set
     * @type {string}
     * @memberof SetLifecycleStateRequest
     */
    'lifecycleStateId'?: string;
}
/**
 * Details of the Entitlement criteria
 * @export
 * @interface SodExemptCriteria
 */
export interface SodExemptCriteria {
    /**
     * If the entitlement already belonged to the user or not.
     * @type {boolean}
     * @memberof SodExemptCriteria
     */
    'existing'?: boolean;
    /**
     * 
     * @type {DtoType}
     * @memberof SodExemptCriteria
     */
    'type'?: DtoType;
    /**
     * Entitlement ID
     * @type {string}
     * @memberof SodExemptCriteria
     */
    'id'?: string;
    /**
     * Entitlement name
     * @type {string}
     * @memberof SodExemptCriteria
     */
    'name'?: string;
}
/**
 * The inner object representing the completed SOD Violation check
 * @export
 * @interface SodViolationCheckResult
 */
export interface SodViolationCheckResult {
    /**
     * 
     * @type {ErrorMessageDto}
     * @memberof SodViolationCheckResult
     */
    'message'?: ErrorMessageDto;
    /**
     * Arbitrary key-value pairs. They will never be processed by the IdentityNow system but will be returned on completion of the violation check.
     * @type {{ [key: string]: string; }}
     * @memberof SodViolationCheckResult
     */
    'clientMetadata'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<SodViolationContext>}
     * @memberof SodViolationCheckResult
     */
    'violationContexts'?: Array<SodViolationContext>;
    /**
     * A list of the Policies that were violated
     * @type {Array<BaseReferenceDto>}
     * @memberof SodViolationCheckResult
     */
    'violatedPolicies'?: Array<BaseReferenceDto>;
}
/**
 * The contextual information of the violated criteria
 * @export
 * @interface SodViolationContext
 */
export interface SodViolationContext {
    /**
     * 
     * @type {BaseReferenceDto}
     * @memberof SodViolationContext
     */
    'policy'?: BaseReferenceDto;
    /**
     * 
     * @type {SodViolationContextConflictingAccessCriteria}
     * @memberof SodViolationContext
     */
    'conflictingAccessCriteria'?: SodViolationContextConflictingAccessCriteria;
}
/**
 * An object referencing a completed SOD violation check
 * @export
 * @interface SodViolationContextCheckCompleted
 */
export interface SodViolationContextCheckCompleted {
    /**
     * The status of SOD violation check
     * @type {string}
     * @memberof SodViolationContextCheckCompleted
     */
    'state'?: SodViolationContextCheckCompletedStateEnum;
    /**
     * The id of the Violation check event
     * @type {string}
     * @memberof SodViolationContextCheckCompleted
     */
    'uuid'?: string;
    /**
     * 
     * @type {SodViolationCheckResult}
     * @memberof SodViolationContextCheckCompleted
     */
    'violationCheckResult'?: SodViolationCheckResult;
}

export const SodViolationContextCheckCompletedStateEnum = {
    Success: 'SUCCESS',
    Error: 'ERROR'
} as const;

export type SodViolationContextCheckCompletedStateEnum = typeof SodViolationContextCheckCompletedStateEnum[keyof typeof SodViolationContextCheckCompletedStateEnum];

/**
 * The object which contains the left and right hand side of the entitlements that got violated according to the policy.
 * @export
 * @interface SodViolationContextConflictingAccessCriteria
 */
export interface SodViolationContextConflictingAccessCriteria {
    /**
     * 
     * @type {SodViolationContextConflictingAccessCriteriaLeftCriteria}
     * @memberof SodViolationContextConflictingAccessCriteria
     */
    'leftCriteria'?: SodViolationContextConflictingAccessCriteriaLeftCriteria;
    /**
     * 
     * @type {SodViolationContextConflictingAccessCriteriaLeftCriteria}
     * @memberof SodViolationContextConflictingAccessCriteria
     */
    'rightCriteria'?: SodViolationContextConflictingAccessCriteriaLeftCriteria;
}
/**
 * 
 * @export
 * @interface SodViolationContextConflictingAccessCriteriaLeftCriteria
 */
export interface SodViolationContextConflictingAccessCriteriaLeftCriteria {
    /**
     * 
     * @type {Array<SodExemptCriteria>}
     * @memberof SodViolationContextConflictingAccessCriteriaLeftCriteria
     */
    'criteriaList'?: Array<SodExemptCriteria>;
}
/**
 * 
 * @export
 * @interface Source
 */
export interface Source {
    /**
     * the id of the Source
     * @type {string}
     * @memberof Source
     */
    'id'?: string;
    /**
     * Human-readable description of the source
     * @type {string}
     * @memberof Source
     */
    'description'?: string;
    /**
     * 
     * @type {SourceOwner}
     * @memberof Source
     */
    'owner'?: SourceOwner;
    /**
     * 
     * @type {SourceCluster}
     * @memberof Source
     */
    'cluster'?: SourceCluster;
    /**
     * 
     * @type {SourceAccountCorrelationConfig}
     * @memberof Source
     */
    'accountCorrelationConfig'?: SourceAccountCorrelationConfig;
    /**
     * 
     * @type {SourceAccountCorrelationRule}
     * @memberof Source
     */
    'accountCorrelationRule'?: SourceAccountCorrelationRule;
    /**
     * 
     * @type {ManagerCorrelationMapping}
     * @memberof Source
     */
    'managerCorrelationMapping'?: ManagerCorrelationMapping;
    /**
     * 
     * @type {SourceManagerCorrelationRule}
     * @memberof Source
     */
    'managerCorrelationRule'?: SourceManagerCorrelationRule;
    /**
     * 
     * @type {SourceBeforeProvisioningRule}
     * @memberof Source
     */
    'beforeProvisioningRule'?: SourceBeforeProvisioningRule;
    /**
     * List of references to Schema objects
     * @type {Array<SourceSchemasInner>}
     * @memberof Source
     */
    'schemas'?: Array<SourceSchemasInner>;
    /**
     * List of references to the associated PasswordPolicy objects.
     * @type {Array<SourcePasswordPoliciesInner>}
     * @memberof Source
     */
    'passwordPolicies'?: Array<SourcePasswordPoliciesInner>;
    /**
     * Optional features that can be supported by a source.
     * @type {Array<SourceFeature>}
     * @memberof Source
     */
    'features'?: Array<SourceFeature>;
    /**
     * Specifies the type of system being managed e.g. Active Directory, Workday, etc..
     * @type {string}
     * @memberof Source
     */
    'type'?: string;
    /**
     * Connector script name.
     * @type {string}
     * @memberof Source
     */
    'connector'?: string;
    /**
     * The fully qualified name of the Java class that implements the connector interface.
     * @type {string}
     * @memberof Source
     */
    'connectorClass'?: string;
    /**
     * Connector specific configuration; will differ from type to type.
     * @type {object}
     * @memberof Source
     */
    'connectorAttributes'?: object;
    /**
     * Number from 0 to 100 that specifies when to skip the delete phase.
     * @type {number}
     * @memberof Source
     */
    'deleteThreshold'?: number;
    /**
     * When true indicates the source is referenced by an IdentityProfile.
     * @type {boolean}
     * @memberof Source
     */
    'authoritative'?: boolean;
    /**
     * 
     * @type {SourceManagementWorkgroup}
     * @memberof Source
     */
    'managementWorkgroup'?: SourceManagementWorkgroup;
    /**
     * When true indicates a healthy source
     * @type {boolean}
     * @memberof Source
     */
    'healthy'?: boolean;
    /**
     * A status identifier, giving specific information on why a source is healthy or not
     * @type {string}
     * @memberof Source
     */
    'status'?: string;
    /**
     * Timestamp showing when a source health check was last performed
     * @type {string}
     * @memberof Source
     */
    'since'?: string;
    /**
     * The id of connector
     * @type {string}
     * @memberof Source
     */
    'connectorId'?: string;
    /**
     * The name of the connector that was chosen on source creation
     * @type {string}
     * @memberof Source
     */
    'connectorName'?: string;
    /**
     * The type of connection (direct or file)
     * @type {string}
     * @memberof Source
     */
    'connectionType'?: string;
    /**
     * The connector implementstion id
     * @type {string}
     * @memberof Source
     */
    'connectorImplementstionId'?: string;
}
/**
 * Reference to an Account Correlation Config object
 * @export
 * @interface SourceAccountCorrelationConfig
 */
export interface SourceAccountCorrelationConfig {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof SourceAccountCorrelationConfig
     */
    'type'?: SourceAccountCorrelationConfigTypeEnum;
    /**
     * ID of the account correlation config
     * @type {string}
     * @memberof SourceAccountCorrelationConfig
     */
    'id'?: string;
    /**
     * Human-readable display name of the account correlation config
     * @type {string}
     * @memberof SourceAccountCorrelationConfig
     */
    'name'?: string;
}

export const SourceAccountCorrelationConfigTypeEnum = {
    AccountCorrelationConfig: 'ACCOUNT_CORRELATION_CONFIG'
} as const;

export type SourceAccountCorrelationConfigTypeEnum = typeof SourceAccountCorrelationConfigTypeEnum[keyof typeof SourceAccountCorrelationConfigTypeEnum];

/**
 * Reference to a Rule that can do COMPLEX correlation, should only be used when accountCorrelationConfig can\'t be used.
 * @export
 * @interface SourceAccountCorrelationRule
 */
export interface SourceAccountCorrelationRule {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof SourceAccountCorrelationRule
     */
    'type'?: SourceAccountCorrelationRuleTypeEnum;
    /**
     * ID of the rule
     * @type {string}
     * @memberof SourceAccountCorrelationRule
     */
    'id'?: string;
    /**
     * Human-readable display name of the rule
     * @type {string}
     * @memberof SourceAccountCorrelationRule
     */
    'name'?: string;
}

export const SourceAccountCorrelationRuleTypeEnum = {
    Rule: 'RULE'
} as const;

export type SourceAccountCorrelationRuleTypeEnum = typeof SourceAccountCorrelationRuleTypeEnum[keyof typeof SourceAccountCorrelationRuleTypeEnum];

/**
 * Rule that runs on the CCG and allows for customization of provisioning plans before the connector is called.
 * @export
 * @interface SourceBeforeProvisioningRule
 */
export interface SourceBeforeProvisioningRule {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof SourceBeforeProvisioningRule
     */
    'type'?: SourceBeforeProvisioningRuleTypeEnum;
    /**
     * ID of the rule
     * @type {string}
     * @memberof SourceBeforeProvisioningRule
     */
    'id'?: string;
    /**
     * Human-readable display name of the rule
     * @type {string}
     * @memberof SourceBeforeProvisioningRule
     */
    'name'?: string;
}

export const SourceBeforeProvisioningRuleTypeEnum = {
    Rule: 'RULE'
} as const;

export type SourceBeforeProvisioningRuleTypeEnum = typeof SourceBeforeProvisioningRuleTypeEnum[keyof typeof SourceBeforeProvisioningRuleTypeEnum];

/**
 * Reference to the associated Cluster
 * @export
 * @interface SourceCluster
 */
export interface SourceCluster {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof SourceCluster
     */
    'type'?: SourceClusterTypeEnum;
    /**
     * ID of the cluster
     * @type {string}
     * @memberof SourceCluster
     */
    'id'?: string;
    /**
     * Human-readable display name of the cluster
     * @type {string}
     * @memberof SourceCluster
     */
    'name'?: string;
}

export const SourceClusterTypeEnum = {
    Cluster: 'CLUSTER'
} as const;

export type SourceClusterTypeEnum = typeof SourceClusterTypeEnum[keyof typeof SourceClusterTypeEnum];

/**
 * Optional features that can be supported by an source. * AUTHENTICATE: The source supports pass-through authentication. * COMPOSITE: The source supports composite source creation. * DIRECT_PERMISSIONS: The source supports returning DirectPermissions. * DISCOVER_SCHEMA: The source supports discovering schemas for users and groups. * ENABLE The source supports reading if an account is enabled or disabled. * MANAGER_LOOKUP: The source supports looking up managers as they are encountered in a feed. This is the opposite of NO_RANDOM_ACCESS. * NO_RANDOM_ACCESS: The source does not support random access and the getObject() methods should not be called and expected to perform. * PROXY: The source can serve as a proxy for another source. When an source has a proxy, all connector calls made with that source are redirected through the connector for the proxy source. * SEARCH * TEMPLATE * UNLOCK: The source supports reading if an account is locked or unlocked. * UNSTRUCTURED_TARGETS: The source supports returning unstructured Targets. * SHAREPOINT_TARGET: The source supports returning unstructured Target data for SharePoint. It will be typically used by AD, LDAP sources. * PROVISIONING: The source can both read and write accounts. Having this feature implies that the provision() method is implemented. It also means that direct and target permissions can also be provisioned if they can be returned by aggregation. * GROUP_PROVISIONING: The source can both read and write groups. Having this feature implies that the provision() method is implemented. * SYNC_PROVISIONING: The source can provision accounts synchronously. * PASSWORD: The source can provision password changes. Since sources can never read passwords, this is should only be used in conjunction with the PROVISIONING feature. * CURRENT_PASSWORD: Some source types support verification of the current password * ACCOUNT_ONLY_REQUEST: The source supports requesting accounts without entitlements. * ADDITIONAL_ACCOUNT_REQUEST: The source supports requesting additional accounts. * NO_AGGREGATION: A source that does not support aggregation. * GROUPS_HAVE_MEMBERS: The source models group memberships with a member attribute on the group object rather than a groups attribute on the account object. This effects the implementation of delta account aggregation. * NO_PERMISSIONS_PROVISIONING: Indicates that the connector cannot provision direct or target permissions for accounts. When DIRECT_PERMISSIONS and PROVISIONING features are present, it is assumed that the connector can also provision direct permissions. This feature disables that assumption and causes permission request to be converted to work items for accounts. * NO_GROUP_PERMISSIONS_PROVISIONING: Indicates that the connector cannot provision direct or target permissions for groups. When DIRECT_PERMISSIONS and PROVISIONING features are present, it is assumed that the connector can also provision direct permissions. This feature disables that assumption and causes permission request to be converted to work items for groups. * NO_UNSTRUCTURED_TARGETS_PROVISIONING: This string will be replaced by NO_GROUP_PERMISSIONS_PROVISIONING and NO_PERMISSIONS_PROVISIONING. * NO_DIRECT_PERMISSIONS_PROVISIONING: This string will be replaced by NO_GROUP_PERMISSIONS_PROVISIONING and NO_PERMISSIONS_PROVISIONING.
 * @export
 * @enum {string}
 */

export const SourceFeature = {
    Authenticate: 'AUTHENTICATE',
    Composite: 'COMPOSITE',
    DirectPermissions: 'DIRECT_PERMISSIONS',
    DiscoverSchema: 'DISCOVER_SCHEMA',
    Enable: 'ENABLE',
    ManagerLookup: 'MANAGER_LOOKUP',
    NoRandomAccess: 'NO_RANDOM_ACCESS',
    Proxy: 'PROXY',
    Search: 'SEARCH',
    Template: 'TEMPLATE',
    Unlock: 'UNLOCK',
    UnstructuredTargets: 'UNSTRUCTURED_TARGETS',
    SharepointTarget: 'SHAREPOINT_TARGET',
    Provisioning: 'PROVISIONING',
    GroupProvisioning: 'GROUP_PROVISIONING',
    SyncProvisioning: 'SYNC_PROVISIONING',
    Password: 'PASSWORD',
    CurrentPassword: 'CURRENT_PASSWORD',
    AccountOnlyRequest: 'ACCOUNT_ONLY_REQUEST',
    AdditionalAccountRequest: 'ADDITIONAL_ACCOUNT_REQUEST',
    NoAggregation: 'NO_AGGREGATION',
    GroupsHaveMembers: 'GROUPS_HAVE_MEMBERS',
    NoPermissionsProvisioning: 'NO_PERMISSIONS_PROVISIONING',
    NoGroupPermissionsProvisioning: 'NO_GROUP_PERMISSIONS_PROVISIONING',
    NoUnstructuredTargetsProvisioning: 'NO_UNSTRUCTURED_TARGETS_PROVISIONING',
    NoDirectPermissionsProvisioning: 'NO_DIRECT_PERMISSIONS_PROVISIONING'
} as const;

export type SourceFeature = typeof SourceFeature[keyof typeof SourceFeature];


/**
 * Dto for source health data
 * @export
 * @interface SourceHealthDto
 */
export interface SourceHealthDto {
    /**
     * the id of the Source
     * @type {string}
     * @memberof SourceHealthDto
     */
    'id'?: string;
    /**
     * Specifies the type of system being managed e.g. Active Directory, Workday, etc..
     * @type {string}
     * @memberof SourceHealthDto
     */
    'type'?: string;
    /**
     * the name of the source
     * @type {string}
     * @memberof SourceHealthDto
     */
    'name'?: string;
    /**
     * source\'s org
     * @type {string}
     * @memberof SourceHealthDto
     */
    'org'?: string;
    /**
     * Is the source authoritative
     * @type {boolean}
     * @memberof SourceHealthDto
     */
    'isAuthoritative'?: boolean;
    /**
     * Is the source in a cluster
     * @type {boolean}
     * @memberof SourceHealthDto
     */
    'isCluster'?: boolean;
    /**
     * source\'s hostname
     * @type {string}
     * @memberof SourceHealthDto
     */
    'hostname'?: string;
    /**
     * source\'s pod
     * @type {string}
     * @memberof SourceHealthDto
     */
    'pod'?: string;
    /**
     * The version of the iqService
     * @type {string}
     * @memberof SourceHealthDto
     */
    'iqServiceVersion'?: string;
    /**
     * connection test result
     * @type {string}
     * @memberof SourceHealthDto
     */
    'status'?: SourceHealthDtoStatusEnum;
}

export const SourceHealthDtoStatusEnum = {
    ErrorCluster: 'SOURCE_STATE_ERROR_CLUSTER',
    ErrorSource: 'SOURCE_STATE_ERROR_SOURCE',
    ErrorVa: 'SOURCE_STATE_ERROR_VA',
    FailureCluster: 'SOURCE_STATE_FAILURE_CLUSTER',
    FailureSource: 'SOURCE_STATE_FAILURE_SOURCE',
    Healthy: 'SOURCE_STATE_HEALTHY',
    UncheckedCluster: 'SOURCE_STATE_UNCHECKED_CLUSTER',
    UncheckedClusterNoSources: 'SOURCE_STATE_UNCHECKED_CLUSTER_NO_SOURCES',
    UncheckedSource: 'SOURCE_STATE_UNCHECKED_SOURCE',
    UncheckedSourceNoAccounts: 'SOURCE_STATE_UNCHECKED_SOURCE_NO_ACCOUNTS'
} as const;

export type SourceHealthDtoStatusEnum = typeof SourceHealthDtoStatusEnum[keyof typeof SourceHealthDtoStatusEnum];

/**
 * Reference to Management Workgroup for this Source
 * @export
 * @interface SourceManagementWorkgroup
 */
export interface SourceManagementWorkgroup {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof SourceManagementWorkgroup
     */
    'type'?: SourceManagementWorkgroupTypeEnum;
    /**
     * ID of the management workgroup
     * @type {string}
     * @memberof SourceManagementWorkgroup
     */
    'id'?: string;
    /**
     * Human-readable display name of the management workgroup
     * @type {string}
     * @memberof SourceManagementWorkgroup
     */
    'name'?: string;
}

export const SourceManagementWorkgroupTypeEnum = {
    GovernanceGroup: 'GOVERNANCE_GROUP'
} as const;

export type SourceManagementWorkgroupTypeEnum = typeof SourceManagementWorkgroupTypeEnum[keyof typeof SourceManagementWorkgroupTypeEnum];

/**
 * Reference to the ManagerCorrelationRule, only used when a simple filter isn\'t sufficient.
 * @export
 * @interface SourceManagerCorrelationRule
 */
export interface SourceManagerCorrelationRule {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof SourceManagerCorrelationRule
     */
    'type'?: SourceManagerCorrelationRuleTypeEnum;
    /**
     * ID of the rule
     * @type {string}
     * @memberof SourceManagerCorrelationRule
     */
    'id'?: string;
    /**
     * Human-readable display name of the rule
     * @type {string}
     * @memberof SourceManagerCorrelationRule
     */
    'name'?: string;
}

export const SourceManagerCorrelationRuleTypeEnum = {
    Rule: 'RULE'
} as const;

export type SourceManagerCorrelationRuleTypeEnum = typeof SourceManagerCorrelationRuleTypeEnum[keyof typeof SourceManagerCorrelationRuleTypeEnum];

/**
 * Reference to an owning Identity Object
 * @export
 * @interface SourceOwner
 */
export interface SourceOwner {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof SourceOwner
     */
    'type'?: SourceOwnerTypeEnum;
    /**
     * ID of the identity
     * @type {string}
     * @memberof SourceOwner
     */
    'id'?: string;
    /**
     * Human-readable display name of the identity
     * @type {string}
     * @memberof SourceOwner
     */
    'name'?: string;
}

export const SourceOwnerTypeEnum = {
    Identity: 'IDENTITY'
} as const;

export type SourceOwnerTypeEnum = typeof SourceOwnerTypeEnum[keyof typeof SourceOwnerTypeEnum];

/**
 * 
 * @export
 * @interface SourcePasswordPoliciesInner
 */
export interface SourcePasswordPoliciesInner {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof SourcePasswordPoliciesInner
     */
    'type'?: SourcePasswordPoliciesInnerTypeEnum;
    /**
     * ID of the policy
     * @type {string}
     * @memberof SourcePasswordPoliciesInner
     */
    'id'?: string;
    /**
     * Human-readable display name of the policy
     * @type {string}
     * @memberof SourcePasswordPoliciesInner
     */
    'name'?: string;
}

export const SourcePasswordPoliciesInnerTypeEnum = {
    PasswordPolicy: 'PASSWORD_POLICY'
} as const;

export type SourcePasswordPoliciesInnerTypeEnum = typeof SourcePasswordPoliciesInnerTypeEnum[keyof typeof SourcePasswordPoliciesInnerTypeEnum];

/**
 * 
 * @export
 * @interface SourceSchemasInner
 */
export interface SourceSchemasInner {
    /**
     * The type of object being referenced
     * @type {string}
     * @memberof SourceSchemasInner
     */
    'type'?: SourceSchemasInnerTypeEnum;
    /**
     * ID of the schema
     * @type {string}
     * @memberof SourceSchemasInner
     */
    'id'?: string;
    /**
     * Human-readable display name of the schema
     * @type {string}
     * @memberof SourceSchemasInner
     */
    'name'?: string;
}

export const SourceSchemasInnerTypeEnum = {
    ConnectorSchema: 'CONNECTOR_SCHEMA'
} as const;

export type SourceSchemasInnerTypeEnum = typeof SourceSchemasInnerTypeEnum[keyof typeof SourceSchemasInnerTypeEnum];

/**
 * Message model for Config Import/Export.
 * @export
 * @interface SpConfigMessage
 */
export interface SpConfigMessage {
    /**
     * Message key.
     * @type {string}
     * @memberof SpConfigMessage
     */
    'key': string;
    /**
     * Message text.
     * @type {string}
     * @memberof SpConfigMessage
     */
    'text': string;
    /**
     * Message details if any, in key:value pairs.
     * @type {{ [key: string]: any; }}
     * @memberof SpConfigMessage
     */
    'details': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface Split
 */
export interface Split {
    /**
     * This can be either a single character or a regex expression, and is used by the transform to identify the break point between two substrings in the incoming data
     * @type {string}
     * @memberof Split
     */
    'delimiter': string;
    /**
     * An integer value for the desired array element after the incoming data has been split into a list; the array is a 0-based object, so the first array element would be index 0, the second element would be index 1, etc.
     * @type {string}
     * @memberof Split
     */
    'index': string;
    /**
     * A boolean (true/false) value which indicates whether an exception should be thrown and returned as an output when an index is out of bounds with the resultant array (i.e., the provided index value is larger than the size of the array)   `true` - The transform should return \"IndexOutOfBoundsException\"   `false` - The transform should return null   If not provided, the transform will default to false and return a null 
     * @type {boolean}
     * @memberof Split
     */
    'throws'?: boolean;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Split
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Split
     */
    'input'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface Static
 */
export interface Static {
    /**
     * This must evaluate to a JSON string, either through a fixed value or through conditional logic using the Apache Velocity Template Language.
     * @type {string}
     * @memberof Static
     */
    'values': string;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Static
     */
    'requiresPeriodicRefresh'?: boolean;
}
/**
 * 
 * @export
 * @interface SubSearchAggregationSpecification
 */
export interface SubSearchAggregationSpecification {
    /**
     * 
     * @type {NestedAggregation}
     * @memberof SubSearchAggregationSpecification
     */
    'nested'?: NestedAggregation;
    /**
     * 
     * @type {MetricAggregation}
     * @memberof SubSearchAggregationSpecification
     */
    'metric'?: MetricAggregation;
    /**
     * 
     * @type {FilterAggregation}
     * @memberof SubSearchAggregationSpecification
     */
    'filter'?: FilterAggregation;
    /**
     * 
     * @type {BucketAggregation}
     * @memberof SubSearchAggregationSpecification
     */
    'bucket'?: BucketAggregation;
    /**
     * 
     * @type {Aggregations}
     * @memberof SubSearchAggregationSpecification
     */
    'subAggregation'?: Aggregations;
}
/**
 * 
 * @export
 * @interface SubSearchAggregationSpecificationAllOf
 */
export interface SubSearchAggregationSpecificationAllOf {
    /**
     * 
     * @type {Aggregations}
     * @memberof SubSearchAggregationSpecificationAllOf
     */
    'subAggregation'?: Aggregations;
}
/**
 * 
 * @export
 * @interface Substring
 */
export interface Substring {
    /**
     * The index of the first character to include in the returned substring.   If `begin` is set to -1, the transform will begin at character 0 of the input data 
     * @type {number}
     * @memberof Substring
     */
    'begin': number;
    /**
     * This integer value is the number of characters to add to the begin attribute when returning a substring.   This attribute is only used if begin is not -1. 
     * @type {number}
     * @memberof Substring
     */
    'beginOffset'?: number;
    /**
     * The index of the first character to exclude from the returned substring.  If end is -1 or not provided at all, the substring transform will return everything up to the end of the input string. 
     * @type {number}
     * @memberof Substring
     */
    'end'?: number;
    /**
     * This integer value is the number of characters to add to the end attribute when returning a substring.   This attribute is only used if end is provided and is not -1. 
     * @type {number}
     * @memberof Substring
     */
    'endOffset'?: number;
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Substring
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Substring
     */
    'input'?: { [key: string]: any; };
}
/**
 * The representation of an internally- or customer-defined transform.
 * @export
 * @interface Transform
 */
export interface Transform {
    /**
     * Unique ID of this transform
     * @type {string}
     * @memberof Transform
     */
    'id'?: string;
    /**
     * Unique name of this transform
     * @type {string}
     * @memberof Transform
     */
    'name': string;
    /**
     * The type of transform operation
     * @type {string}
     * @memberof Transform
     */
    'type': TransformTypeEnum;
    /**
     * 
     * @type {TransformAttributes}
     * @memberof Transform
     */
    'attributes': TransformAttributes;
    /**
     * Indicates whether this is an internal SailPoint-created transform or a customer-created transform
     * @type {boolean}
     * @memberof Transform
     */
    'internal'?: boolean;
}

export const TransformTypeEnum = {
    AccountAttribute: 'accountAttribute',
    Base64Decode: 'base64Decode',
    Base64Encode: 'base64Encode',
    Concat: 'concat',
    Conditional: 'conditional',
    DateCompare: 'dateCompare',
    DateFormat: 'dateFormat',
    DateMath: 'dateMath',
    DecomposeDiacriticalMarks: 'decomposeDiacriticalMarks',
    E164phone: 'e164phone',
    FirstValid: 'firstValid',
    Rule: 'rule',
    IdentityAttribute: 'identityAttribute',
    IndexOf: 'indexOf',
    Iso3166: 'iso3166',
    LastIndexOf: 'lastIndexOf',
    LeftPad: 'leftPad',
    Lookup: 'lookup',
    Lower: 'lower',
    NormalizeNames: 'normalizeNames',
    RandomAlphaNumeric: 'randomAlphaNumeric',
    RandomNumeric: 'randomNumeric',
    Reference: 'reference',
    ReplaceAll: 'replaceAll',
    Replace: 'replace',
    RightPad: 'rightPad',
    Split: 'split',
    Static: 'static',
    Substring: 'substring',
    Trim: 'trim',
    Upper: 'upper',
    UsernameGenerator: 'usernameGenerator',
    Uuid: 'uuid'
} as const;

export type TransformTypeEnum = typeof TransformTypeEnum[keyof typeof TransformTypeEnum];

/**
 * @type TransformAttributes
 * Meta-data about the transform. Values in this list are specific to the type of transform to be executed.
 * @export
 */
export type TransformAttributes = AccountAttribute | Base64Decode | Base64Encode | Concatenation | Conditional | DateCompare | DateFormat | DateMath | DecomposeDiacriticalMarks | E164phone | FirstValid | ISO3166 | IdentityAttribute | IndexOf | LeftPad | Lookup | Lower | NameNormalizer | RandomAlphaNumeric | RandomNumeric | Reference | Replace | ReplaceAll | RightPad | Rule | Split | Static | Substring | Trim | UUIDGenerator | Upper;

/**
 * 
 * @export
 * @interface TransformDefinition
 */
export interface TransformDefinition {
    /**
     * The type of the transform definition.
     * @type {string}
     * @memberof TransformDefinition
     */
    'type'?: string;
    /**
     * Arbitrary key-value pairs to store any metadata for the object
     * @type {{ [key: string]: TransformDefinitionAttributesValue; }}
     * @memberof TransformDefinition
     */
    'attributes'?: { [key: string]: TransformDefinitionAttributesValue; };
}
/**
 * 
 * @export
 * @interface TransformDefinitionAttributesValue
 */
export interface TransformDefinitionAttributesValue {
}
/**
 * 
 * @export
 * @interface Trim
 */
export interface Trim {
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Trim
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Trim
     */
    'input'?: { [key: string]: any; };
}
/**
 * Query parameters used to construct an Elasticsearch type ahead query object.  The typeAheadQuery performs a search for top values beginning with the typed values. For example, typing \"Jo\" results in top hits matching \"Jo.\" Typing \"Job\" results in top hits matching \"Job.\" 
 * @export
 * @interface TypeAheadQuery
 */
export interface TypeAheadQuery {
    /**
     * The type ahead query string used to construct a phrase prefix match query.
     * @type {string}
     * @memberof TypeAheadQuery
     */
    'query': string;
    /**
     * The field on which to perform the type ahead search.
     * @type {string}
     * @memberof TypeAheadQuery
     */
    'field': string;
    /**
     * The nested type.
     * @type {string}
     * @memberof TypeAheadQuery
     */
    'nestedType'?: string;
    /**
     * The number of suffixes the last term will be expanded into. Influences the performance of the query and the number results returned. Valid values: 1 to 1000.
     * @type {number}
     * @memberof TypeAheadQuery
     */
    'maxExpansions'?: number;
}
/**
 * A typed reference to the object. 
 * @export
 * @interface TypedReference
 */
export interface TypedReference {
    /**
     * 
     * @type {DtoType}
     * @memberof TypedReference
     */
    'type': DtoType;
    /**
     * The id of the object. 
     * @type {string}
     * @memberof TypedReference
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface UUIDGenerator
 */
export interface UUIDGenerator {
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof UUIDGenerator
     */
    'requiresPeriodicRefresh'?: boolean;
}
/**
 * 
 * @export
 * @interface UploadSourceAccountsSchemaRequest
 */
export interface UploadSourceAccountsSchemaRequest {
    /**
     * 
     * @type {any}
     * @memberof UploadSourceAccountsSchemaRequest
     */
    'file'?: any;
}
/**
 * 
 * @export
 * @interface Upper
 */
export interface Upper {
    /**
     * A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process
     * @type {boolean}
     * @memberof Upper
     */
    'requiresPeriodicRefresh'?: boolean;
    /**
     * This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.
     * @type {{ [key: string]: any; }}
     * @memberof Upper
     */
    'input'?: { [key: string]: any; };
}
/**
 * The type of ProvisioningPolicy usage.
 * @export
 * @enum {string}
 */

export const UsageType = {
    Create: 'CREATE',
    Update: 'UPDATE',
    Delete: 'DELETE',
    Assign: 'ASSIGN',
    Unassign: 'UNASSIGN',
    CreateGroup: 'CREATE_GROUP',
    UpdateGroup: 'UPDATE_GROUP',
    DeleteGroup: 'DELETE_GROUP',
    Register: 'REGISTER',
    CreateIdentity: 'CREATE_IDENTITY',
    UpdateIdentity: 'UPDATE_IDENTITY',
    EditGroup: 'EDIT_GROUP',
    Enable: 'ENABLE',
    Disable: 'DISABLE',
    Unlock: 'UNLOCK',
    ChangePassword: 'CHANGE_PASSWORD'
} as const;

export type UsageType = typeof UsageType[keyof typeof UsageType];


/**
 * The state of a work item
 * @export
 * @enum {string}
 */

export const WorkItemState = {
    Finished: 'FINISHED',
    Rejected: 'REJECTED',
    Returned: 'RETURNED',
    Expired: 'EXPIRED',
    Pending: 'PENDING',
    Canceled: 'CANCELED'
} as const;

export type WorkItemState = typeof WorkItemState[keyof typeof WorkItemState];


/**
 * The type of the work item
 * @export
 * @enum {string}
 */

export const WorkItemType = {
    Unknown: 'UNKNOWN',
    Generic: 'GENERIC',
    Certification: 'CERTIFICATION',
    Remediation: 'REMEDIATION',
    Delegation: 'DELEGATION',
    Approval: 'APPROVAL',
    Violationreview: 'VIOLATIONREVIEW',
    Form: 'FORM',
    Policyviolation: 'POLICYVIOLATION',
    Challenge: 'CHALLENGE',
    Impactanalysis: 'IMPACTANALYSIS',
    Signoff: 'SIGNOFF',
    Event: 'EVENT',
    Manualaction: 'MANUALACTION',
    Test: 'TEST'
} as const;

export type WorkItemType = typeof WorkItemType[keyof typeof WorkItemType];


/**
 * 
 * @export
 * @interface WorkItems
 */
export interface WorkItems {
    /**
     * ID of the work item
     * @type {string}
     * @memberof WorkItems
     */
    'id'?: string;
    /**
     * ID of the requester
     * @type {string}
     * @memberof WorkItems
     */
    'requesterId'?: string;
    /**
     * The displayname of the requester
     * @type {string}
     * @memberof WorkItems
     */
    'requesterDisplayName'?: string;
    /**
     * The ID of the owner
     * @type {string}
     * @memberof WorkItems
     */
    'ownerId'?: string;
    /**
     * The name of the owner
     * @type {string}
     * @memberof WorkItems
     */
    'ownerName'?: string;
    /**
     * Time when the work item was created
     * @type {string}
     * @memberof WorkItems
     */
    'created'?: string;
    /**
     * Time when the work item was last updated
     * @type {string}
     * @memberof WorkItems
     */
    'modified'?: string;
    /**
     * The description of the work item
     * @type {string}
     * @memberof WorkItems
     */
    'description'?: string;
    /**
     * 
     * @type {WorkItemState}
     * @memberof WorkItems
     */
    'state'?: WorkItemState;
    /**
     * 
     * @type {WorkItemType}
     * @memberof WorkItems
     */
    'type'?: WorkItemType;
    /**
     * 
     * @type {RemediationItemDetails}
     * @memberof WorkItems
     */
    'remediationItems'?: RemediationItemDetails;
    /**
     * 
     * @type {ApprovalItemDetails}
     * @memberof WorkItems
     */
    'approvalItems'?: ApprovalItemDetails;
    /**
     * The work item name
     * @type {string}
     * @memberof WorkItems
     */
    'name'?: string;
    /**
     * The time at which the work item completed
     * @type {string}
     * @memberof WorkItems
     */
    'completed'?: string;
    /**
     * The number of items in the work item
     * @type {number}
     * @memberof WorkItems
     */
    'numItems'?: number;
    /**
     * 
     * @type {FormDetails}
     * @memberof WorkItems
     */
    'form'?: FormDetails;
    /**
     * An array of errors that ocurred during the work item
     * @type {Array<string>}
     * @memberof WorkItems
     */
    'errors'?: Array<string>;
}
/**
 * 
 * @export
 * @interface WorkItemsCount
 */
export interface WorkItemsCount {
    /**
     * The count of work items
     * @type {number}
     * @memberof WorkItemsCount
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface WorkItemsSummary
 */
export interface WorkItemsSummary {
    /**
     * The count of open work items
     * @type {number}
     * @memberof WorkItemsSummary
     */
    'open'?: number;
    /**
     * The count of completed work items
     * @type {number}
     * @memberof WorkItemsSummary
     */
    'completed'?: number;
    /**
     * The count of total work items
     * @type {number}
     * @memberof WorkItemsSummary
     */
    'total'?: number;
}

/**
 * AccessRequestApprovalsApi - axios parameter creator
 * @export
 */
export const AccessRequestApprovalsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint returns the number of pending, approved and rejected access requests approvals. See \"owner-id\" query parameter below for authorization info.
         * @summary Get the number of access-requests-approvals
         * @param {string} [ownerId] The id of the owner or approver identity of the approvals. If present, the value returns approval summary for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN user can also fetch all the approvals in the org, when owner-id is not used.    * Non ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {string} [fromDate] From date is the date and time from which the results will be shown. It should be in a valid ISO-8601 format
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approvalSummary: async (ownerId?: string, fromDate?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/access-request-approvals/approval-summary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['owner-id'] = ownerId;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from-date'] = fromDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint approves an access request approval. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
         * @summary Approves an access request approval.
         * @param {string} approvalId The id of the approval.
         * @param {CommentDto} [commentDto] Reviewer\&#39;s comment.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approveRequest: async (approvalId: string, commentDto?: CommentDto, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'approvalId' is not null or undefined
            assertParamExists('approveRequest', 'approvalId', approvalId)
            const localVarPath = `/access-request-approvals/{approvalId}/approve`
                .replace(`{${"approvalId"}}`, encodeURIComponent(String(approvalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(commentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint forwards an access request approval to a new owner. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
         * @summary Forwards an access request approval.
         * @param {string} approvalId The id of the approval.
         * @param {ForwardApprovalDto} forwardApprovalDto Information about the forwarded approval.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        forwardRequest: async (approvalId: string, forwardApprovalDto: ForwardApprovalDto, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'approvalId' is not null or undefined
            assertParamExists('forwardRequest', 'approvalId', approvalId)
            // verify required parameter 'forwardApprovalDto' is not null or undefined
            assertParamExists('forwardRequest', 'forwardApprovalDto', forwardApprovalDto)
            const localVarPath = `/access-request-approvals/{approvalId}/forward`
                .replace(`{${"approvalId"}}`, encodeURIComponent(String(approvalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(forwardApprovalDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns list of completed approvals. See *owner-id* query parameter below for authorization info.
         * @summary Completed Access Request Approvals List
         * @param {string} [ownerId] If present, the value returns only completed approvals for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN users can also fetch all the approvals in the org, when owner-id is not used.    * Non-ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **requestedFor.id**: *eq, in*  **modified**: *gt, lt, ge, le*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listCompletedApprovals: async (ownerId?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/access-request-approvals/completed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['owner-id'] = ownerId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a list of pending approvals. See \"owner-id\" query parameter below for authorization info.
         * @summary Pending Access Request Approvals List
         * @param {string} [ownerId] If present, the value returns only pending approvals for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN users can also fetch all the approvals in the org, when owner-id is not used.    * Non-ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **requestedFor.id**: *eq, in*  **modified**: *gt, lt, ge, le*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listPendingApprovals: async (ownerId?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/access-request-approvals/pending`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['owner-id'] = ownerId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint rejects an access request approval. Only the owner of the approval and admin users are allowed to perform this action.
         * @summary Rejects an access request approval.
         * @param {string} approvalId The id of the approval.
         * @param {CommentDto} [commentDto] Reviewer\&#39;s comment.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        rejectRequest: async (approvalId: string, commentDto?: CommentDto, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'approvalId' is not null or undefined
            assertParamExists('rejectRequest', 'approvalId', approvalId)
            const localVarPath = `/access-request-approvals/{approvalId}/reject`
                .replace(`{${"approvalId"}}`, encodeURIComponent(String(approvalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(commentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccessRequestApprovalsApi - functional programming interface
 * @export
 */
export const AccessRequestApprovalsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccessRequestApprovalsApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint returns the number of pending, approved and rejected access requests approvals. See \"owner-id\" query parameter below for authorization info.
         * @summary Get the number of access-requests-approvals
         * @param {string} [ownerId] The id of the owner or approver identity of the approvals. If present, the value returns approval summary for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN user can also fetch all the approvals in the org, when owner-id is not used.    * Non ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {string} [fromDate] From date is the date and time from which the results will be shown. It should be in a valid ISO-8601 format
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async approvalSummary(ownerId?: string, fromDate?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApprovalSummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approvalSummary(ownerId, fromDate, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint approves an access request approval. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
         * @summary Approves an access request approval.
         * @param {string} approvalId The id of the approval.
         * @param {CommentDto} [commentDto] Reviewer\&#39;s comment.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async approveRequest(approvalId: string, commentDto?: CommentDto, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveRequest(approvalId, commentDto, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint forwards an access request approval to a new owner. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
         * @summary Forwards an access request approval.
         * @param {string} approvalId The id of the approval.
         * @param {ForwardApprovalDto} forwardApprovalDto Information about the forwarded approval.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async forwardRequest(approvalId: string, forwardApprovalDto: ForwardApprovalDto, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forwardRequest(approvalId, forwardApprovalDto, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns list of completed approvals. See *owner-id* query parameter below for authorization info.
         * @summary Completed Access Request Approvals List
         * @param {string} [ownerId] If present, the value returns only completed approvals for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN users can also fetch all the approvals in the org, when owner-id is not used.    * Non-ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **requestedFor.id**: *eq, in*  **modified**: *gt, lt, ge, le*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listCompletedApprovals(ownerId?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CompletedApproval>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCompletedApprovals(ownerId, limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns a list of pending approvals. See \"owner-id\" query parameter below for authorization info.
         * @summary Pending Access Request Approvals List
         * @param {string} [ownerId] If present, the value returns only pending approvals for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN users can also fetch all the approvals in the org, when owner-id is not used.    * Non-ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **requestedFor.id**: *eq, in*  **modified**: *gt, lt, ge, le*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listPendingApprovals(ownerId?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PendingApproval>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPendingApprovals(ownerId, limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint rejects an access request approval. Only the owner of the approval and admin users are allowed to perform this action.
         * @summary Rejects an access request approval.
         * @param {string} approvalId The id of the approval.
         * @param {CommentDto} [commentDto] Reviewer\&#39;s comment.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async rejectRequest(approvalId: string, commentDto?: CommentDto, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejectRequest(approvalId, commentDto, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccessRequestApprovalsApi - factory interface
 * @export
 */
export const AccessRequestApprovalsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccessRequestApprovalsApiFp(configuration)
    return {
        /**
         * This endpoint returns the number of pending, approved and rejected access requests approvals. See \"owner-id\" query parameter below for authorization info.
         * @summary Get the number of access-requests-approvals
         * @param {string} [ownerId] The id of the owner or approver identity of the approvals. If present, the value returns approval summary for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN user can also fetch all the approvals in the org, when owner-id is not used.    * Non ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {string} [fromDate] From date is the date and time from which the results will be shown. It should be in a valid ISO-8601 format
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approvalSummary(ownerId?: string, fromDate?: string, axiosOptions?: any): AxiosPromise<ApprovalSummary> {
            return localVarFp.approvalSummary(ownerId, fromDate, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint approves an access request approval. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
         * @summary Approves an access request approval.
         * @param {string} approvalId The id of the approval.
         * @param {CommentDto} [commentDto] Reviewer\&#39;s comment.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approveRequest(approvalId: string, commentDto?: CommentDto, axiosOptions?: any): AxiosPromise<object> {
            return localVarFp.approveRequest(approvalId, commentDto, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint forwards an access request approval to a new owner. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
         * @summary Forwards an access request approval.
         * @param {string} approvalId The id of the approval.
         * @param {ForwardApprovalDto} forwardApprovalDto Information about the forwarded approval.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        forwardRequest(approvalId: string, forwardApprovalDto: ForwardApprovalDto, axiosOptions?: any): AxiosPromise<object> {
            return localVarFp.forwardRequest(approvalId, forwardApprovalDto, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns list of completed approvals. See *owner-id* query parameter below for authorization info.
         * @summary Completed Access Request Approvals List
         * @param {string} [ownerId] If present, the value returns only completed approvals for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN users can also fetch all the approvals in the org, when owner-id is not used.    * Non-ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **requestedFor.id**: *eq, in*  **modified**: *gt, lt, ge, le*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listCompletedApprovals(ownerId?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<CompletedApproval>> {
            return localVarFp.listCompletedApprovals(ownerId, limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a list of pending approvals. See \"owner-id\" query parameter below for authorization info.
         * @summary Pending Access Request Approvals List
         * @param {string} [ownerId] If present, the value returns only pending approvals for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN users can also fetch all the approvals in the org, when owner-id is not used.    * Non-ORG_ADMIN users can only specify *me* or pass their own identity ID value.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **requestedFor.id**: *eq, in*  **modified**: *gt, lt, ge, le*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listPendingApprovals(ownerId?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<PendingApproval>> {
            return localVarFp.listPendingApprovals(ownerId, limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint rejects an access request approval. Only the owner of the approval and admin users are allowed to perform this action.
         * @summary Rejects an access request approval.
         * @param {string} approvalId The id of the approval.
         * @param {CommentDto} [commentDto] Reviewer\&#39;s comment.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        rejectRequest(approvalId: string, commentDto?: CommentDto, axiosOptions?: any): AxiosPromise<object> {
            return localVarFp.rejectRequest(approvalId, commentDto, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for approvalSummary operation in AccessRequestApprovalsApi.
 * @export
 * @interface AccessRequestApprovalsApiApprovalSummaryRequest
 */
export interface AccessRequestApprovalsApiApprovalSummaryRequest {
    /**
     * The id of the owner or approver identity of the approvals. If present, the value returns approval summary for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN user can also fetch all the approvals in the org, when owner-id is not used.    * Non ORG_ADMIN users can only specify *me* or pass their own identity ID value.
     * @type {string}
     * @memberof AccessRequestApprovalsApiApprovalSummary
     */
    readonly ownerId?: string

    /**
     * From date is the date and time from which the results will be shown. It should be in a valid ISO-8601 format
     * @type {string}
     * @memberof AccessRequestApprovalsApiApprovalSummary
     */
    readonly fromDate?: string
}

/**
 * Request parameters for approveRequest operation in AccessRequestApprovalsApi.
 * @export
 * @interface AccessRequestApprovalsApiApproveRequestRequest
 */
export interface AccessRequestApprovalsApiApproveRequestRequest {
    /**
     * The id of the approval.
     * @type {string}
     * @memberof AccessRequestApprovalsApiApproveRequest
     */
    readonly approvalId: string

    /**
     * Reviewer\&#39;s comment.
     * @type {CommentDto}
     * @memberof AccessRequestApprovalsApiApproveRequest
     */
    readonly commentDto?: CommentDto
}

/**
 * Request parameters for forwardRequest operation in AccessRequestApprovalsApi.
 * @export
 * @interface AccessRequestApprovalsApiForwardRequestRequest
 */
export interface AccessRequestApprovalsApiForwardRequestRequest {
    /**
     * The id of the approval.
     * @type {string}
     * @memberof AccessRequestApprovalsApiForwardRequest
     */
    readonly approvalId: string

    /**
     * Information about the forwarded approval.
     * @type {ForwardApprovalDto}
     * @memberof AccessRequestApprovalsApiForwardRequest
     */
    readonly forwardApprovalDto: ForwardApprovalDto
}

/**
 * Request parameters for listCompletedApprovals operation in AccessRequestApprovalsApi.
 * @export
 * @interface AccessRequestApprovalsApiListCompletedApprovalsRequest
 */
export interface AccessRequestApprovalsApiListCompletedApprovalsRequest {
    /**
     * If present, the value returns only completed approvals for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN users can also fetch all the approvals in the org, when owner-id is not used.    * Non-ORG_ADMIN users can only specify *me* or pass their own identity ID value.
     * @type {string}
     * @memberof AccessRequestApprovalsApiListCompletedApprovals
     */
    readonly ownerId?: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccessRequestApprovalsApiListCompletedApprovals
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccessRequestApprovalsApiListCompletedApprovals
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof AccessRequestApprovalsApiListCompletedApprovals
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **requestedFor.id**: *eq, in*  **modified**: *gt, lt, ge, le*
     * @type {string}
     * @memberof AccessRequestApprovalsApiListCompletedApprovals
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
     * @type {string}
     * @memberof AccessRequestApprovalsApiListCompletedApprovals
     */
    readonly sorters?: string
}

/**
 * Request parameters for listPendingApprovals operation in AccessRequestApprovalsApi.
 * @export
 * @interface AccessRequestApprovalsApiListPendingApprovalsRequest
 */
export interface AccessRequestApprovalsApiListPendingApprovalsRequest {
    /**
     * If present, the value returns only pending approvals for the specified identity.    * ORG_ADMIN users can call this with any identity ID value.    * ORG_ADMIN users can also fetch all the approvals in the org, when owner-id is not used.    * Non-ORG_ADMIN users can only specify *me* or pass their own identity ID value.
     * @type {string}
     * @memberof AccessRequestApprovalsApiListPendingApprovals
     */
    readonly ownerId?: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccessRequestApprovalsApiListPendingApprovals
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccessRequestApprovalsApiListPendingApprovals
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof AccessRequestApprovalsApiListPendingApprovals
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **requestedFor.id**: *eq, in*  **modified**: *gt, lt, ge, le*
     * @type {string}
     * @memberof AccessRequestApprovalsApiListPendingApprovals
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
     * @type {string}
     * @memberof AccessRequestApprovalsApiListPendingApprovals
     */
    readonly sorters?: string
}

/**
 * Request parameters for rejectRequest operation in AccessRequestApprovalsApi.
 * @export
 * @interface AccessRequestApprovalsApiRejectRequestRequest
 */
export interface AccessRequestApprovalsApiRejectRequestRequest {
    /**
     * The id of the approval.
     * @type {string}
     * @memberof AccessRequestApprovalsApiRejectRequest
     */
    readonly approvalId: string

    /**
     * Reviewer\&#39;s comment.
     * @type {CommentDto}
     * @memberof AccessRequestApprovalsApiRejectRequest
     */
    readonly commentDto?: CommentDto
}

/**
 * AccessRequestApprovalsApi - object-oriented interface
 * @export
 * @class AccessRequestApprovalsApi
 * @extends {BaseAPI}
 */
export class AccessRequestApprovalsApi extends BaseAPI {
    /**
     * This endpoint returns the number of pending, approved and rejected access requests approvals. See \"owner-id\" query parameter below for authorization info.
     * @summary Get the number of access-requests-approvals
     * @param {AccessRequestApprovalsApiApprovalSummaryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestApprovalsApi
     */
    public approvalSummary(requestParameters: AccessRequestApprovalsApiApprovalSummaryRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return AccessRequestApprovalsApiFp(this.configuration).approvalSummary(requestParameters.ownerId, requestParameters.fromDate, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint approves an access request approval. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
     * @summary Approves an access request approval.
     * @param {AccessRequestApprovalsApiApproveRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestApprovalsApi
     */
    public approveRequest(requestParameters: AccessRequestApprovalsApiApproveRequestRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessRequestApprovalsApiFp(this.configuration).approveRequest(requestParameters.approvalId, requestParameters.commentDto, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint forwards an access request approval to a new owner. Only the owner of the approval and ORG_ADMIN users are allowed to perform this action.
     * @summary Forwards an access request approval.
     * @param {AccessRequestApprovalsApiForwardRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestApprovalsApi
     */
    public forwardRequest(requestParameters: AccessRequestApprovalsApiForwardRequestRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessRequestApprovalsApiFp(this.configuration).forwardRequest(requestParameters.approvalId, requestParameters.forwardApprovalDto, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns list of completed approvals. See *owner-id* query parameter below for authorization info.
     * @summary Completed Access Request Approvals List
     * @param {AccessRequestApprovalsApiListCompletedApprovalsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestApprovalsApi
     */
    public listCompletedApprovals(requestParameters: AccessRequestApprovalsApiListCompletedApprovalsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return AccessRequestApprovalsApiFp(this.configuration).listCompletedApprovals(requestParameters.ownerId, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a list of pending approvals. See \"owner-id\" query parameter below for authorization info.
     * @summary Pending Access Request Approvals List
     * @param {AccessRequestApprovalsApiListPendingApprovalsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestApprovalsApi
     */
    public listPendingApprovals(requestParameters: AccessRequestApprovalsApiListPendingApprovalsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return AccessRequestApprovalsApiFp(this.configuration).listPendingApprovals(requestParameters.ownerId, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint rejects an access request approval. Only the owner of the approval and admin users are allowed to perform this action.
     * @summary Rejects an access request approval.
     * @param {AccessRequestApprovalsApiRejectRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestApprovalsApi
     */
    public rejectRequest(requestParameters: AccessRequestApprovalsApiRejectRequestRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessRequestApprovalsApiFp(this.configuration).rejectRequest(requestParameters.approvalId, requestParameters.commentDto, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AccessRequestsApi - axios parameter creator
 * @export
 */
export const AccessRequestsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API endpoint cancels a pending access request. An access request can be cancelled only if it has not passed the approval step. Any token with ORG_ADMIN authority or token of the user who originally requested the access request is required to cancel it.
         * @summary Cancel Access Request
         * @param {CancelAccessRequest} cancelAccessRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        cancelAccessRequest: async (cancelAccessRequest: CancelAccessRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cancelAccessRequest' is not null or undefined
            assertParamExists('cancelAccessRequest', 'cancelAccessRequest', cancelAccessRequest)
            const localVarPath = `/access-requests/cancel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cancelAccessRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This submits the access request into IdentityNow, where it will follow any IdentityNow approval processes.  Access requests are processed asynchronously by IdentityNow.  A success response from this endpoint means the request has been submitted to IDN and is queued for processing.  Because this endpoint is asynchronous, it will not return an error if you submit duplicate access requests in quick succession, or you submit an access request for access that is already in progress, approved, or rejected. It is best practice to check for any existing access requests that reference the same access items before submitting a new access request.  This can be accomplished by using the [access request status](https://developer.sailpoint.com/idn/api/v3/list-access-request-status) or the [pending access request approvals](https://developer.sailpoint.com/idn/api/v3/list-pending-approvals) endpoints.  You can also use the [search API](https://developer.sailpoint.com/idn/api/v3/search) to check the existing access items that an identity has before submitting an access request to ensure you are not requesting access that is already granted.  There are two types of access request:  __GRANT_ACCESS__ * Can be requested for multiple identities in a single request. * Supports self request and request on behalf of other users, see \'/beta/access-request-config\' endpoint for request configuration options.   * Allows any authenticated token (except API) to call this endpoint to request to grant access to themselves. Depending on the configuration, a user can request access for others. * Roles, Access Profiles and Entitlements can be requested. * While requesting entitlements, maximum of 25 entitlements and 10 recipients are allowed in a request.   __REVOKE_ACCESS__ * Can only be requested for a single identity at a time. * Does not support self request. Only manager can request to revoke access for their directly managed employees. * If removeDate is specified, then the access will be removed on that date and time. * Allows a manager to request to revoke access for direct employees. A token with ORG_ADMIN authority can also request to revoke access from anyone. * Roles and Access Profiles can be requested for revocation. Revoke request for entitlements are not supported currently.  NOTE: There is no indication to the approver in the IdentityNow UI that the approval request is for a revoke action. Take this into consideration when calling this API.  A token with API authority cannot be used to call this endpoint.  
         * @summary Submit an Access Request
         * @param {AccessRequest} accessRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createAccessRequest: async (accessRequest: AccessRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessRequest' is not null or undefined
            assertParamExists('createAccessRequest', 'accessRequest', accessRequest)
            const localVarPath = `/access-requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accessRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns the current access-request configuration.
         * @summary Get Access Request Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessRequestConfig: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/access-request-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * The Access Request Status API returns a list of access request statuses based on the specified query parameters. Any token with any authority can request their own status. A token with ORG_ADMIN authority is required to call this API to get a list of statuses for other users.
         * @summary Access Request Status
         * @param {string} [requestedFor] Filter the results by the identity for which the requests were made. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [requestedBy] Filter the results by the identity that made the requests. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [regardingIdentity] Filter the results by the specified identity which is either the requester or target of the requests. *me* indicates the current user. Mutually exclusive with *requested-for* and *requested-by*.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.
         * @param {number} [limit] Max number of results to return.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. Defaults to 0 if not specified.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **accountActivityItemId**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified, accountActivityItemId**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccessRequestStatus: async (requestedFor?: string, requestedBy?: string, regardingIdentity?: string, count?: boolean, limit?: number, offset?: number, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/access-request-status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (requestedFor !== undefined) {
                localVarQueryParameter['requested-for'] = requestedFor;
            }

            if (requestedBy !== undefined) {
                localVarQueryParameter['requested-by'] = requestedBy;
            }

            if (regardingIdentity !== undefined) {
                localVarQueryParameter['regarding-identity'] = regardingIdentity;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint replaces the current access-request configuration. A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Access Request Configuration
         * @param {AccessRequestConfig} accessRequestConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateAccessRequestConfig: async (accessRequestConfig: AccessRequestConfig, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessRequestConfig' is not null or undefined
            assertParamExists('updateAccessRequestConfig', 'accessRequestConfig', accessRequestConfig)
            const localVarPath = `/access-request-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accessRequestConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccessRequestsApi - functional programming interface
 * @export
 */
export const AccessRequestsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccessRequestsApiAxiosParamCreator(configuration)
    return {
        /**
         * This API endpoint cancels a pending access request. An access request can be cancelled only if it has not passed the approval step. Any token with ORG_ADMIN authority or token of the user who originally requested the access request is required to cancel it.
         * @summary Cancel Access Request
         * @param {CancelAccessRequest} cancelAccessRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async cancelAccessRequest(cancelAccessRequest: CancelAccessRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelAccessRequest(cancelAccessRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This submits the access request into IdentityNow, where it will follow any IdentityNow approval processes.  Access requests are processed asynchronously by IdentityNow.  A success response from this endpoint means the request has been submitted to IDN and is queued for processing.  Because this endpoint is asynchronous, it will not return an error if you submit duplicate access requests in quick succession, or you submit an access request for access that is already in progress, approved, or rejected. It is best practice to check for any existing access requests that reference the same access items before submitting a new access request.  This can be accomplished by using the [access request status](https://developer.sailpoint.com/idn/api/v3/list-access-request-status) or the [pending access request approvals](https://developer.sailpoint.com/idn/api/v3/list-pending-approvals) endpoints.  You can also use the [search API](https://developer.sailpoint.com/idn/api/v3/search) to check the existing access items that an identity has before submitting an access request to ensure you are not requesting access that is already granted.  There are two types of access request:  __GRANT_ACCESS__ * Can be requested for multiple identities in a single request. * Supports self request and request on behalf of other users, see \'/beta/access-request-config\' endpoint for request configuration options.   * Allows any authenticated token (except API) to call this endpoint to request to grant access to themselves. Depending on the configuration, a user can request access for others. * Roles, Access Profiles and Entitlements can be requested. * While requesting entitlements, maximum of 25 entitlements and 10 recipients are allowed in a request.   __REVOKE_ACCESS__ * Can only be requested for a single identity at a time. * Does not support self request. Only manager can request to revoke access for their directly managed employees. * If removeDate is specified, then the access will be removed on that date and time. * Allows a manager to request to revoke access for direct employees. A token with ORG_ADMIN authority can also request to revoke access from anyone. * Roles and Access Profiles can be requested for revocation. Revoke request for entitlements are not supported currently.  NOTE: There is no indication to the approver in the IdentityNow UI that the approval request is for a revoke action. Take this into consideration when calling this API.  A token with API authority cannot be used to call this endpoint.  
         * @summary Submit an Access Request
         * @param {AccessRequest} accessRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createAccessRequest(accessRequest: AccessRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccessRequest(accessRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns the current access-request configuration.
         * @summary Get Access Request Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAccessRequestConfig(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessRequestConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccessRequestConfig(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The Access Request Status API returns a list of access request statuses based on the specified query parameters. Any token with any authority can request their own status. A token with ORG_ADMIN authority is required to call this API to get a list of statuses for other users.
         * @summary Access Request Status
         * @param {string} [requestedFor] Filter the results by the identity for which the requests were made. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [requestedBy] Filter the results by the identity that made the requests. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [regardingIdentity] Filter the results by the specified identity which is either the requester or target of the requests. *me* indicates the current user. Mutually exclusive with *requested-for* and *requested-by*.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.
         * @param {number} [limit] Max number of results to return.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. Defaults to 0 if not specified.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **accountActivityItemId**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified, accountActivityItemId**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listAccessRequestStatus(requestedFor?: string, requestedBy?: string, regardingIdentity?: string, count?: boolean, limit?: number, offset?: number, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RequestedItemStatus>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccessRequestStatus(requestedFor, requestedBy, regardingIdentity, count, limit, offset, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint replaces the current access-request configuration. A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Access Request Configuration
         * @param {AccessRequestConfig} accessRequestConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateAccessRequestConfig(accessRequestConfig: AccessRequestConfig, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessRequestConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAccessRequestConfig(accessRequestConfig, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccessRequestsApi - factory interface
 * @export
 */
export const AccessRequestsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccessRequestsApiFp(configuration)
    return {
        /**
         * This API endpoint cancels a pending access request. An access request can be cancelled only if it has not passed the approval step. Any token with ORG_ADMIN authority or token of the user who originally requested the access request is required to cancel it.
         * @summary Cancel Access Request
         * @param {CancelAccessRequest} cancelAccessRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        cancelAccessRequest(cancelAccessRequest: CancelAccessRequest, axiosOptions?: any): AxiosPromise<object> {
            return localVarFp.cancelAccessRequest(cancelAccessRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This submits the access request into IdentityNow, where it will follow any IdentityNow approval processes.  Access requests are processed asynchronously by IdentityNow.  A success response from this endpoint means the request has been submitted to IDN and is queued for processing.  Because this endpoint is asynchronous, it will not return an error if you submit duplicate access requests in quick succession, or you submit an access request for access that is already in progress, approved, or rejected. It is best practice to check for any existing access requests that reference the same access items before submitting a new access request.  This can be accomplished by using the [access request status](https://developer.sailpoint.com/idn/api/v3/list-access-request-status) or the [pending access request approvals](https://developer.sailpoint.com/idn/api/v3/list-pending-approvals) endpoints.  You can also use the [search API](https://developer.sailpoint.com/idn/api/v3/search) to check the existing access items that an identity has before submitting an access request to ensure you are not requesting access that is already granted.  There are two types of access request:  __GRANT_ACCESS__ * Can be requested for multiple identities in a single request. * Supports self request and request on behalf of other users, see \'/beta/access-request-config\' endpoint for request configuration options.   * Allows any authenticated token (except API) to call this endpoint to request to grant access to themselves. Depending on the configuration, a user can request access for others. * Roles, Access Profiles and Entitlements can be requested. * While requesting entitlements, maximum of 25 entitlements and 10 recipients are allowed in a request.   __REVOKE_ACCESS__ * Can only be requested for a single identity at a time. * Does not support self request. Only manager can request to revoke access for their directly managed employees. * If removeDate is specified, then the access will be removed on that date and time. * Allows a manager to request to revoke access for direct employees. A token with ORG_ADMIN authority can also request to revoke access from anyone. * Roles and Access Profiles can be requested for revocation. Revoke request for entitlements are not supported currently.  NOTE: There is no indication to the approver in the IdentityNow UI that the approval request is for a revoke action. Take this into consideration when calling this API.  A token with API authority cannot be used to call this endpoint.  
         * @summary Submit an Access Request
         * @param {AccessRequest} accessRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createAccessRequest(accessRequest: AccessRequest, axiosOptions?: any): AxiosPromise<object> {
            return localVarFp.createAccessRequest(accessRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns the current access-request configuration.
         * @summary Get Access Request Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccessRequestConfig(axiosOptions?: any): AxiosPromise<AccessRequestConfig> {
            return localVarFp.getAccessRequestConfig(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * The Access Request Status API returns a list of access request statuses based on the specified query parameters. Any token with any authority can request their own status. A token with ORG_ADMIN authority is required to call this API to get a list of statuses for other users.
         * @summary Access Request Status
         * @param {string} [requestedFor] Filter the results by the identity for which the requests were made. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [requestedBy] Filter the results by the identity that made the requests. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [regardingIdentity] Filter the results by the specified identity which is either the requester or target of the requests. *me* indicates the current user. Mutually exclusive with *requested-for* and *requested-by*.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.
         * @param {number} [limit] Max number of results to return.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. Defaults to 0 if not specified.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **accountActivityItemId**: *eq, in*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified, accountActivityItemId**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccessRequestStatus(requestedFor?: string, requestedBy?: string, regardingIdentity?: string, count?: boolean, limit?: number, offset?: number, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<RequestedItemStatus>> {
            return localVarFp.listAccessRequestStatus(requestedFor, requestedBy, regardingIdentity, count, limit, offset, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint replaces the current access-request configuration. A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Access Request Configuration
         * @param {AccessRequestConfig} accessRequestConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateAccessRequestConfig(accessRequestConfig: AccessRequestConfig, axiosOptions?: any): AxiosPromise<AccessRequestConfig> {
            return localVarFp.updateAccessRequestConfig(accessRequestConfig, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cancelAccessRequest operation in AccessRequestsApi.
 * @export
 * @interface AccessRequestsApiCancelAccessRequestRequest
 */
export interface AccessRequestsApiCancelAccessRequestRequest {
    /**
     * 
     * @type {CancelAccessRequest}
     * @memberof AccessRequestsApiCancelAccessRequest
     */
    readonly cancelAccessRequest: CancelAccessRequest
}

/**
 * Request parameters for createAccessRequest operation in AccessRequestsApi.
 * @export
 * @interface AccessRequestsApiCreateAccessRequestRequest
 */
export interface AccessRequestsApiCreateAccessRequestRequest {
    /**
     * 
     * @type {AccessRequest}
     * @memberof AccessRequestsApiCreateAccessRequest
     */
    readonly accessRequest: AccessRequest
}

/**
 * Request parameters for listAccessRequestStatus operation in AccessRequestsApi.
 * @export
 * @interface AccessRequestsApiListAccessRequestStatusRequest
 */
export interface AccessRequestsApiListAccessRequestStatusRequest {
    /**
     * Filter the results by the identity for which the requests were made. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
     * @type {string}
     * @memberof AccessRequestsApiListAccessRequestStatus
     */
    readonly requestedFor?: string

    /**
     * Filter the results by the identity that made the requests. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
     * @type {string}
     * @memberof AccessRequestsApiListAccessRequestStatus
     */
    readonly requestedBy?: string

    /**
     * Filter the results by the specified identity which is either the requester or target of the requests. *me* indicates the current user. Mutually exclusive with *requested-for* and *requested-by*.
     * @type {string}
     * @memberof AccessRequestsApiListAccessRequestStatus
     */
    readonly regardingIdentity?: string

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.
     * @type {boolean}
     * @memberof AccessRequestsApiListAccessRequestStatus
     */
    readonly count?: boolean

    /**
     * Max number of results to return.
     * @type {number}
     * @memberof AccessRequestsApiListAccessRequestStatus
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. Defaults to 0 if not specified.
     * @type {number}
     * @memberof AccessRequestsApiListAccessRequestStatus
     */
    readonly offset?: number

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **accountActivityItemId**: *eq, in*
     * @type {string}
     * @memberof AccessRequestsApiListAccessRequestStatus
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified, accountActivityItemId**
     * @type {string}
     * @memberof AccessRequestsApiListAccessRequestStatus
     */
    readonly sorters?: string
}

/**
 * Request parameters for updateAccessRequestConfig operation in AccessRequestsApi.
 * @export
 * @interface AccessRequestsApiUpdateAccessRequestConfigRequest
 */
export interface AccessRequestsApiUpdateAccessRequestConfigRequest {
    /**
     * 
     * @type {AccessRequestConfig}
     * @memberof AccessRequestsApiUpdateAccessRequestConfig
     */
    readonly accessRequestConfig: AccessRequestConfig
}

/**
 * AccessRequestsApi - object-oriented interface
 * @export
 * @class AccessRequestsApi
 * @extends {BaseAPI}
 */
export class AccessRequestsApi extends BaseAPI {
    /**
     * This API endpoint cancels a pending access request. An access request can be cancelled only if it has not passed the approval step. Any token with ORG_ADMIN authority or token of the user who originally requested the access request is required to cancel it.
     * @summary Cancel Access Request
     * @param {AccessRequestsApiCancelAccessRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestsApi
     */
    public cancelAccessRequest(requestParameters: AccessRequestsApiCancelAccessRequestRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessRequestsApiFp(this.configuration).cancelAccessRequest(requestParameters.cancelAccessRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This submits the access request into IdentityNow, where it will follow any IdentityNow approval processes.  Access requests are processed asynchronously by IdentityNow.  A success response from this endpoint means the request has been submitted to IDN and is queued for processing.  Because this endpoint is asynchronous, it will not return an error if you submit duplicate access requests in quick succession, or you submit an access request for access that is already in progress, approved, or rejected. It is best practice to check for any existing access requests that reference the same access items before submitting a new access request.  This can be accomplished by using the [access request status](https://developer.sailpoint.com/idn/api/v3/list-access-request-status) or the [pending access request approvals](https://developer.sailpoint.com/idn/api/v3/list-pending-approvals) endpoints.  You can also use the [search API](https://developer.sailpoint.com/idn/api/v3/search) to check the existing access items that an identity has before submitting an access request to ensure you are not requesting access that is already granted.  There are two types of access request:  __GRANT_ACCESS__ * Can be requested for multiple identities in a single request. * Supports self request and request on behalf of other users, see \'/beta/access-request-config\' endpoint for request configuration options.   * Allows any authenticated token (except API) to call this endpoint to request to grant access to themselves. Depending on the configuration, a user can request access for others. * Roles, Access Profiles and Entitlements can be requested. * While requesting entitlements, maximum of 25 entitlements and 10 recipients are allowed in a request.   __REVOKE_ACCESS__ * Can only be requested for a single identity at a time. * Does not support self request. Only manager can request to revoke access for their directly managed employees. * If removeDate is specified, then the access will be removed on that date and time. * Allows a manager to request to revoke access for direct employees. A token with ORG_ADMIN authority can also request to revoke access from anyone. * Roles and Access Profiles can be requested for revocation. Revoke request for entitlements are not supported currently.  NOTE: There is no indication to the approver in the IdentityNow UI that the approval request is for a revoke action. Take this into consideration when calling this API.  A token with API authority cannot be used to call this endpoint.  
     * @summary Submit an Access Request
     * @param {AccessRequestsApiCreateAccessRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestsApi
     */
    public createAccessRequest(requestParameters: AccessRequestsApiCreateAccessRequestRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessRequestsApiFp(this.configuration).createAccessRequest(requestParameters.accessRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns the current access-request configuration.
     * @summary Get Access Request Configuration
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestsApi
     */
    public getAccessRequestConfig(axiosOptions?: AxiosRequestConfig) {
        return AccessRequestsApiFp(this.configuration).getAccessRequestConfig(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The Access Request Status API returns a list of access request statuses based on the specified query parameters. Any token with any authority can request their own status. A token with ORG_ADMIN authority is required to call this API to get a list of statuses for other users.
     * @summary Access Request Status
     * @param {AccessRequestsApiListAccessRequestStatusRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestsApi
     */
    public listAccessRequestStatus(requestParameters: AccessRequestsApiListAccessRequestStatusRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return AccessRequestsApiFp(this.configuration).listAccessRequestStatus(requestParameters.requestedFor, requestParameters.requestedBy, requestParameters.regardingIdentity, requestParameters.count, requestParameters.limit, requestParameters.offset, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint replaces the current access-request configuration. A token with ORG_ADMIN authority is required to call this API.
     * @summary Update Access Request Configuration
     * @param {AccessRequestsApiUpdateAccessRequestConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessRequestsApi
     */
    public updateAccessRequestConfig(requestParameters: AccessRequestsApiUpdateAccessRequestConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return AccessRequestsApiFp(this.configuration).updateAccessRequestConfig(requestParameters.accessRequestConfig, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AccountActivitiesApi - axios parameter creator
 * @export
 */
export const AccountActivitiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This gets a single account activity by its id.
         * @summary Get an Account Activity
         * @param {string} id The account activity id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccountActivity: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAccountActivity', 'id', id)
            const localVarPath = `/account-activities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a collection of account activities that satisfy the given query parameters.
         * @summary List Account Activities
         * @param {string} [requestedFor] The identity that the activity was requested for. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [requestedBy] The identity that requested the activity. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [regardingIdentity] The specified identity will be either the requester or target of the account activity. *me* indicates the current user. Mutually exclusive with *requested-for* and *requested-by*.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results).  Filtering is supported for the following fields and operators:  **type**: *eq, in* (See the &#x60;type&#x60; property in the response schema for possible values)  **created**: *gt, lt, ge, le*  **modified**: *gt, lt, ge, le*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **type, created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccountActivities: async (requestedFor?: string, requestedBy?: string, regardingIdentity?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account-activities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (requestedFor !== undefined) {
                localVarQueryParameter['requested-for'] = requestedFor;
            }

            if (requestedBy !== undefined) {
                localVarQueryParameter['requested-by'] = requestedBy;
            }

            if (regardingIdentity !== undefined) {
                localVarQueryParameter['regarding-identity'] = regardingIdentity;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountActivitiesApi - functional programming interface
 * @export
 */
export const AccountActivitiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountActivitiesApiAxiosParamCreator(configuration)
    return {
        /**
         * This gets a single account activity by its id.
         * @summary Get an Account Activity
         * @param {string} id The account activity id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountActivity(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountActivity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountActivity(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a collection of account activities that satisfy the given query parameters.
         * @summary List Account Activities
         * @param {string} [requestedFor] The identity that the activity was requested for. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [requestedBy] The identity that requested the activity. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [regardingIdentity] The specified identity will be either the requester or target of the account activity. *me* indicates the current user. Mutually exclusive with *requested-for* and *requested-by*.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results).  Filtering is supported for the following fields and operators:  **type**: *eq, in* (See the &#x60;type&#x60; property in the response schema for possible values)  **created**: *gt, lt, ge, le*  **modified**: *gt, lt, ge, le*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **type, created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listAccountActivities(requestedFor?: string, requestedBy?: string, regardingIdentity?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccountActivity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccountActivities(requestedFor, requestedBy, regardingIdentity, limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountActivitiesApi - factory interface
 * @export
 */
export const AccountActivitiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountActivitiesApiFp(configuration)
    return {
        /**
         * This gets a single account activity by its id.
         * @summary Get an Account Activity
         * @param {string} id The account activity id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccountActivity(id: string, axiosOptions?: any): AxiosPromise<AccountActivity> {
            return localVarFp.getAccountActivity(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a collection of account activities that satisfy the given query parameters.
         * @summary List Account Activities
         * @param {string} [requestedFor] The identity that the activity was requested for. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [requestedBy] The identity that requested the activity. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
         * @param {string} [regardingIdentity] The specified identity will be either the requester or target of the account activity. *me* indicates the current user. Mutually exclusive with *requested-for* and *requested-by*.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results).  Filtering is supported for the following fields and operators:  **type**: *eq, in* (See the &#x60;type&#x60; property in the response schema for possible values)  **created**: *gt, lt, ge, le*  **modified**: *gt, lt, ge, le*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **type, created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccountActivities(requestedFor?: string, requestedBy?: string, regardingIdentity?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<AccountActivity>> {
            return localVarFp.listAccountActivities(requestedFor, requestedBy, regardingIdentity, limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getAccountActivity operation in AccountActivitiesApi.
 * @export
 * @interface AccountActivitiesApiGetAccountActivityRequest
 */
export interface AccountActivitiesApiGetAccountActivityRequest {
    /**
     * The account activity id
     * @type {string}
     * @memberof AccountActivitiesApiGetAccountActivity
     */
    readonly id: string
}

/**
 * Request parameters for listAccountActivities operation in AccountActivitiesApi.
 * @export
 * @interface AccountActivitiesApiListAccountActivitiesRequest
 */
export interface AccountActivitiesApiListAccountActivitiesRequest {
    /**
     * The identity that the activity was requested for. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
     * @type {string}
     * @memberof AccountActivitiesApiListAccountActivities
     */
    readonly requestedFor?: string

    /**
     * The identity that requested the activity. *me* indicates the current user. Mutually exclusive with *regarding-identity*.
     * @type {string}
     * @memberof AccountActivitiesApiListAccountActivities
     */
    readonly requestedBy?: string

    /**
     * The specified identity will be either the requester or target of the account activity. *me* indicates the current user. Mutually exclusive with *requested-for* and *requested-by*.
     * @type {string}
     * @memberof AccountActivitiesApiListAccountActivities
     */
    readonly regardingIdentity?: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccountActivitiesApiListAccountActivities
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccountActivitiesApiListAccountActivities
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof AccountActivitiesApiListAccountActivities
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results).  Filtering is supported for the following fields and operators:  **type**: *eq, in* (See the &#x60;type&#x60; property in the response schema for possible values)  **created**: *gt, lt, ge, le*  **modified**: *gt, lt, ge, le*
     * @type {string}
     * @memberof AccountActivitiesApiListAccountActivities
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **type, created, modified**
     * @type {string}
     * @memberof AccountActivitiesApiListAccountActivities
     */
    readonly sorters?: string
}

/**
 * AccountActivitiesApi - object-oriented interface
 * @export
 * @class AccountActivitiesApi
 * @extends {BaseAPI}
 */
export class AccountActivitiesApi extends BaseAPI {
    /**
     * This gets a single account activity by its id.
     * @summary Get an Account Activity
     * @param {AccountActivitiesApiGetAccountActivityRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountActivitiesApi
     */
    public getAccountActivity(requestParameters: AccountActivitiesApiGetAccountActivityRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountActivitiesApiFp(this.configuration).getAccountActivity(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a collection of account activities that satisfy the given query parameters.
     * @summary List Account Activities
     * @param {AccountActivitiesApiListAccountActivitiesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountActivitiesApi
     */
    public listAccountActivities(requestParameters: AccountActivitiesApiListAccountActivitiesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return AccountActivitiesApiFp(this.configuration).listAccountActivities(requestParameters.requestedFor, requestParameters.requestedBy, requestParameters.regardingIdentity, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API submits an account creation task and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Account
         * @param {AccountAttributesCreate} accountAttributesCreate 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createAccount: async (accountAttributesCreate: AccountAttributesCreate, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountAttributesCreate' is not null or undefined
            assertParamExists('createAccount', 'accountAttributesCreate', accountAttributesCreate)
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountAttributesCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API submits an account delete task and returns the task ID. This operation can only be used on Flat File Sources. Any attempt to execute this request on the source of other type will result in an error response with a status code of 400. A token with ORG_ADMIN authority is required to call this API.
         * @summary Delete Account
         * @param {string} id The account ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAccount', 'id', id)
            const localVarPath = `/accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API submits a task to disable the account and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Disable Account
         * @param {string} id The account id
         * @param {AccountToggleRequest} accountToggleRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        disableAccount: async (id: string, accountToggleRequest: AccountToggleRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('disableAccount', 'id', id)
            // verify required parameter 'accountToggleRequest' is not null or undefined
            assertParamExists('disableAccount', 'accountToggleRequest', accountToggleRequest)
            const localVarPath = `/accounts/{id}/disable`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountToggleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API submits a task to enable account and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Enable Account
         * @param {string} id The account id
         * @param {AccountToggleRequest} accountToggleRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        enableAccount: async (id: string, accountToggleRequest: AccountToggleRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('enableAccount', 'id', id)
            // verify required parameter 'accountToggleRequest' is not null or undefined
            assertParamExists('enableAccount', 'accountToggleRequest', accountToggleRequest)
            const localVarPath = `/accounts/{id}/enable`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountToggleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the details for a single account based on the ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Account Details
         * @param {string} id The account ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccount: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAccount', 'id', id)
            const localVarPath = `/accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns entitlements of the account.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Account Entitlements
         * @param {string} id The account id
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccountEntitlements: async (id: string, limit?: number, offset?: number, count?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAccountEntitlements', 'id', id)
            const localVarPath = `/accounts/{id}/entitlements`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This returns a list of accounts.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Accounts List
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **identityId**: *eq*  **name**: *eq, in*  **nativeIdentity**: *eq, in*  **sourceId**: *eq, in*  **uncorrelated**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccounts: async (limit?: number, offset?: number, count?: boolean, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API submits an account update task and returns the task ID.   A token with ORG_ADMIN authority is required to call this API. >**NOTE: The PUT Account API is designated only for Delimited File sources.**
         * @summary Update Account
         * @param {string} id The account ID
         * @param {AccountAttributes} accountAttributes 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putAccount: async (id: string, accountAttributes: AccountAttributes, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putAccount', 'id', id)
            // verify required parameter 'accountAttributes' is not null or undefined
            assertParamExists('putAccount', 'accountAttributes', accountAttributes)
            const localVarPath = `/accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountAttributes, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API asynchronously reloads the account directly from the connector and performs a one-time aggregation process.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Reload Account
         * @param {string} id The account id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        reloadAccount: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('reloadAccount', 'id', id)
            const localVarPath = `/accounts/{id}/reload`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API submits a task to unlock an account and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Unlock Account
         * @param {string} id The account id
         * @param {AccountUnlockRequest} accountUnlockRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        unlockAccount: async (id: string, accountUnlockRequest: AccountUnlockRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unlockAccount', 'id', id)
            // verify required parameter 'accountUnlockRequest' is not null or undefined
            assertParamExists('unlockAccount', 'accountUnlockRequest', accountUnlockRequest)
            const localVarPath = `/accounts/{id}/unlock`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountUnlockRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to modify the following fields: * `identityId`  * `manuallyCorrelated`  >**NOTE: All other fields can not be modified.**  The request must provide a JSONPatch payload.  A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Account
         * @param {string} id The account ID
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of account update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount: async (id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateAccount', 'id', id)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('updateAccount', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * This API submits an account creation task and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Account
         * @param {AccountAttributesCreate} accountAttributesCreate 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createAccount(accountAttributesCreate: AccountAttributesCreate, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsAsyncResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccount(accountAttributesCreate, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API submits an account delete task and returns the task ID. This operation can only be used on Flat File Sources. Any attempt to execute this request on the source of other type will result in an error response with a status code of 400. A token with ORG_ADMIN authority is required to call this API.
         * @summary Delete Account
         * @param {string} id The account ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccount(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsAsyncResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccount(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API submits a task to disable the account and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Disable Account
         * @param {string} id The account id
         * @param {AccountToggleRequest} accountToggleRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async disableAccount(id: string, accountToggleRequest: AccountToggleRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsAsyncResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableAccount(id, accountToggleRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API submits a task to enable account and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Enable Account
         * @param {string} id The account id
         * @param {AccountToggleRequest} accountToggleRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async enableAccount(id: string, accountToggleRequest: AccountToggleRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsAsyncResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableAccount(id, accountToggleRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns the details for a single account based on the ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Account Details
         * @param {string} id The account ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAccount(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccount(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns entitlements of the account.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Account Entitlements
         * @param {string} id The account id
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountEntitlements(id: string, limit?: number, offset?: number, count?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EntitlementDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountEntitlements(id, limit, offset, count, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This returns a list of accounts.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Accounts List
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **identityId**: *eq*  **name**: *eq, in*  **nativeIdentity**: *eq, in*  **sourceId**: *eq, in*  **uncorrelated**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listAccounts(limit?: number, offset?: number, count?: boolean, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Account>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccounts(limit, offset, count, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API submits an account update task and returns the task ID.   A token with ORG_ADMIN authority is required to call this API. >**NOTE: The PUT Account API is designated only for Delimited File sources.**
         * @summary Update Account
         * @param {string} id The account ID
         * @param {AccountAttributes} accountAttributes 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async putAccount(id: string, accountAttributes: AccountAttributes, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsAsyncResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putAccount(id, accountAttributes, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API asynchronously reloads the account directly from the connector and performs a one-time aggregation process.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Reload Account
         * @param {string} id The account id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async reloadAccount(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsAsyncResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reloadAccount(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API submits a task to unlock an account and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Unlock Account
         * @param {string} id The account id
         * @param {AccountUnlockRequest} accountUnlockRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async unlockAccount(id: string, accountUnlockRequest: AccountUnlockRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsAsyncResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlockAccount(id, accountUnlockRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this API to modify the following fields: * `identityId`  * `manuallyCorrelated`  >**NOTE: All other fields can not be modified.**  The request must provide a JSONPatch payload.  A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Account
         * @param {string} id The account ID
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of account update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateAccount(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAccount(id, jsonPatchOperation, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * This API submits an account creation task and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Account
         * @param {AccountAttributesCreate} accountAttributesCreate 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createAccount(accountAttributesCreate: AccountAttributesCreate, axiosOptions?: any): AxiosPromise<AccountsAsyncResult> {
            return localVarFp.createAccount(accountAttributesCreate, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API submits an account delete task and returns the task ID. This operation can only be used on Flat File Sources. Any attempt to execute this request on the source of other type will result in an error response with a status code of 400. A token with ORG_ADMIN authority is required to call this API.
         * @summary Delete Account
         * @param {string} id The account ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount(id: string, axiosOptions?: any): AxiosPromise<AccountsAsyncResult> {
            return localVarFp.deleteAccount(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API submits a task to disable the account and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Disable Account
         * @param {string} id The account id
         * @param {AccountToggleRequest} accountToggleRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        disableAccount(id: string, accountToggleRequest: AccountToggleRequest, axiosOptions?: any): AxiosPromise<AccountsAsyncResult> {
            return localVarFp.disableAccount(id, accountToggleRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API submits a task to enable account and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Enable Account
         * @param {string} id The account id
         * @param {AccountToggleRequest} accountToggleRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        enableAccount(id: string, accountToggleRequest: AccountToggleRequest, axiosOptions?: any): AxiosPromise<AccountsAsyncResult> {
            return localVarFp.enableAccount(id, accountToggleRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the details for a single account based on the ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Account Details
         * @param {string} id The account ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(id: string, axiosOptions?: any): AxiosPromise<Account> {
            return localVarFp.getAccount(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns entitlements of the account.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Account Entitlements
         * @param {string} id The account id
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAccountEntitlements(id: string, limit?: number, offset?: number, count?: boolean, axiosOptions?: any): AxiosPromise<Array<EntitlementDto>> {
            return localVarFp.getAccountEntitlements(id, limit, offset, count, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This returns a list of accounts.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Accounts List
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **identityId**: *eq*  **name**: *eq, in*  **nativeIdentity**: *eq, in*  **sourceId**: *eq, in*  **uncorrelated**: *eq*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccounts(limit?: number, offset?: number, count?: boolean, filters?: string, axiosOptions?: any): AxiosPromise<Array<Account>> {
            return localVarFp.listAccounts(limit, offset, count, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API submits an account update task and returns the task ID.   A token with ORG_ADMIN authority is required to call this API. >**NOTE: The PUT Account API is designated only for Delimited File sources.**
         * @summary Update Account
         * @param {string} id The account ID
         * @param {AccountAttributes} accountAttributes 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        putAccount(id: string, accountAttributes: AccountAttributes, axiosOptions?: any): AxiosPromise<AccountsAsyncResult> {
            return localVarFp.putAccount(id, accountAttributes, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API asynchronously reloads the account directly from the connector and performs a one-time aggregation process.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Reload Account
         * @param {string} id The account id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        reloadAccount(id: string, axiosOptions?: any): AxiosPromise<AccountsAsyncResult> {
            return localVarFp.reloadAccount(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API submits a task to unlock an account and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
         * @summary Unlock Account
         * @param {string} id The account id
         * @param {AccountUnlockRequest} accountUnlockRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        unlockAccount(id: string, accountUnlockRequest: AccountUnlockRequest, axiosOptions?: any): AxiosPromise<AccountsAsyncResult> {
            return localVarFp.unlockAccount(id, accountUnlockRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to modify the following fields: * `identityId`  * `manuallyCorrelated`  >**NOTE: All other fields can not be modified.**  The request must provide a JSONPatch payload.  A token with ORG_ADMIN authority is required to call this API.
         * @summary Update Account
         * @param {string} id The account ID
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of account update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: any): AxiosPromise<object> {
            return localVarFp.updateAccount(id, jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiCreateAccountRequest
 */
export interface AccountsApiCreateAccountRequest {
    /**
     * 
     * @type {AccountAttributesCreate}
     * @memberof AccountsApiCreateAccount
     */
    readonly accountAttributesCreate: AccountAttributesCreate
}

/**
 * Request parameters for deleteAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiDeleteAccountRequest
 */
export interface AccountsApiDeleteAccountRequest {
    /**
     * The account ID
     * @type {string}
     * @memberof AccountsApiDeleteAccount
     */
    readonly id: string
}

/**
 * Request parameters for disableAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiDisableAccountRequest
 */
export interface AccountsApiDisableAccountRequest {
    /**
     * The account id
     * @type {string}
     * @memberof AccountsApiDisableAccount
     */
    readonly id: string

    /**
     * 
     * @type {AccountToggleRequest}
     * @memberof AccountsApiDisableAccount
     */
    readonly accountToggleRequest: AccountToggleRequest
}

/**
 * Request parameters for enableAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiEnableAccountRequest
 */
export interface AccountsApiEnableAccountRequest {
    /**
     * The account id
     * @type {string}
     * @memberof AccountsApiEnableAccount
     */
    readonly id: string

    /**
     * 
     * @type {AccountToggleRequest}
     * @memberof AccountsApiEnableAccount
     */
    readonly accountToggleRequest: AccountToggleRequest
}

/**
 * Request parameters for getAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiGetAccountRequest
 */
export interface AccountsApiGetAccountRequest {
    /**
     * The account ID
     * @type {string}
     * @memberof AccountsApiGetAccount
     */
    readonly id: string
}

/**
 * Request parameters for getAccountEntitlements operation in AccountsApi.
 * @export
 * @interface AccountsApiGetAccountEntitlementsRequest
 */
export interface AccountsApiGetAccountEntitlementsRequest {
    /**
     * The account id
     * @type {string}
     * @memberof AccountsApiGetAccountEntitlements
     */
    readonly id: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccountsApiGetAccountEntitlements
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccountsApiGetAccountEntitlements
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof AccountsApiGetAccountEntitlements
     */
    readonly count?: boolean
}

/**
 * Request parameters for listAccounts operation in AccountsApi.
 * @export
 * @interface AccountsApiListAccountsRequest
 */
export interface AccountsApiListAccountsRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccountsApiListAccounts
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof AccountsApiListAccounts
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof AccountsApiListAccounts
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **identityId**: *eq*  **name**: *eq, in*  **nativeIdentity**: *eq, in*  **sourceId**: *eq, in*  **uncorrelated**: *eq*
     * @type {string}
     * @memberof AccountsApiListAccounts
     */
    readonly filters?: string
}

/**
 * Request parameters for putAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiPutAccountRequest
 */
export interface AccountsApiPutAccountRequest {
    /**
     * The account ID
     * @type {string}
     * @memberof AccountsApiPutAccount
     */
    readonly id: string

    /**
     * 
     * @type {AccountAttributes}
     * @memberof AccountsApiPutAccount
     */
    readonly accountAttributes: AccountAttributes
}

/**
 * Request parameters for reloadAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiReloadAccountRequest
 */
export interface AccountsApiReloadAccountRequest {
    /**
     * The account id
     * @type {string}
     * @memberof AccountsApiReloadAccount
     */
    readonly id: string
}

/**
 * Request parameters for unlockAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiUnlockAccountRequest
 */
export interface AccountsApiUnlockAccountRequest {
    /**
     * The account id
     * @type {string}
     * @memberof AccountsApiUnlockAccount
     */
    readonly id: string

    /**
     * 
     * @type {AccountUnlockRequest}
     * @memberof AccountsApiUnlockAccount
     */
    readonly accountUnlockRequest: AccountUnlockRequest
}

/**
 * Request parameters for updateAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiUpdateAccountRequest
 */
export interface AccountsApiUpdateAccountRequest {
    /**
     * The account ID
     * @type {string}
     * @memberof AccountsApiUpdateAccount
     */
    readonly id: string

    /**
     * A list of account update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
     * @type {Array<JsonPatchOperation>}
     * @memberof AccountsApiUpdateAccount
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * This API submits an account creation task and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
     * @summary Create Account
     * @param {AccountsApiCreateAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public createAccount(requestParameters: AccountsApiCreateAccountRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).createAccount(requestParameters.accountAttributesCreate, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API submits an account delete task and returns the task ID. This operation can only be used on Flat File Sources. Any attempt to execute this request on the source of other type will result in an error response with a status code of 400. A token with ORG_ADMIN authority is required to call this API.
     * @summary Delete Account
     * @param {AccountsApiDeleteAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public deleteAccount(requestParameters: AccountsApiDeleteAccountRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).deleteAccount(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API submits a task to disable the account and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
     * @summary Disable Account
     * @param {AccountsApiDisableAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public disableAccount(requestParameters: AccountsApiDisableAccountRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).disableAccount(requestParameters.id, requestParameters.accountToggleRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API submits a task to enable account and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
     * @summary Enable Account
     * @param {AccountsApiEnableAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public enableAccount(requestParameters: AccountsApiEnableAccountRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).enableAccount(requestParameters.id, requestParameters.accountToggleRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the details for a single account based on the ID.   A token with ORG_ADMIN authority is required to call this API.
     * @summary Account Details
     * @param {AccountsApiGetAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccount(requestParameters: AccountsApiGetAccountRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccount(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns entitlements of the account.   A token with ORG_ADMIN authority is required to call this API.
     * @summary Account Entitlements
     * @param {AccountsApiGetAccountEntitlementsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccountEntitlements(requestParameters: AccountsApiGetAccountEntitlementsRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccountEntitlements(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This returns a list of accounts.   A token with ORG_ADMIN authority is required to call this API.
     * @summary Accounts List
     * @param {AccountsApiListAccountsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public listAccounts(requestParameters: AccountsApiListAccountsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).listAccounts(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API submits an account update task and returns the task ID.   A token with ORG_ADMIN authority is required to call this API. >**NOTE: The PUT Account API is designated only for Delimited File sources.**
     * @summary Update Account
     * @param {AccountsApiPutAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public putAccount(requestParameters: AccountsApiPutAccountRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).putAccount(requestParameters.id, requestParameters.accountAttributes, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API asynchronously reloads the account directly from the connector and performs a one-time aggregation process.   A token with ORG_ADMIN authority is required to call this API.
     * @summary Reload Account
     * @param {AccountsApiReloadAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public reloadAccount(requestParameters: AccountsApiReloadAccountRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).reloadAccount(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API submits a task to unlock an account and returns the task ID.   A token with ORG_ADMIN authority is required to call this API.
     * @summary Unlock Account
     * @param {AccountsApiUnlockAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public unlockAccount(requestParameters: AccountsApiUnlockAccountRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).unlockAccount(requestParameters.id, requestParameters.accountUnlockRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to modify the following fields: * `identityId`  * `manuallyCorrelated`  >**NOTE: All other fields can not be modified.**  The request must provide a JSONPatch payload.  A token with ORG_ADMIN authority is required to call this API.
     * @summary Update Account
     * @param {AccountsApiUpdateAccountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public updateAccount(requestParameters: AccountsApiUpdateAccountRequest, axiosOptions?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).updateAccount(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CertificationSummariesApi - axios parameter creator
 * @export
 */
export const CertificationSummariesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API returns a list of access summaries for the specified identity campaign certification and type. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Access Summaries
         * @param {string} id The identity campaign certification ID
         * @param {'ROLE' | 'ACCESS_PROFILE' | 'ENTITLEMENT'} type The type of access review item to retrieve summaries for
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki-API-Standard-Collection-Parameters/ta-p/156407)  Filtering is supported for the following fields and operators:  **completed**: *eq, ne*  **access.id**: *eq, in*  **access.name**: *eq, sw*  **entitlement.sourceName**: *eq, sw*  **accessProfile.sourceName**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **access.name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityAccessSummaries: async (id: string, type: 'ROLE' | 'ACCESS_PROFILE' | 'ENTITLEMENT', limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getIdentityAccessSummaries', 'id', id)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getIdentityAccessSummaries', 'type', type)
            const localVarPath = `/certifications/{id}/access-summaries/{type}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a summary of the decisions made on an identity campaign certification. The decisions are summarized by type. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Summary of Certification Decisions
         * @param {string} id The certification ID
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki-API-Standard-Collection-Parameters/ta-p/156407)  Filtering is supported for the following fields and operators:  **identitySummary.id**: *eq, in*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityDecisionSummary: async (id: string, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getIdentityDecisionSummary', 'id', id)
            const localVarPath = `/certifications/{id}/decision-summary`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of the identity summaries for a specific identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Identity Summaries for Campaign Certification
         * @param {string} id The identity campaign certification ID
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **completed**: *eq, ne*  **name**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentitySummaries: async (id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getIdentitySummaries', 'id', id)
            const localVarPath = `/certifications/{id}/identity-summaries`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the summary for an identity on a specified identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Summary for Identity
         * @param {string} id The identity campaign certification ID
         * @param {string} identitySummaryId The identity summary ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentitySummary: async (id: string, identitySummaryId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getIdentitySummary', 'id', id)
            // verify required parameter 'identitySummaryId' is not null or undefined
            assertParamExists('getIdentitySummary', 'identitySummaryId', identitySummaryId)
            const localVarPath = `/certifications/{id}/identity-summary/{identitySummaryId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"identitySummaryId"}}`, encodeURIComponent(String(identitySummaryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * CertificationSummariesApi - functional programming interface
 * @export
 */
export const CertificationSummariesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CertificationSummariesApiAxiosParamCreator(configuration)
    return {
        /**
         * This API returns a list of access summaries for the specified identity campaign certification and type. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Access Summaries
         * @param {string} id The identity campaign certification ID
         * @param {'ROLE' | 'ACCESS_PROFILE' | 'ENTITLEMENT'} type The type of access review item to retrieve summaries for
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki-API-Standard-Collection-Parameters/ta-p/156407)  Filtering is supported for the following fields and operators:  **completed**: *eq, ne*  **access.id**: *eq, in*  **access.name**: *eq, sw*  **entitlement.sourceName**: *eq, sw*  **accessProfile.sourceName**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **access.name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentityAccessSummaries(id: string, type: 'ROLE' | 'ACCESS_PROFILE' | 'ENTITLEMENT', limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccessSummary>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentityAccessSummaries(id, type, limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns a summary of the decisions made on an identity campaign certification. The decisions are summarized by type. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Summary of Certification Decisions
         * @param {string} id The certification ID
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki-API-Standard-Collection-Parameters/ta-p/156407)  Filtering is supported for the following fields and operators:  **identitySummary.id**: *eq, in*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentityDecisionSummary(id: string, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityCertDecisionSummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentityDecisionSummary(id, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns a list of the identity summaries for a specific identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Identity Summaries for Campaign Certification
         * @param {string} id The identity campaign certification ID
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **completed**: *eq, ne*  **name**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentitySummaries(id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CertificationIdentitySummary>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentitySummaries(id, limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns the summary for an identity on a specified identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Summary for Identity
         * @param {string} id The identity campaign certification ID
         * @param {string} identitySummaryId The identity summary ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentitySummary(id: string, identitySummaryId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CertificationIdentitySummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentitySummary(id, identitySummaryId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CertificationSummariesApi - factory interface
 * @export
 */
export const CertificationSummariesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CertificationSummariesApiFp(configuration)
    return {
        /**
         * This API returns a list of access summaries for the specified identity campaign certification and type. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Access Summaries
         * @param {string} id The identity campaign certification ID
         * @param {'ROLE' | 'ACCESS_PROFILE' | 'ENTITLEMENT'} type The type of access review item to retrieve summaries for
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki-API-Standard-Collection-Parameters/ta-p/156407)  Filtering is supported for the following fields and operators:  **completed**: *eq, ne*  **access.id**: *eq, in*  **access.name**: *eq, sw*  **entitlement.sourceName**: *eq, sw*  **accessProfile.sourceName**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **access.name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityAccessSummaries(id: string, type: 'ROLE' | 'ACCESS_PROFILE' | 'ENTITLEMENT', limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<AccessSummary>> {
            return localVarFp.getIdentityAccessSummaries(id, type, limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a summary of the decisions made on an identity campaign certification. The decisions are summarized by type. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Summary of Certification Decisions
         * @param {string} id The certification ID
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki-API-Standard-Collection-Parameters/ta-p/156407)  Filtering is supported for the following fields and operators:  **identitySummary.id**: *eq, in*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityDecisionSummary(id: string, filters?: string, axiosOptions?: any): AxiosPromise<IdentityCertDecisionSummary> {
            return localVarFp.getIdentityDecisionSummary(id, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of the identity summaries for a specific identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Identity Summaries for Campaign Certification
         * @param {string} id The identity campaign certification ID
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **completed**: *eq, ne*  **name**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentitySummaries(id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<CertificationIdentitySummary>> {
            return localVarFp.getIdentitySummaries(id, limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the summary for an identity on a specified identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
         * @summary Summary for Identity
         * @param {string} id The identity campaign certification ID
         * @param {string} identitySummaryId The identity summary ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentitySummary(id: string, identitySummaryId: string, axiosOptions?: any): AxiosPromise<CertificationIdentitySummary> {
            return localVarFp.getIdentitySummary(id, identitySummaryId, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getIdentityAccessSummaries operation in CertificationSummariesApi.
 * @export
 * @interface CertificationSummariesApiGetIdentityAccessSummariesRequest
 */
export interface CertificationSummariesApiGetIdentityAccessSummariesRequest {
    /**
     * The identity campaign certification ID
     * @type {string}
     * @memberof CertificationSummariesApiGetIdentityAccessSummaries
     */
    readonly id: string

    /**
     * The type of access review item to retrieve summaries for
     * @type {'ROLE' | 'ACCESS_PROFILE' | 'ENTITLEMENT'}
     * @memberof CertificationSummariesApiGetIdentityAccessSummaries
     */
    readonly type: 'ROLE' | 'ACCESS_PROFILE' | 'ENTITLEMENT'

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationSummariesApiGetIdentityAccessSummaries
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationSummariesApiGetIdentityAccessSummaries
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof CertificationSummariesApiGetIdentityAccessSummaries
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki-API-Standard-Collection-Parameters/ta-p/156407)  Filtering is supported for the following fields and operators:  **completed**: *eq, ne*  **access.id**: *eq, in*  **access.name**: *eq, sw*  **entitlement.sourceName**: *eq, sw*  **accessProfile.sourceName**: *eq, sw*
     * @type {string}
     * @memberof CertificationSummariesApiGetIdentityAccessSummaries
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **access.name**
     * @type {string}
     * @memberof CertificationSummariesApiGetIdentityAccessSummaries
     */
    readonly sorters?: string
}

/**
 * Request parameters for getIdentityDecisionSummary operation in CertificationSummariesApi.
 * @export
 * @interface CertificationSummariesApiGetIdentityDecisionSummaryRequest
 */
export interface CertificationSummariesApiGetIdentityDecisionSummaryRequest {
    /**
     * The certification ID
     * @type {string}
     * @memberof CertificationSummariesApiGetIdentityDecisionSummary
     */
    readonly id: string

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki-API-Standard-Collection-Parameters/ta-p/156407)  Filtering is supported for the following fields and operators:  **identitySummary.id**: *eq, in*
     * @type {string}
     * @memberof CertificationSummariesApiGetIdentityDecisionSummary
     */
    readonly filters?: string
}

/**
 * Request parameters for getIdentitySummaries operation in CertificationSummariesApi.
 * @export
 * @interface CertificationSummariesApiGetIdentitySummariesRequest
 */
export interface CertificationSummariesApiGetIdentitySummariesRequest {
    /**
     * The identity campaign certification ID
     * @type {string}
     * @memberof CertificationSummariesApiGetIdentitySummaries
     */
    readonly id: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationSummariesApiGetIdentitySummaries
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationSummariesApiGetIdentitySummaries
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof CertificationSummariesApiGetIdentitySummaries
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **completed**: *eq, ne*  **name**: *eq, sw*
     * @type {string}
     * @memberof CertificationSummariesApiGetIdentitySummaries
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
     * @type {string}
     * @memberof CertificationSummariesApiGetIdentitySummaries
     */
    readonly sorters?: string
}

/**
 * Request parameters for getIdentitySummary operation in CertificationSummariesApi.
 * @export
 * @interface CertificationSummariesApiGetIdentitySummaryRequest
 */
export interface CertificationSummariesApiGetIdentitySummaryRequest {
    /**
     * The identity campaign certification ID
     * @type {string}
     * @memberof CertificationSummariesApiGetIdentitySummary
     */
    readonly id: string

    /**
     * The identity summary ID
     * @type {string}
     * @memberof CertificationSummariesApiGetIdentitySummary
     */
    readonly identitySummaryId: string
}

/**
 * CertificationSummariesApi - object-oriented interface
 * @export
 * @class CertificationSummariesApi
 * @extends {BaseAPI}
 */
export class CertificationSummariesApi extends BaseAPI {
    /**
     * This API returns a list of access summaries for the specified identity campaign certification and type. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
     * @summary Access Summaries
     * @param {CertificationSummariesApiGetIdentityAccessSummariesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationSummariesApi
     */
    public getIdentityAccessSummaries(requestParameters: CertificationSummariesApiGetIdentityAccessSummariesRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationSummariesApiFp(this.configuration).getIdentityAccessSummaries(requestParameters.id, requestParameters.type, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a summary of the decisions made on an identity campaign certification. The decisions are summarized by type. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
     * @summary Summary of Certification Decisions
     * @param {CertificationSummariesApiGetIdentityDecisionSummaryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationSummariesApi
     */
    public getIdentityDecisionSummary(requestParameters: CertificationSummariesApiGetIdentityDecisionSummaryRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationSummariesApiFp(this.configuration).getIdentityDecisionSummary(requestParameters.id, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of the identity summaries for a specific identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
     * @summary Identity Summaries for Campaign Certification
     * @param {CertificationSummariesApiGetIdentitySummariesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationSummariesApi
     */
    public getIdentitySummaries(requestParameters: CertificationSummariesApiGetIdentitySummariesRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationSummariesApiFp(this.configuration).getIdentitySummaries(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the summary for an identity on a specified identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API.
     * @summary Summary for Identity
     * @param {CertificationSummariesApiGetIdentitySummaryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationSummariesApi
     */
    public getIdentitySummary(requestParameters: CertificationSummariesApiGetIdentitySummaryRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationSummariesApiFp(this.configuration).getIdentitySummary(requestParameters.id, requestParameters.identitySummaryId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CertificationsApi - axios parameter creator
 * @export
 */
export const CertificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API returns a single identity campaign certification by its ID. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Identity Certification by ID
         * @param {string} id The certification id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityCertification: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getIdentityCertification', 'id', id)
            const localVarPath = `/certifications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of access review items for an identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary List of Access Review Items
         * @param {string} id The identity campaign certification ID
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **type / access.type**: *eq*  **completed**: *eq, ne*  **identitySummary.id**: *eq, in*  **identitySummary.name**: *eq, sw*  **access.id**: *eq, in*  **access.name**: *eq, sw*  **entitlement.sourceName**: *eq, sw*  **accessProfile.sourceName**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **identitySummary.name, access.name, access.type, entitlement.sourceName, accessProfile.sourceName**
         * @param {string} [entitlements] Filter results to view access review items that pertain to any of the specified comma-separated entitlement IDs.  An error will occur if this param is used with **access-profiles** or **roles** as only one of these query params can be used at a time.
         * @param {string} [accessProfiles] Filter results to view access review items that pertain to any of the specified comma-separated access-profle IDs.  An error will occur if this param is used with **entitlements** or **roles** as only one of these query params can be used at a time.
         * @param {string} [roles] Filter results to view access review items that pertain to any of the specified comma-separated role IDs.  An error will occur if this param is used with **entitlements** or **access-profiles** as only one of these query params can be used at a time.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listIdentityAccessReviewItems: async (id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, entitlements?: string, accessProfiles?: string, roles?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listIdentityAccessReviewItems', 'id', id)
            const localVarPath = `/certifications/{id}/access-review-items`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (entitlements !== undefined) {
                localVarQueryParameter['entitlements'] = entitlements;
            }

            if (accessProfiles !== undefined) {
                localVarQueryParameter['access-profiles'] = accessProfiles;
            }

            if (roles !== undefined) {
                localVarQueryParameter['roles'] = roles;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns a list of identity campaign certifications that satisfy the given query parameters. Any authenticated token can call this API, but only certifications you are authorized to review will be returned. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Identity Campaign Certifications by IDs
         * @param {string} [reviewerIdentity] The ID of reviewer identity. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: **id**: *eq, in* **campaign.id**: *eq, in* **phase**: *eq* **completed**: *eq, ne*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **name, due, signed**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listIdentityCertifications: async (reviewerIdentity?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/certifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (reviewerIdentity !== undefined) {
                localVarQueryParameter['reviewer-identity'] = reviewerIdentity;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * The API makes a decision to approve or revoke one or more identity campaign certification items. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Decide on a Certification Item
         * @param {string} id The ID of the identity campaign certification on which to make decisions
         * @param {Array<ReviewDecision>} reviewDecision A non-empty array of decisions to be made.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        makeIdentityDecision: async (id: string, reviewDecision: Array<ReviewDecision>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('makeIdentityDecision', 'id', id)
            // verify required parameter 'reviewDecision' is not null or undefined
            assertParamExists('makeIdentityDecision', 'reviewDecision', reviewDecision)
            const localVarPath = `/certifications/{id}/decide`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reviewDecision, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API reassigns up to 50 identities or items in an identity campaign certification to another reviewer. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Reassign Identities or Items
         * @param {string} id The identity campaign certification ID
         * @param {ReviewReassign} reviewReassign 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        reassignIdentityCertifications: async (id: string, reviewReassign: ReviewReassign, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('reassignIdentityCertifications', 'id', id)
            // verify required parameter 'reviewReassign' is not null or undefined
            assertParamExists('reassignIdentityCertifications', 'reviewReassign', reviewReassign)
            const localVarPath = `/certifications/{id}/reassign`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reviewReassign, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API finalizes all decisions made on an identity campaign certification and initiates any remediations required. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Finalize Identity Certification Decisions
         * @param {string} id The identity campaign certification ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        signOffIdentityCertification: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('signOffIdentityCertification', 'id', id)
            const localVarPath = `/certifications/{id}/sign-off`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * CertificationsApi - functional programming interface
 * @export
 */
export const CertificationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CertificationsApiAxiosParamCreator(configuration)
    return {
        /**
         * This API returns a single identity campaign certification by its ID. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Identity Certification by ID
         * @param {string} id The certification id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentityCertification(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityCertificationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentityCertification(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns a list of access review items for an identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary List of Access Review Items
         * @param {string} id The identity campaign certification ID
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **type / access.type**: *eq*  **completed**: *eq, ne*  **identitySummary.id**: *eq, in*  **identitySummary.name**: *eq, sw*  **access.id**: *eq, in*  **access.name**: *eq, sw*  **entitlement.sourceName**: *eq, sw*  **accessProfile.sourceName**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **identitySummary.name, access.name, access.type, entitlement.sourceName, accessProfile.sourceName**
         * @param {string} [entitlements] Filter results to view access review items that pertain to any of the specified comma-separated entitlement IDs.  An error will occur if this param is used with **access-profiles** or **roles** as only one of these query params can be used at a time.
         * @param {string} [accessProfiles] Filter results to view access review items that pertain to any of the specified comma-separated access-profle IDs.  An error will occur if this param is used with **entitlements** or **roles** as only one of these query params can be used at a time.
         * @param {string} [roles] Filter results to view access review items that pertain to any of the specified comma-separated role IDs.  An error will occur if this param is used with **entitlements** or **access-profiles** as only one of these query params can be used at a time.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listIdentityAccessReviewItems(id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, entitlements?: string, accessProfiles?: string, roles?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccessReviewItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listIdentityAccessReviewItems(id, limit, offset, count, filters, sorters, entitlements, accessProfiles, roles, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns a list of identity campaign certifications that satisfy the given query parameters. Any authenticated token can call this API, but only certifications you are authorized to review will be returned. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Identity Campaign Certifications by IDs
         * @param {string} [reviewerIdentity] The ID of reviewer identity. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: **id**: *eq, in* **campaign.id**: *eq, in* **phase**: *eq* **completed**: *eq, ne*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **name, due, signed**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listIdentityCertifications(reviewerIdentity?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IdentityCertificationDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listIdentityCertifications(reviewerIdentity, limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The API makes a decision to approve or revoke one or more identity campaign certification items. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Decide on a Certification Item
         * @param {string} id The ID of the identity campaign certification on which to make decisions
         * @param {Array<ReviewDecision>} reviewDecision A non-empty array of decisions to be made.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async makeIdentityDecision(id: string, reviewDecision: Array<ReviewDecision>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityCertificationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.makeIdentityDecision(id, reviewDecision, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API reassigns up to 50 identities or items in an identity campaign certification to another reviewer. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Reassign Identities or Items
         * @param {string} id The identity campaign certification ID
         * @param {ReviewReassign} reviewReassign 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async reassignIdentityCertifications(id: string, reviewReassign: ReviewReassign, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityCertificationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reassignIdentityCertifications(id, reviewReassign, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API finalizes all decisions made on an identity campaign certification and initiates any remediations required. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Finalize Identity Certification Decisions
         * @param {string} id The identity campaign certification ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async signOffIdentityCertification(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityCertificationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signOffIdentityCertification(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CertificationsApi - factory interface
 * @export
 */
export const CertificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CertificationsApiFp(configuration)
    return {
        /**
         * This API returns a single identity campaign certification by its ID. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Identity Certification by ID
         * @param {string} id The certification id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityCertification(id: string, axiosOptions?: any): AxiosPromise<IdentityCertificationDto> {
            return localVarFp.getIdentityCertification(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of access review items for an identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary List of Access Review Items
         * @param {string} id The identity campaign certification ID
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **type / access.type**: *eq*  **completed**: *eq, ne*  **identitySummary.id**: *eq, in*  **identitySummary.name**: *eq, sw*  **access.id**: *eq, in*  **access.name**: *eq, sw*  **entitlement.sourceName**: *eq, sw*  **accessProfile.sourceName**: *eq, sw*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **identitySummary.name, access.name, access.type, entitlement.sourceName, accessProfile.sourceName**
         * @param {string} [entitlements] Filter results to view access review items that pertain to any of the specified comma-separated entitlement IDs.  An error will occur if this param is used with **access-profiles** or **roles** as only one of these query params can be used at a time.
         * @param {string} [accessProfiles] Filter results to view access review items that pertain to any of the specified comma-separated access-profle IDs.  An error will occur if this param is used with **entitlements** or **roles** as only one of these query params can be used at a time.
         * @param {string} [roles] Filter results to view access review items that pertain to any of the specified comma-separated role IDs.  An error will occur if this param is used with **entitlements** or **access-profiles** as only one of these query params can be used at a time.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listIdentityAccessReviewItems(id: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, entitlements?: string, accessProfiles?: string, roles?: string, axiosOptions?: any): AxiosPromise<Array<AccessReviewItem>> {
            return localVarFp.listIdentityAccessReviewItems(id, limit, offset, count, filters, sorters, entitlements, accessProfiles, roles, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns a list of identity campaign certifications that satisfy the given query parameters. Any authenticated token can call this API, but only certifications you are authorized to review will be returned. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Identity Campaign Certifications by IDs
         * @param {string} [reviewerIdentity] The ID of reviewer identity. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: **id**: *eq, in* **campaign.id**: *eq, in* **phase**: *eq* **completed**: *eq, ne*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **name, due, signed**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listIdentityCertifications(reviewerIdentity?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<IdentityCertificationDto>> {
            return localVarFp.listIdentityCertifications(reviewerIdentity, limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * The API makes a decision to approve or revoke one or more identity campaign certification items. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Decide on a Certification Item
         * @param {string} id The ID of the identity campaign certification on which to make decisions
         * @param {Array<ReviewDecision>} reviewDecision A non-empty array of decisions to be made.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        makeIdentityDecision(id: string, reviewDecision: Array<ReviewDecision>, axiosOptions?: any): AxiosPromise<IdentityCertificationDto> {
            return localVarFp.makeIdentityDecision(id, reviewDecision, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API reassigns up to 50 identities or items in an identity campaign certification to another reviewer. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Reassign Identities or Items
         * @param {string} id The identity campaign certification ID
         * @param {ReviewReassign} reviewReassign 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        reassignIdentityCertifications(id: string, reviewReassign: ReviewReassign, axiosOptions?: any): AxiosPromise<IdentityCertificationDto> {
            return localVarFp.reassignIdentityCertifications(id, reviewReassign, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API finalizes all decisions made on an identity campaign certification and initiates any remediations required. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
         * @summary Finalize Identity Certification Decisions
         * @param {string} id The identity campaign certification ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        signOffIdentityCertification(id: string, axiosOptions?: any): AxiosPromise<IdentityCertificationDto> {
            return localVarFp.signOffIdentityCertification(id, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getIdentityCertification operation in CertificationsApi.
 * @export
 * @interface CertificationsApiGetIdentityCertificationRequest
 */
export interface CertificationsApiGetIdentityCertificationRequest {
    /**
     * The certification id
     * @type {string}
     * @memberof CertificationsApiGetIdentityCertification
     */
    readonly id: string
}

/**
 * Request parameters for listIdentityAccessReviewItems operation in CertificationsApi.
 * @export
 * @interface CertificationsApiListIdentityAccessReviewItemsRequest
 */
export interface CertificationsApiListIdentityAccessReviewItemsRequest {
    /**
     * The identity campaign certification ID
     * @type {string}
     * @memberof CertificationsApiListIdentityAccessReviewItems
     */
    readonly id: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationsApiListIdentityAccessReviewItems
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationsApiListIdentityAccessReviewItems
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof CertificationsApiListIdentityAccessReviewItems
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **type / access.type**: *eq*  **completed**: *eq, ne*  **identitySummary.id**: *eq, in*  **identitySummary.name**: *eq, sw*  **access.id**: *eq, in*  **access.name**: *eq, sw*  **entitlement.sourceName**: *eq, sw*  **accessProfile.sourceName**: *eq, sw*
     * @type {string}
     * @memberof CertificationsApiListIdentityAccessReviewItems
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **identitySummary.name, access.name, access.type, entitlement.sourceName, accessProfile.sourceName**
     * @type {string}
     * @memberof CertificationsApiListIdentityAccessReviewItems
     */
    readonly sorters?: string

    /**
     * Filter results to view access review items that pertain to any of the specified comma-separated entitlement IDs.  An error will occur if this param is used with **access-profiles** or **roles** as only one of these query params can be used at a time.
     * @type {string}
     * @memberof CertificationsApiListIdentityAccessReviewItems
     */
    readonly entitlements?: string

    /**
     * Filter results to view access review items that pertain to any of the specified comma-separated access-profle IDs.  An error will occur if this param is used with **entitlements** or **roles** as only one of these query params can be used at a time.
     * @type {string}
     * @memberof CertificationsApiListIdentityAccessReviewItems
     */
    readonly accessProfiles?: string

    /**
     * Filter results to view access review items that pertain to any of the specified comma-separated role IDs.  An error will occur if this param is used with **entitlements** or **access-profiles** as only one of these query params can be used at a time.
     * @type {string}
     * @memberof CertificationsApiListIdentityAccessReviewItems
     */
    readonly roles?: string
}

/**
 * Request parameters for listIdentityCertifications operation in CertificationsApi.
 * @export
 * @interface CertificationsApiListIdentityCertificationsRequest
 */
export interface CertificationsApiListIdentityCertificationsRequest {
    /**
     * The ID of reviewer identity. *me* indicates the current user.
     * @type {string}
     * @memberof CertificationsApiListIdentityCertifications
     */
    readonly reviewerIdentity?: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationsApiListIdentityCertifications
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof CertificationsApiListIdentityCertifications
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof CertificationsApiListIdentityCertifications
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: **id**: *eq, in* **campaign.id**: *eq, in* **phase**: *eq* **completed**: *eq, ne*
     * @type {string}
     * @memberof CertificationsApiListIdentityCertifications
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results) Sorting is supported for the following fields: **name, due, signed**
     * @type {string}
     * @memberof CertificationsApiListIdentityCertifications
     */
    readonly sorters?: string
}

/**
 * Request parameters for makeIdentityDecision operation in CertificationsApi.
 * @export
 * @interface CertificationsApiMakeIdentityDecisionRequest
 */
export interface CertificationsApiMakeIdentityDecisionRequest {
    /**
     * The ID of the identity campaign certification on which to make decisions
     * @type {string}
     * @memberof CertificationsApiMakeIdentityDecision
     */
    readonly id: string

    /**
     * A non-empty array of decisions to be made.
     * @type {Array<ReviewDecision>}
     * @memberof CertificationsApiMakeIdentityDecision
     */
    readonly reviewDecision: Array<ReviewDecision>
}

/**
 * Request parameters for reassignIdentityCertifications operation in CertificationsApi.
 * @export
 * @interface CertificationsApiReassignIdentityCertificationsRequest
 */
export interface CertificationsApiReassignIdentityCertificationsRequest {
    /**
     * The identity campaign certification ID
     * @type {string}
     * @memberof CertificationsApiReassignIdentityCertifications
     */
    readonly id: string

    /**
     * 
     * @type {ReviewReassign}
     * @memberof CertificationsApiReassignIdentityCertifications
     */
    readonly reviewReassign: ReviewReassign
}

/**
 * Request parameters for signOffIdentityCertification operation in CertificationsApi.
 * @export
 * @interface CertificationsApiSignOffIdentityCertificationRequest
 */
export interface CertificationsApiSignOffIdentityCertificationRequest {
    /**
     * The identity campaign certification ID
     * @type {string}
     * @memberof CertificationsApiSignOffIdentityCertification
     */
    readonly id: string
}

/**
 * CertificationsApi - object-oriented interface
 * @export
 * @class CertificationsApi
 * @extends {BaseAPI}
 */
export class CertificationsApi extends BaseAPI {
    /**
     * This API returns a single identity campaign certification by its ID. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
     * @summary Identity Certification by ID
     * @param {CertificationsApiGetIdentityCertificationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    public getIdentityCertification(requestParameters: CertificationsApiGetIdentityCertificationRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationsApiFp(this.configuration).getIdentityCertification(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of access review items for an identity campaign certification. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
     * @summary List of Access Review Items
     * @param {CertificationsApiListIdentityAccessReviewItemsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    public listIdentityAccessReviewItems(requestParameters: CertificationsApiListIdentityAccessReviewItemsRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationsApiFp(this.configuration).listIdentityAccessReviewItems(requestParameters.id, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, requestParameters.entitlements, requestParameters.accessProfiles, requestParameters.roles, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns a list of identity campaign certifications that satisfy the given query parameters. Any authenticated token can call this API, but only certifications you are authorized to review will be returned. This API does not support requests for certifications assigned to Governance Groups.
     * @summary Identity Campaign Certifications by IDs
     * @param {CertificationsApiListIdentityCertificationsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    public listIdentityCertifications(requestParameters: CertificationsApiListIdentityCertificationsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return CertificationsApiFp(this.configuration).listIdentityCertifications(requestParameters.reviewerIdentity, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The API makes a decision to approve or revoke one or more identity campaign certification items. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
     * @summary Decide on a Certification Item
     * @param {CertificationsApiMakeIdentityDecisionRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    public makeIdentityDecision(requestParameters: CertificationsApiMakeIdentityDecisionRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationsApiFp(this.configuration).makeIdentityDecision(requestParameters.id, requestParameters.reviewDecision, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API reassigns up to 50 identities or items in an identity campaign certification to another reviewer. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
     * @summary Reassign Identities or Items
     * @param {CertificationsApiReassignIdentityCertificationsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    public reassignIdentityCertifications(requestParameters: CertificationsApiReassignIdentityCertificationsRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationsApiFp(this.configuration).reassignIdentityCertifications(requestParameters.id, requestParameters.reviewReassign, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API finalizes all decisions made on an identity campaign certification and initiates any remediations required. A token with ORG_ADMIN or CERT_ADMIN authority is required to call this API. Reviewers for this certification can also call this API. This API does not support requests for certifications assigned to Governance Groups.
     * @summary Finalize Identity Certification Decisions
     * @param {CertificationsApiSignOffIdentityCertificationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificationsApi
     */
    public signOffIdentityCertification(requestParameters: CertificationsApiSignOffIdentityCertificationRequest, axiosOptions?: AxiosRequestConfig) {
        return CertificationsApiFp(this.configuration).signOffIdentityCertification(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdentityProfilesApi - axios parameter creator
 * @export
 */
export const IdentityProfilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This exports existing identity profiles in the format specified by the sp-config service.
         * @summary Export Identity Profiles
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, ne*  **name**: *eq, ne*  **priority**: *eq, ne*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id**, **name**, **priority**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportIdentityProfiles: async (limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/identity-profiles/export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This returns the default identity attribute config. A token with ORG_ADMIN authority is required to call this API to get the default identity attribute config.
         * @summary Get default Identity Attribute Config
         * @param {string} identityProfileId The Identity Profile ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultIdentityAttributeConfig: async (identityProfileId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileId' is not null or undefined
            assertParamExists('getDefaultIdentityAttributeConfig', 'identityProfileId', identityProfileId)
            const localVarPath = `/identity-profiles/{identity-profile-id}/default-identity-attribute-config`
                .replace(`{${"identity-profile-id"}}`, encodeURIComponent(String(identityProfileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This returns a single Identity Profile based on ID. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Get single Identity Profile
         * @param {string} identityProfileId The Identity Profile ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityProfile: async (identityProfileId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileId' is not null or undefined
            assertParamExists('getIdentityProfile', 'identityProfileId', identityProfileId)
            const localVarPath = `/identity-profiles/{identity-profile-id}`
                .replace(`{${"identity-profile-id"}}`, encodeURIComponent(String(identityProfileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This imports previously exported identity profiles.
         * @summary Import Identity Profiles
         * @param {Array<IdentityProfileExportedObject>} identityProfileExportedObject Previously exported Identity Profiles.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importIdentityProfiles: async (identityProfileExportedObject: Array<IdentityProfileExportedObject>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileExportedObject' is not null or undefined
            assertParamExists('importIdentityProfiles', 'identityProfileExportedObject', identityProfileExportedObject)
            const localVarPath = `/identity-profiles/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(identityProfileExportedObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This returns a list of Identity Profiles based on the specified query parameters. A token with ORG_ADMIN or API authority is required to call this API to get a list of Identity Profiles.
         * @summary Identity Profiles List
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, ne*  **name**: *eq, ne*  **priority**: *eq, ne*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id**, **name**, **priority**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listIdentityProfiles: async (limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/identity-profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdentityProfilesApi - functional programming interface
 * @export
 */
export const IdentityProfilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdentityProfilesApiAxiosParamCreator(configuration)
    return {
        /**
         * This exports existing identity profiles in the format specified by the sp-config service.
         * @summary Export Identity Profiles
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, ne*  **name**: *eq, ne*  **priority**: *eq, ne*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id**, **name**, **priority**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async exportIdentityProfiles(limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IdentityProfileExportedObject>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportIdentityProfiles(limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This returns the default identity attribute config. A token with ORG_ADMIN authority is required to call this API to get the default identity attribute config.
         * @summary Get default Identity Attribute Config
         * @param {string} identityProfileId The Identity Profile ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultIdentityAttributeConfig(identityProfileId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityAttributeConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDefaultIdentityAttributeConfig(identityProfileId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This returns a single Identity Profile based on ID. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Get single Identity Profile
         * @param {string} identityProfileId The Identity Profile ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentityProfile(identityProfileId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentityProfile(identityProfileId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This imports previously exported identity profiles.
         * @summary Import Identity Profiles
         * @param {Array<IdentityProfileExportedObject>} identityProfileExportedObject Previously exported Identity Profiles.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async importIdentityProfiles(identityProfileExportedObject: Array<IdentityProfileExportedObject>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectImportResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importIdentityProfiles(identityProfileExportedObject, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This returns a list of Identity Profiles based on the specified query parameters. A token with ORG_ADMIN or API authority is required to call this API to get a list of Identity Profiles.
         * @summary Identity Profiles List
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, ne*  **name**: *eq, ne*  **priority**: *eq, ne*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id**, **name**, **priority**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listIdentityProfiles(limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IdentityProfile>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listIdentityProfiles(limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdentityProfilesApi - factory interface
 * @export
 */
export const IdentityProfilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdentityProfilesApiFp(configuration)
    return {
        /**
         * This exports existing identity profiles in the format specified by the sp-config service.
         * @summary Export Identity Profiles
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, ne*  **name**: *eq, ne*  **priority**: *eq, ne*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id**, **name**, **priority**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportIdentityProfiles(limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<IdentityProfileExportedObject>> {
            return localVarFp.exportIdentityProfiles(limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This returns the default identity attribute config. A token with ORG_ADMIN authority is required to call this API to get the default identity attribute config.
         * @summary Get default Identity Attribute Config
         * @param {string} identityProfileId The Identity Profile ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultIdentityAttributeConfig(identityProfileId: string, axiosOptions?: any): AxiosPromise<IdentityAttributeConfig> {
            return localVarFp.getDefaultIdentityAttributeConfig(identityProfileId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This returns a single Identity Profile based on ID. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Get single Identity Profile
         * @param {string} identityProfileId The Identity Profile ID.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityProfile(identityProfileId: string, axiosOptions?: any): AxiosPromise<IdentityProfile> {
            return localVarFp.getIdentityProfile(identityProfileId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This imports previously exported identity profiles.
         * @summary Import Identity Profiles
         * @param {Array<IdentityProfileExportedObject>} identityProfileExportedObject Previously exported Identity Profiles.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importIdentityProfiles(identityProfileExportedObject: Array<IdentityProfileExportedObject>, axiosOptions?: any): AxiosPromise<ObjectImportResult> {
            return localVarFp.importIdentityProfiles(identityProfileExportedObject, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This returns a list of Identity Profiles based on the specified query parameters. A token with ORG_ADMIN or API authority is required to call this API to get a list of Identity Profiles.
         * @summary Identity Profiles List
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, ne*  **name**: *eq, ne*  **priority**: *eq, ne*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id**, **name**, **priority**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listIdentityProfiles(limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<IdentityProfile>> {
            return localVarFp.listIdentityProfiles(limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for exportIdentityProfiles operation in IdentityProfilesApi.
 * @export
 * @interface IdentityProfilesApiExportIdentityProfilesRequest
 */
export interface IdentityProfilesApiExportIdentityProfilesRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IdentityProfilesApiExportIdentityProfiles
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IdentityProfilesApiExportIdentityProfiles
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof IdentityProfilesApiExportIdentityProfiles
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, ne*  **name**: *eq, ne*  **priority**: *eq, ne*
     * @type {string}
     * @memberof IdentityProfilesApiExportIdentityProfiles
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id**, **name**, **priority**
     * @type {string}
     * @memberof IdentityProfilesApiExportIdentityProfiles
     */
    readonly sorters?: string
}

/**
 * Request parameters for getDefaultIdentityAttributeConfig operation in IdentityProfilesApi.
 * @export
 * @interface IdentityProfilesApiGetDefaultIdentityAttributeConfigRequest
 */
export interface IdentityProfilesApiGetDefaultIdentityAttributeConfigRequest {
    /**
     * The Identity Profile ID.
     * @type {string}
     * @memberof IdentityProfilesApiGetDefaultIdentityAttributeConfig
     */
    readonly identityProfileId: string
}

/**
 * Request parameters for getIdentityProfile operation in IdentityProfilesApi.
 * @export
 * @interface IdentityProfilesApiGetIdentityProfileRequest
 */
export interface IdentityProfilesApiGetIdentityProfileRequest {
    /**
     * The Identity Profile ID.
     * @type {string}
     * @memberof IdentityProfilesApiGetIdentityProfile
     */
    readonly identityProfileId: string
}

/**
 * Request parameters for importIdentityProfiles operation in IdentityProfilesApi.
 * @export
 * @interface IdentityProfilesApiImportIdentityProfilesRequest
 */
export interface IdentityProfilesApiImportIdentityProfilesRequest {
    /**
     * Previously exported Identity Profiles.
     * @type {Array<IdentityProfileExportedObject>}
     * @memberof IdentityProfilesApiImportIdentityProfiles
     */
    readonly identityProfileExportedObject: Array<IdentityProfileExportedObject>
}

/**
 * Request parameters for listIdentityProfiles operation in IdentityProfilesApi.
 * @export
 * @interface IdentityProfilesApiListIdentityProfilesRequest
 */
export interface IdentityProfilesApiListIdentityProfilesRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IdentityProfilesApiListIdentityProfiles
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof IdentityProfilesApiListIdentityProfiles
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof IdentityProfilesApiListIdentityProfiles
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, ne*  **name**: *eq, ne*  **priority**: *eq, ne*
     * @type {string}
     * @memberof IdentityProfilesApiListIdentityProfiles
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **id**, **name**, **priority**
     * @type {string}
     * @memberof IdentityProfilesApiListIdentityProfiles
     */
    readonly sorters?: string
}

/**
 * IdentityProfilesApi - object-oriented interface
 * @export
 * @class IdentityProfilesApi
 * @extends {BaseAPI}
 */
export class IdentityProfilesApi extends BaseAPI {
    /**
     * This exports existing identity profiles in the format specified by the sp-config service.
     * @summary Export Identity Profiles
     * @param {IdentityProfilesApiExportIdentityProfilesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesApi
     */
    public exportIdentityProfiles(requestParameters: IdentityProfilesApiExportIdentityProfilesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return IdentityProfilesApiFp(this.configuration).exportIdentityProfiles(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This returns the default identity attribute config. A token with ORG_ADMIN authority is required to call this API to get the default identity attribute config.
     * @summary Get default Identity Attribute Config
     * @param {IdentityProfilesApiGetDefaultIdentityAttributeConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesApi
     */
    public getDefaultIdentityAttributeConfig(requestParameters: IdentityProfilesApiGetDefaultIdentityAttributeConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return IdentityProfilesApiFp(this.configuration).getDefaultIdentityAttributeConfig(requestParameters.identityProfileId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This returns a single Identity Profile based on ID. A token with ORG_ADMIN or API authority is required to call this API.
     * @summary Get single Identity Profile
     * @param {IdentityProfilesApiGetIdentityProfileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesApi
     */
    public getIdentityProfile(requestParameters: IdentityProfilesApiGetIdentityProfileRequest, axiosOptions?: AxiosRequestConfig) {
        return IdentityProfilesApiFp(this.configuration).getIdentityProfile(requestParameters.identityProfileId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This imports previously exported identity profiles.
     * @summary Import Identity Profiles
     * @param {IdentityProfilesApiImportIdentityProfilesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesApi
     */
    public importIdentityProfiles(requestParameters: IdentityProfilesApiImportIdentityProfilesRequest, axiosOptions?: AxiosRequestConfig) {
        return IdentityProfilesApiFp(this.configuration).importIdentityProfiles(requestParameters.identityProfileExportedObject, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This returns a list of Identity Profiles based on the specified query parameters. A token with ORG_ADMIN or API authority is required to call this API to get a list of Identity Profiles.
     * @summary Identity Profiles List
     * @param {IdentityProfilesApiListIdentityProfilesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProfilesApi
     */
    public listIdentityProfiles(requestParameters: IdentityProfilesApiListIdentityProfilesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return IdentityProfilesApiFp(this.configuration).listIdentityProfiles(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LifecycleStatesApi - axios parameter creator
 * @export
 */
export const LifecycleStatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API creates a new Lifecycle State. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Create Lifecycle State
         * @param {string} identityProfileId Identity Profile ID
         * @param {LifecycleState} lifecycleState Lifecycle State
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createLifecycleState: async (identityProfileId: string, lifecycleState: LifecycleState, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileId' is not null or undefined
            assertParamExists('createLifecycleState', 'identityProfileId', identityProfileId)
            // verify required parameter 'lifecycleState' is not null or undefined
            assertParamExists('createLifecycleState', 'lifecycleState', lifecycleState)
            const localVarPath = `/identity-profiles/{identity-profile-id}/lifecycle-states`
                .replace(`{${"identity-profile-id"}}`, encodeURIComponent(String(identityProfileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(lifecycleState, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint deletes the Lifecycle State using it\'s ID. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Delete Lifecycle State by ID
         * @param {string} identityProfileId Identity Profile ID
         * @param {string} lifecycleStateId Lifecycle State ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteLifecycleState: async (identityProfileId: string, lifecycleStateId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileId' is not null or undefined
            assertParamExists('deleteLifecycleState', 'identityProfileId', identityProfileId)
            // verify required parameter 'lifecycleStateId' is not null or undefined
            assertParamExists('deleteLifecycleState', 'lifecycleStateId', lifecycleStateId)
            const localVarPath = `/identity-profiles/{identity-profile-id}/lifecycle-states/{lifecycle-state-id}`
                .replace(`{${"identity-profile-id"}}`, encodeURIComponent(String(identityProfileId)))
                .replace(`{${"lifecycle-state-id"}}`, encodeURIComponent(String(lifecycleStateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves a Lifecycle State. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Retrieves Lifecycle State
         * @param {string} identityProfileId Identity Profile ID
         * @param {string} lifecycleStateId Lifecycle State ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLifecycleState: async (identityProfileId: string, lifecycleStateId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileId' is not null or undefined
            assertParamExists('getLifecycleState', 'identityProfileId', identityProfileId)
            // verify required parameter 'lifecycleStateId' is not null or undefined
            assertParamExists('getLifecycleState', 'lifecycleStateId', lifecycleStateId)
            const localVarPath = `/identity-profiles/{identity-profile-id}/lifecycle-states/{lifecycle-state-id}`
                .replace(`{${"identity-profile-id"}}`, encodeURIComponent(String(identityProfileId)))
                .replace(`{${"lifecycle-state-id"}}`, encodeURIComponent(String(lifecycleStateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point lists all the LifecycleStates associated with IdentityProfiles. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Lists LifecycleStates
         * @param {string} identityProfileId The IdentityProfile id
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listLifecycleStates: async (identityProfileId: string, limit?: number, offset?: number, count?: boolean, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileId' is not null or undefined
            assertParamExists('listLifecycleStates', 'identityProfileId', identityProfileId)
            const localVarPath = `/identity-profiles/{identity-profile-id}/lifecycle-states`
                .replace(`{${"identity-profile-id"}}`, encodeURIComponent(String(identityProfileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint will set/update an identity\'s lifecycle state to the one provided and updates the corresponding Identity Profile. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Set Lifecycle State
         * @param {string} identityId The ID of the identity to update
         * @param {SetLifecycleStateRequest} setLifecycleStateRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setLifecycleState: async (identityId: string, setLifecycleStateRequest: SetLifecycleStateRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('setLifecycleState', 'identityId', identityId)
            // verify required parameter 'setLifecycleStateRequest' is not null or undefined
            assertParamExists('setLifecycleState', 'setLifecycleStateRequest', setLifecycleStateRequest)
            const localVarPath = `/identities/{identity-id}/set-lifecycle-state`
                .replace(`{${"identity-id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setLifecycleStateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint updates individual Lifecycle State fields using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Update Lifecycle State
         * @param {string} identityProfileId Identity Profile ID
         * @param {string} lifecycleStateId Lifecycle State ID
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of lifecycle state update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields can be updated: * enabled * description * accountActions * accessProfileIds * emailNotificationOption 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateLifecycleStates: async (identityProfileId: string, lifecycleStateId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identityProfileId' is not null or undefined
            assertParamExists('updateLifecycleStates', 'identityProfileId', identityProfileId)
            // verify required parameter 'lifecycleStateId' is not null or undefined
            assertParamExists('updateLifecycleStates', 'lifecycleStateId', lifecycleStateId)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('updateLifecycleStates', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/identity-profiles/{identity-profile-id}/lifecycle-states/{lifecycle-state-id}`
                .replace(`{${"identity-profile-id"}}`, encodeURIComponent(String(identityProfileId)))
                .replace(`{${"lifecycle-state-id"}}`, encodeURIComponent(String(lifecycleStateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * LifecycleStatesApi - functional programming interface
 * @export
 */
export const LifecycleStatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LifecycleStatesApiAxiosParamCreator(configuration)
    return {
        /**
         * This API creates a new Lifecycle State. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Create Lifecycle State
         * @param {string} identityProfileId Identity Profile ID
         * @param {LifecycleState} lifecycleState Lifecycle State
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createLifecycleState(identityProfileId: string, lifecycleState: LifecycleState, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifecycleState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createLifecycleState(identityProfileId, lifecycleState, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint deletes the Lifecycle State using it\'s ID. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Delete Lifecycle State by ID
         * @param {string} identityProfileId Identity Profile ID
         * @param {string} lifecycleStateId Lifecycle State ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLifecycleState(identityProfileId: string, lifecycleStateId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseReferenceDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLifecycleState(identityProfileId, lifecycleStateId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint retrieves a Lifecycle State. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Retrieves Lifecycle State
         * @param {string} identityProfileId Identity Profile ID
         * @param {string} lifecycleStateId Lifecycle State ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getLifecycleState(identityProfileId: string, lifecycleStateId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifecycleState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLifecycleState(identityProfileId, lifecycleStateId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This end-point lists all the LifecycleStates associated with IdentityProfiles. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Lists LifecycleStates
         * @param {string} identityProfileId The IdentityProfile id
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listLifecycleStates(identityProfileId: string, limit?: number, offset?: number, count?: boolean, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LifecycleState>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLifecycleStates(identityProfileId, limit, offset, count, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint will set/update an identity\'s lifecycle state to the one provided and updates the corresponding Identity Profile. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Set Lifecycle State
         * @param {string} identityId The ID of the identity to update
         * @param {SetLifecycleStateRequest} setLifecycleStateRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async setLifecycleState(identityId: string, setLifecycleStateRequest: SetLifecycleStateRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetLifecycleState200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setLifecycleState(identityId, setLifecycleStateRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint updates individual Lifecycle State fields using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Update Lifecycle State
         * @param {string} identityProfileId Identity Profile ID
         * @param {string} lifecycleStateId Lifecycle State ID
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of lifecycle state update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields can be updated: * enabled * description * accountActions * accessProfileIds * emailNotificationOption 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateLifecycleStates(identityProfileId: string, lifecycleStateId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifecycleState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLifecycleStates(identityProfileId, lifecycleStateId, jsonPatchOperation, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LifecycleStatesApi - factory interface
 * @export
 */
export const LifecycleStatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LifecycleStatesApiFp(configuration)
    return {
        /**
         * This API creates a new Lifecycle State. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Create Lifecycle State
         * @param {string} identityProfileId Identity Profile ID
         * @param {LifecycleState} lifecycleState Lifecycle State
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createLifecycleState(identityProfileId: string, lifecycleState: LifecycleState, axiosOptions?: any): AxiosPromise<LifecycleState> {
            return localVarFp.createLifecycleState(identityProfileId, lifecycleState, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint deletes the Lifecycle State using it\'s ID. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Delete Lifecycle State by ID
         * @param {string} identityProfileId Identity Profile ID
         * @param {string} lifecycleStateId Lifecycle State ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteLifecycleState(identityProfileId: string, lifecycleStateId: string, axiosOptions?: any): AxiosPromise<BaseReferenceDto> {
            return localVarFp.deleteLifecycleState(identityProfileId, lifecycleStateId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint retrieves a Lifecycle State. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Retrieves Lifecycle State
         * @param {string} identityProfileId Identity Profile ID
         * @param {string} lifecycleStateId Lifecycle State ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLifecycleState(identityProfileId: string, lifecycleStateId: string, axiosOptions?: any): AxiosPromise<LifecycleState> {
            return localVarFp.getLifecycleState(identityProfileId, lifecycleStateId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This end-point lists all the LifecycleStates associated with IdentityProfiles. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Lists LifecycleStates
         * @param {string} identityProfileId The IdentityProfile id
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listLifecycleStates(identityProfileId: string, limit?: number, offset?: number, count?: boolean, sorters?: string, axiosOptions?: any): AxiosPromise<Array<LifecycleState>> {
            return localVarFp.listLifecycleStates(identityProfileId, limit, offset, count, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will set/update an identity\'s lifecycle state to the one provided and updates the corresponding Identity Profile. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Set Lifecycle State
         * @param {string} identityId The ID of the identity to update
         * @param {SetLifecycleStateRequest} setLifecycleStateRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setLifecycleState(identityId: string, setLifecycleStateRequest: SetLifecycleStateRequest, axiosOptions?: any): AxiosPromise<SetLifecycleState200Response> {
            return localVarFp.setLifecycleState(identityId, setLifecycleStateRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint updates individual Lifecycle State fields using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. A token with ORG_ADMIN or API authority is required to call this API.
         * @summary Update Lifecycle State
         * @param {string} identityProfileId Identity Profile ID
         * @param {string} lifecycleStateId Lifecycle State ID
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of lifecycle state update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields can be updated: * enabled * description * accountActions * accessProfileIds * emailNotificationOption 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateLifecycleStates(identityProfileId: string, lifecycleStateId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: any): AxiosPromise<LifecycleState> {
            return localVarFp.updateLifecycleStates(identityProfileId, lifecycleStateId, jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createLifecycleState operation in LifecycleStatesApi.
 * @export
 * @interface LifecycleStatesApiCreateLifecycleStateRequest
 */
export interface LifecycleStatesApiCreateLifecycleStateRequest {
    /**
     * Identity Profile ID
     * @type {string}
     * @memberof LifecycleStatesApiCreateLifecycleState
     */
    readonly identityProfileId: string

    /**
     * Lifecycle State
     * @type {LifecycleState}
     * @memberof LifecycleStatesApiCreateLifecycleState
     */
    readonly lifecycleState: LifecycleState
}

/**
 * Request parameters for deleteLifecycleState operation in LifecycleStatesApi.
 * @export
 * @interface LifecycleStatesApiDeleteLifecycleStateRequest
 */
export interface LifecycleStatesApiDeleteLifecycleStateRequest {
    /**
     * Identity Profile ID
     * @type {string}
     * @memberof LifecycleStatesApiDeleteLifecycleState
     */
    readonly identityProfileId: string

    /**
     * Lifecycle State ID
     * @type {string}
     * @memberof LifecycleStatesApiDeleteLifecycleState
     */
    readonly lifecycleStateId: string
}

/**
 * Request parameters for getLifecycleState operation in LifecycleStatesApi.
 * @export
 * @interface LifecycleStatesApiGetLifecycleStateRequest
 */
export interface LifecycleStatesApiGetLifecycleStateRequest {
    /**
     * Identity Profile ID
     * @type {string}
     * @memberof LifecycleStatesApiGetLifecycleState
     */
    readonly identityProfileId: string

    /**
     * Lifecycle State ID
     * @type {string}
     * @memberof LifecycleStatesApiGetLifecycleState
     */
    readonly lifecycleStateId: string
}

/**
 * Request parameters for listLifecycleStates operation in LifecycleStatesApi.
 * @export
 * @interface LifecycleStatesApiListLifecycleStatesRequest
 */
export interface LifecycleStatesApiListLifecycleStatesRequest {
    /**
     * The IdentityProfile id
     * @type {string}
     * @memberof LifecycleStatesApiListLifecycleStates
     */
    readonly identityProfileId: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof LifecycleStatesApiListLifecycleStates
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof LifecycleStatesApiListLifecycleStates
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof LifecycleStatesApiListLifecycleStates
     */
    readonly count?: boolean

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **created, modified**
     * @type {string}
     * @memberof LifecycleStatesApiListLifecycleStates
     */
    readonly sorters?: string
}

/**
 * Request parameters for setLifecycleState operation in LifecycleStatesApi.
 * @export
 * @interface LifecycleStatesApiSetLifecycleStateRequest
 */
export interface LifecycleStatesApiSetLifecycleStateRequest {
    /**
     * The ID of the identity to update
     * @type {string}
     * @memberof LifecycleStatesApiSetLifecycleState
     */
    readonly identityId: string

    /**
     * 
     * @type {SetLifecycleStateRequest}
     * @memberof LifecycleStatesApiSetLifecycleState
     */
    readonly setLifecycleStateRequest: SetLifecycleStateRequest
}

/**
 * Request parameters for updateLifecycleStates operation in LifecycleStatesApi.
 * @export
 * @interface LifecycleStatesApiUpdateLifecycleStatesRequest
 */
export interface LifecycleStatesApiUpdateLifecycleStatesRequest {
    /**
     * Identity Profile ID
     * @type {string}
     * @memberof LifecycleStatesApiUpdateLifecycleStates
     */
    readonly identityProfileId: string

    /**
     * Lifecycle State ID
     * @type {string}
     * @memberof LifecycleStatesApiUpdateLifecycleStates
     */
    readonly lifecycleStateId: string

    /**
     * A list of lifecycle state update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields can be updated: * enabled * description * accountActions * accessProfileIds * emailNotificationOption 
     * @type {Array<JsonPatchOperation>}
     * @memberof LifecycleStatesApiUpdateLifecycleStates
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * LifecycleStatesApi - object-oriented interface
 * @export
 * @class LifecycleStatesApi
 * @extends {BaseAPI}
 */
export class LifecycleStatesApi extends BaseAPI {
    /**
     * This API creates a new Lifecycle State. A token with ORG_ADMIN or API authority is required to call this API.
     * @summary Create Lifecycle State
     * @param {LifecycleStatesApiCreateLifecycleStateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecycleStatesApi
     */
    public createLifecycleState(requestParameters: LifecycleStatesApiCreateLifecycleStateRequest, axiosOptions?: AxiosRequestConfig) {
        return LifecycleStatesApiFp(this.configuration).createLifecycleState(requestParameters.identityProfileId, requestParameters.lifecycleState, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint deletes the Lifecycle State using it\'s ID. A token with API, or ORG_ADMIN authority is required to call this API.
     * @summary Delete Lifecycle State by ID
     * @param {LifecycleStatesApiDeleteLifecycleStateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecycleStatesApi
     */
    public deleteLifecycleState(requestParameters: LifecycleStatesApiDeleteLifecycleStateRequest, axiosOptions?: AxiosRequestConfig) {
        return LifecycleStatesApiFp(this.configuration).deleteLifecycleState(requestParameters.identityProfileId, requestParameters.lifecycleStateId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint retrieves a Lifecycle State. A token with ORG_ADMIN or API authority is required to call this API.
     * @summary Retrieves Lifecycle State
     * @param {LifecycleStatesApiGetLifecycleStateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecycleStatesApi
     */
    public getLifecycleState(requestParameters: LifecycleStatesApiGetLifecycleStateRequest, axiosOptions?: AxiosRequestConfig) {
        return LifecycleStatesApiFp(this.configuration).getLifecycleState(requestParameters.identityProfileId, requestParameters.lifecycleStateId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point lists all the LifecycleStates associated with IdentityProfiles. A token with API, or ORG_ADMIN authority is required to call this API.
     * @summary Lists LifecycleStates
     * @param {LifecycleStatesApiListLifecycleStatesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecycleStatesApi
     */
    public listLifecycleStates(requestParameters: LifecycleStatesApiListLifecycleStatesRequest, axiosOptions?: AxiosRequestConfig) {
        return LifecycleStatesApiFp(this.configuration).listLifecycleStates(requestParameters.identityProfileId, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint will set/update an identity\'s lifecycle state to the one provided and updates the corresponding Identity Profile. A token with ORG_ADMIN or API authority is required to call this API.
     * @summary Set Lifecycle State
     * @param {LifecycleStatesApiSetLifecycleStateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecycleStatesApi
     */
    public setLifecycleState(requestParameters: LifecycleStatesApiSetLifecycleStateRequest, axiosOptions?: AxiosRequestConfig) {
        return LifecycleStatesApiFp(this.configuration).setLifecycleState(requestParameters.identityId, requestParameters.setLifecycleStateRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint updates individual Lifecycle State fields using the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. A token with ORG_ADMIN or API authority is required to call this API.
     * @summary Update Lifecycle State
     * @param {LifecycleStatesApiUpdateLifecycleStatesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LifecycleStatesApi
     */
    public updateLifecycleStates(requestParameters: LifecycleStatesApiUpdateLifecycleStatesRequest, axiosOptions?: AxiosRequestConfig) {
        return LifecycleStatesApiFp(this.configuration).updateLifecycleStates(requestParameters.identityProfileId, requestParameters.lifecycleStateId, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NonEmployeeLifecycleManagementApi - axios parameter creator
 * @export
 */
export const NonEmployeeLifecycleManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API creates a new schema attribute for Non-Employee Source. The schema technical name must be unique in the source. Attempts to create a schema attribute with an existing name will result in a \"400.1.409 Reference conflict\" response. At most, 10 custom attributes can be created per schema. Attempts to create more than 10 will result in a \"400.1.4 Limit violation\" response. Requires role context of `idn:nesr:create`
         * @summary Create a new Schema Attribute for Non-Employee Source
         * @param {string} sourceId The Source id
         * @param {NonEmployeeSchemaAttributeBody} nonEmployeeSchemaAttributeBody 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSchemaAttribute: async (sourceId: string, nonEmployeeSchemaAttributeBody: NonEmployeeSchemaAttributeBody, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('createSchemaAttribute', 'sourceId', sourceId)
            // verify required parameter 'nonEmployeeSchemaAttributeBody' is not null or undefined
            assertParamExists('createSchemaAttribute', 'nonEmployeeSchemaAttributeBody', nonEmployeeSchemaAttributeBody)
            const localVarPath = `/non-employee-sources/{sourceId}/schema-attributes`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nonEmployeeSchemaAttributeBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point deletes a specific schema attribute for a non-employee source. Requires role context of `idn:nesr:delete` 
         * @summary Delete a Schema Attribute for Non-Employee Source
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSchemaAttribute: async (attributeId: string, sourceId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attributeId' is not null or undefined
            assertParamExists('deleteSchemaAttribute', 'attributeId', attributeId)
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('deleteSchemaAttribute', 'sourceId', sourceId)
            const localVarPath = `/non-employee-sources/{sourceId}/schema-attributes/{attributeId}`
                .replace(`{${"attributeId"}}`, encodeURIComponent(String(attributeId)))
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point deletes all custom schema attributes for a non-employee source. Requires role context of `idn:nesr:delete`
         * @summary Delete all custom schema attributes for Non-Employee Source
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSchemaAttributes: async (sourceId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('deleteSchemaAttributes', 'sourceId', sourceId)
            const localVarPath = `/non-employee-sources/{sourceId}/schema-attributes`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API gets a schema attribute by Id for the specified Non-Employee SourceId. Requires role context of `idn:nesr:read` or the user must be an account manager of the source.
         * @summary Get Schema Attribute Non-Employee Source
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSchemaAttribute: async (attributeId: string, sourceId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attributeId' is not null or undefined
            assertParamExists('getSchemaAttribute', 'attributeId', attributeId)
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('getSchemaAttribute', 'sourceId', sourceId)
            const localVarPath = `/non-employee-sources/{sourceId}/schema-attributes/{attributeId}`
                .replace(`{${"attributeId"}}`, encodeURIComponent(String(attributeId)))
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API gets the list of schema attributes for the specified Non-Employee SourceId. There are 8 mandatory attributes added to each new Non-Employee Source automatically. Additionaly, user can add up to 10 custom attributes. This interface returns all the mandatory attributes followed by any custom attributes. At most, a total of 18 attributes will be returned. Requires role context of `idn:nesr:read` or the user must be an account manager of the source.
         * @summary List Schema Attributes Non-Employee Source
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSchemaAttributes: async (sourceId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('getSchemaAttributes', 'sourceId', sourceId)
            const localVarPath = `/non-employee-sources/{sourceId}/schema-attributes`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Gets a non-employee approval item detail. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can get any approval.   2. The user owns the requested approval.
         * @summary Get a non-employee approval item detail
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {boolean} [includeDetail] The object nonEmployeeRequest will not be included detail when set to false. *Default value is true*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        nonEmployeeApprovalGet: async (id: string, includeDetail?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('nonEmployeeApprovalGet', 'id', id)
            const localVarPath = `/non-employee-approvals/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (includeDetail !== undefined) {
                localVarQueryParameter['include-detail'] = includeDetail;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a list of non-employee approval requests. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can list the approvals for any approver.   2. The user owns the requested approval.
         * @summary Get List of Non-Employee Approval Requests
         * @param {string} [requestedFor] The identity for whom the request was made. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407) Filtering is supported for the following fields and operators: **approvalStatus**: *eq*  *Example:* approvalStatus eq \&quot;PENDING\&quot;
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407#toc-hId-2058949) Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        nonEmployeeApprovalList: async (requestedFor?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/non-employee-approvals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (requestedFor !== undefined) {
                localVarQueryParameter['requested-for'] = requestedFor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will retrieve a summary of non-employee approval requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a summary of all non-employee approval requests assigned to a particular approver by passing in that approver\'s id.   2. The current user is an approver, in which case \"me\" should be provided as the `requested-for` value. This will provide the approver with a summary of the approval items assigned to him or her.
         * @summary Get Summary of Non-Employee Approval Requests
         * @param {string} requestedFor The identity (UUID) of the approver for whom for whom the summary is being retrieved. Use \&quot;me\&quot; instead to indicate the current user.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        nonEmployeeApprovalSummary: async (requestedFor: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestedFor' is not null or undefined
            assertParamExists('nonEmployeeApprovalSummary', 'requestedFor', requestedFor)
            const localVarPath = `/non-employee-approvals/summary/{requested-for}`
                .replace(`{${"requested-for"}}`, encodeURIComponent(String(requestedFor)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Approves a non-employee approval request and notifies the next approver. The current user must be the requested approver.
         * @summary Approve a Non-Employee Request
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {NonEmployeeApprovalDecision} nonEmployeeApprovalDecision 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        nonEmployeeApproveRequest: async (id: string, nonEmployeeApprovalDecision: NonEmployeeApprovalDecision, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('nonEmployeeApproveRequest', 'id', id)
            // verify required parameter 'nonEmployeeApprovalDecision' is not null or undefined
            assertParamExists('nonEmployeeApproveRequest', 'nonEmployeeApprovalDecision', nonEmployeeApprovalDecision)
            const localVarPath = `/non-employee-approvals/{id}/approve`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nonEmployeeApprovalDecision, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * The nonEmployeeBulkUploadStatus API returns the status of the newest bulk upload job for the specified source. Requires role context of `idn:nesr:read` 
         * @summary Obtain the status of bulk upload on the source
         * @param {string} id Source ID (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        nonEmployeeBulkUploadStatus: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('nonEmployeeBulkUploadStatus', 'id', id)
            const localVarPath = `/non-employee-sources/{id}/non-employee-bulk-upload/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This requests a download for the Source Schema Template for a provided source. Requires role context of `idn:nesr:read`
         * @summary Exports Source Schema Template
         * @param {string} id Source Id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        nonEmployeeExportSourceSchemaTemplate: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('nonEmployeeExportSourceSchemaTemplate', 'id', id)
            const localVarPath = `/non-employee-sources/{id}/schema-attributes-template/download`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will delete multiple non-employee records based on the non-employee ids provided. Requires role context of `idn:nesr:delete`
         * @summary Delete Multiple Non-Employee Records
         * @param {NonEmployeeRecordBulkDeleteRequest} nonEmployeeRecordBulkDeleteRequest Non-Employee bulk delete request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        nonEmployeeRecordBulkDelete: async (nonEmployeeRecordBulkDeleteRequest: NonEmployeeRecordBulkDeleteRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nonEmployeeRecordBulkDeleteRequest' is not null or undefined
            assertParamExists('nonEmployeeRecordBulkDelete', 'nonEmployeeRecordBulkDeleteRequest', nonEmployeeRecordBulkDeleteRequest)
            const localVarPath = `/non-employee-records/bulk-delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nonEmployeeRecordBulkDeleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will create a non-employee record. Requires role context of `idn:nesr:create`
         * @summary Create Non-Employee Record
         * @param {NonEmployeeRequestBody} nonEmployeeRequestBody Non-Employee record creation request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        nonEmployeeRecordCreation: async (nonEmployeeRequestBody: NonEmployeeRequestBody, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nonEmployeeRequestBody' is not null or undefined
            assertParamExists('nonEmployeeRecordCreation', 'nonEmployeeRequestBody', nonEmployeeRequestBody)
            const localVarPath = `/non-employee-records`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nonEmployeeRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will delete a non-employee record. Requires role context of `idn:nesr:delete`
         * @summary Delete Non-Employee Record
         * @param {string} id Non-Employee record id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        nonEmployeeRecordDelete: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('nonEmployeeRecordDelete', 'id', id)
            const localVarPath = `/non-employee-records/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a non-employee record. Requires role context of `idn:nesr:read`
         * @summary Get a Non-Employee Record
         * @param {string} id Non-Employee record id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        nonEmployeeRecordGet: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('nonEmployeeRecordGet', 'id', id)
            const localVarPath = `/non-employee-records/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a list of non-employee records. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can get a list of all of the non-employees.   2. The user is an account manager, in which case they can get a list of the non-employees that they manage.
         * @summary List Non-Employee Records
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407#toc-hId-2058949) Sorting is supported for the following fields: **id, accountName, sourceId, manager, firstName, lastName, email, phone, startDate, endDate, created, modified**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407) Filtering is supported for the following fields and operators: **sourceId**: *eq*  *Example:* sourceId eq \&quot;2c91808568c529c60168cca6f90c1313\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        nonEmployeeRecordList: async (limit?: number, offset?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/non-employee-records`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will patch a non-employee record. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:update`, in which case they update all available fields.   2. The user is owner of the source, in this case they can only update the end date.
         * @summary Patch Non-Employee Record
         * @param {string} id Non-employee record id (UUID)
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of non-employee update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Attributes are restricted by user type. Owner of source can update end date. Organization admins can update all available fields.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        nonEmployeeRecordPatch: async (id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('nonEmployeeRecordPatch', 'id', id)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('nonEmployeeRecordPatch', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/non-employee-records/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will update a non-employee record. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:update`, in which case they update all available fields.   2. The user is owner of the source, in this case they can only update the end date.
         * @summary Update Non-Employee Record
         * @param {string} id Non-employee record id (UUID)
         * @param {NonEmployeeRequestBody} nonEmployeeRequestBody Non-employee record creation request body. Attributes are restricted by user type. Owner of source can update end date. Organization admins can update all available fields.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        nonEmployeeRecordUpdate: async (id: string, nonEmployeeRequestBody: NonEmployeeRequestBody, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('nonEmployeeRecordUpdate', 'id', id)
            // verify required parameter 'nonEmployeeRequestBody' is not null or undefined
            assertParamExists('nonEmployeeRecordUpdate', 'nonEmployeeRequestBody', nonEmployeeRequestBody)
            const localVarPath = `/non-employee-records/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nonEmployeeRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This post will import, or update, Non-Employee records found in the CSV. Requires role context of `idn:nesr:create`
         * @summary Imports, or Updates, Non-Employee Records
         * @param {string} id Source Id (UUID)
         * @param {string} data 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        nonEmployeeRecordsBulkUpload: async (id: string, data: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('nonEmployeeRecordsBulkUpload', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('nonEmployeeRecordsBulkUpload', 'data', data)
            const localVarPath = `/non-employee-sources/{id}/non-employee-bulk-upload`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


            if (data !== undefined) { 
                localVarFormParams.append('data', data as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This requests a CSV download for all non-employees from a provided source. Requires role context of `idn:nesr:read`
         * @summary Exports Non-Employee Records to CSV
         * @param {string} id Source Id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        nonEmployeeRecordsExport: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('nonEmployeeRecordsExport', 'id', id)
            const localVarPath = `/non-employee-sources/{id}/non-employees/download`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint will reject an approval item request and notify user. The current user must be the requested approver.
         * @summary Reject a Non-Employee Request
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {NonEmployeeRejectApprovalDecision} nonEmployeeRejectApprovalDecision 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        nonEmployeeRejectRequest: async (id: string, nonEmployeeRejectApprovalDecision: NonEmployeeRejectApprovalDecision, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('nonEmployeeRejectRequest', 'id', id)
            // verify required parameter 'nonEmployeeRejectApprovalDecision' is not null or undefined
            assertParamExists('nonEmployeeRejectRequest', 'nonEmployeeRejectApprovalDecision', nonEmployeeRejectApprovalDecision)
            const localVarPath = `/non-employee-approvals/{id}/reject`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nonEmployeeRejectApprovalDecision, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will create a non-employee request and notify the approver. Requires role context of `idn:nesr:create` or the user must own the source.
         * @summary Create Non-Employee Request
         * @param {NonEmployeeRequestBody} nonEmployeeRequestBody Non-Employee creation request body
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        nonEmployeeRequestCreation: async (nonEmployeeRequestBody: NonEmployeeRequestBody, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nonEmployeeRequestBody' is not null or undefined
            assertParamExists('nonEmployeeRequestCreation', 'nonEmployeeRequestBody', nonEmployeeRequestBody)
            const localVarPath = `/non-employee-requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nonEmployeeRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will delete a non-employee request.  Requires role context of `idn:nesr:delete`
         * @summary Delete Non-Employee Request
         * @param {string} id Non-Employee request id in the UUID format
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        nonEmployeeRequestDeletion: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('nonEmployeeRequestDeletion', 'id', id)
            const localVarPath = `/non-employee-requests/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a non-employee request. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in this case the user can get the non-employee request for any user.   2. The user must be the owner of the non-employee request.
         * @summary Get a Non-Employee Request
         * @param {string} id Non-Employee request id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        nonEmployeeRequestGet: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('nonEmployeeRequestGet', 'id', id)
            const localVarPath = `/non-employee-requests/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a list of non-employee requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a list non-employee requests assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a list of the non-employee requests in the source(s) he or she manages.
         * @summary List Non-Employee Requests
         * @param {string} requestedFor The identity for whom the request was made. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407#toc-hId-2058949) Sorting is supported for the following fields: **created, approvalStatus, firstName, lastName, email, phone, accountName, startDate, endDate**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407) Filtering is supported for the following fields and operators: **sourceId**: *eq*  *Example:* sourceId eq \&quot;2c91808568c529c60168cca6f90c1313\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        nonEmployeeRequestList: async (requestedFor: string, limit?: number, offset?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestedFor' is not null or undefined
            assertParamExists('nonEmployeeRequestList', 'requestedFor', requestedFor)
            const localVarPath = `/non-employee-requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (requestedFor !== undefined) {
                localVarQueryParameter['requested-for'] = requestedFor;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will retrieve a summary of non-employee requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a summary of all non-employee approval requests assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a summary of the non-employee requests in the source(s) he or she manages.
         * @summary Get Summary of Non-Employee Requests
         * @param {string} requestedFor The identity (UUID) of the non-employee account manager for whom the summary is being retrieved. Use \&quot;me\&quot; instead to indicate the current user.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        nonEmployeeRequestSummaryGet: async (requestedFor: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestedFor' is not null or undefined
            assertParamExists('nonEmployeeRequestSummaryGet', 'requestedFor', requestedFor)
            const localVarPath = `/non-employee-requests/summary/{requested-for}`
                .replace(`{${"requested-for"}}`, encodeURIComponent(String(requestedFor)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will delete a non-employee source. Requires role context of `idn:nesr:delete`.
         * @summary Delete Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        nonEmployeeSourceDelete: async (sourceId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('nonEmployeeSourceDelete', 'sourceId', sourceId)
            const localVarPath = `/non-employee-sources/{sourceId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a non-employee source. There are two contextual uses for the requested-for path parameter:    1. The user has the role context of `idn:nesr:read`, in which case he or she may request any source.   2. The current user is an account manager, in which case the user can only request sources that they own.
         * @summary Get a Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        nonEmployeeSourceGet: async (sourceId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('nonEmployeeSourceGet', 'sourceId', sourceId)
            const localVarPath = `/non-employee-sources/{sourceId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * patch a non-employee source. (partial update) <br/> Patchable field: **name, description, approvers, accountManagers** Requires role context of `idn:nesr:update`.
         * @summary Patch a Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of non-employee source update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        nonEmployeeSourcePatch: async (sourceId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('nonEmployeeSourcePatch', 'sourceId', sourceId)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('nonEmployeeSourcePatch', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/non-employee-sources/{sourceId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This request will create a non-employee source. Requires role context of `idn:nesr:create`
         * @summary Create Non-Employee Source
         * @param {NonEmployeeSourceRequestBody} nonEmployeeSourceRequestBody Non-Employee source creation request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        nonEmployeeSourcesCreation: async (nonEmployeeSourceRequestBody: NonEmployeeSourceRequestBody, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nonEmployeeSourceRequestBody' is not null or undefined
            assertParamExists('nonEmployeeSourcesCreation', 'nonEmployeeSourceRequestBody', nonEmployeeSourceRequestBody)
            const localVarPath = `/non-employee-sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nonEmployeeSourceRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a list of non-employee sources. There are two contextual uses for the requested-for path parameter:    1. The user has the role context of `idn:nesr:read`, in which case he or she may request a list sources assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a list of the sources that he or she owns.
         * @summary List Non-Employee Sources
         * @param {string} requestedFor The identity for whom the request was made. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [nonEmployeeCount] The flag to determine whether return a non-employee count associate with source.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407#toc-hId-2058949) Sorting is supported for the following fields: **name, created**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        nonEmployeeSourcesList: async (requestedFor: string, limit?: number, offset?: number, count?: boolean, nonEmployeeCount?: boolean, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestedFor' is not null or undefined
            assertParamExists('nonEmployeeSourcesList', 'requestedFor', requestedFor)
            const localVarPath = `/non-employee-sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (requestedFor !== undefined) {
                localVarQueryParameter['requested-for'] = requestedFor;
            }

            if (nonEmployeeCount !== undefined) {
                localVarQueryParameter['non-employee-count'] = nonEmployeeCount;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point patches a specific schema attribute for a non-employee SourceId. Requires role context of `idn:nesr:update` 
         * @summary Patch a Schema Attribute for Non-Employee Source
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of schema attribute update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. The following properties are allowed for update \&#39;:\&#39; \&#39;label\&#39;, \&#39;helpText\&#39;, \&#39;placeholder\&#39;, \&#39;required\&#39;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchSchemaAttribute: async (attributeId: string, sourceId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attributeId' is not null or undefined
            assertParamExists('patchSchemaAttribute', 'attributeId', attributeId)
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('patchSchemaAttribute', 'sourceId', sourceId)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('patchSchemaAttribute', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/non-employee-sources/{sourceId}/schema-attributes/{attributeId}`
                .replace(`{${"attributeId"}}`, encodeURIComponent(String(attributeId)))
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * NonEmployeeLifecycleManagementApi - functional programming interface
 * @export
 */
export const NonEmployeeLifecycleManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NonEmployeeLifecycleManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * This API creates a new schema attribute for Non-Employee Source. The schema technical name must be unique in the source. Attempts to create a schema attribute with an existing name will result in a \"400.1.409 Reference conflict\" response. At most, 10 custom attributes can be created per schema. Attempts to create more than 10 will result in a \"400.1.4 Limit violation\" response. Requires role context of `idn:nesr:create`
         * @summary Create a new Schema Attribute for Non-Employee Source
         * @param {string} sourceId The Source id
         * @param {NonEmployeeSchemaAttributeBody} nonEmployeeSchemaAttributeBody 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createSchemaAttribute(sourceId: string, nonEmployeeSchemaAttributeBody: NonEmployeeSchemaAttributeBody, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeSchemaAttribute>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSchemaAttribute(sourceId, nonEmployeeSchemaAttributeBody, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This end-point deletes a specific schema attribute for a non-employee source. Requires role context of `idn:nesr:delete` 
         * @summary Delete a Schema Attribute for Non-Employee Source
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSchemaAttribute(attributeId: string, sourceId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSchemaAttribute(attributeId, sourceId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This end-point deletes all custom schema attributes for a non-employee source. Requires role context of `idn:nesr:delete`
         * @summary Delete all custom schema attributes for Non-Employee Source
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSchemaAttributes(sourceId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSchemaAttributes(sourceId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API gets a schema attribute by Id for the specified Non-Employee SourceId. Requires role context of `idn:nesr:read` or the user must be an account manager of the source.
         * @summary Get Schema Attribute Non-Employee Source
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSchemaAttribute(attributeId: string, sourceId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeSchemaAttribute>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSchemaAttribute(attributeId, sourceId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API gets the list of schema attributes for the specified Non-Employee SourceId. There are 8 mandatory attributes added to each new Non-Employee Source automatically. Additionaly, user can add up to 10 custom attributes. This interface returns all the mandatory attributes followed by any custom attributes. At most, a total of 18 attributes will be returned. Requires role context of `idn:nesr:read` or the user must be an account manager of the source.
         * @summary List Schema Attributes Non-Employee Source
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSchemaAttributes(sourceId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NonEmployeeSchemaAttribute>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSchemaAttributes(sourceId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a non-employee approval item detail. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can get any approval.   2. The user owns the requested approval.
         * @summary Get a non-employee approval item detail
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {boolean} [includeDetail] The object nonEmployeeRequest will not be included detail when set to false. *Default value is true*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async nonEmployeeApprovalGet(id: string, includeDetail?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeApprovalItemDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nonEmployeeApprovalGet(id, includeDetail, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a list of non-employee approval requests. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can list the approvals for any approver.   2. The user owns the requested approval.
         * @summary Get List of Non-Employee Approval Requests
         * @param {string} [requestedFor] The identity for whom the request was made. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407) Filtering is supported for the following fields and operators: **approvalStatus**: *eq*  *Example:* approvalStatus eq \&quot;PENDING\&quot;
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407#toc-hId-2058949) Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async nonEmployeeApprovalList(requestedFor?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NonEmployeeApprovalItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nonEmployeeApprovalList(requestedFor, limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This request will retrieve a summary of non-employee approval requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a summary of all non-employee approval requests assigned to a particular approver by passing in that approver\'s id.   2. The current user is an approver, in which case \"me\" should be provided as the `requested-for` value. This will provide the approver with a summary of the approval items assigned to him or her.
         * @summary Get Summary of Non-Employee Approval Requests
         * @param {string} requestedFor The identity (UUID) of the approver for whom for whom the summary is being retrieved. Use \&quot;me\&quot; instead to indicate the current user.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async nonEmployeeApprovalSummary(requestedFor: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeApprovalSummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nonEmployeeApprovalSummary(requestedFor, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Approves a non-employee approval request and notifies the next approver. The current user must be the requested approver.
         * @summary Approve a Non-Employee Request
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {NonEmployeeApprovalDecision} nonEmployeeApprovalDecision 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async nonEmployeeApproveRequest(id: string, nonEmployeeApprovalDecision: NonEmployeeApprovalDecision, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeApprovalItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nonEmployeeApproveRequest(id, nonEmployeeApprovalDecision, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The nonEmployeeBulkUploadStatus API returns the status of the newest bulk upload job for the specified source. Requires role context of `idn:nesr:read` 
         * @summary Obtain the status of bulk upload on the source
         * @param {string} id Source ID (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async nonEmployeeBulkUploadStatus(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeBulkUploadStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nonEmployeeBulkUploadStatus(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This requests a download for the Source Schema Template for a provided source. Requires role context of `idn:nesr:read`
         * @summary Exports Source Schema Template
         * @param {string} id Source Id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async nonEmployeeExportSourceSchemaTemplate(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nonEmployeeExportSourceSchemaTemplate(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This request will delete multiple non-employee records based on the non-employee ids provided. Requires role context of `idn:nesr:delete`
         * @summary Delete Multiple Non-Employee Records
         * @param {NonEmployeeRecordBulkDeleteRequest} nonEmployeeRecordBulkDeleteRequest Non-Employee bulk delete request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async nonEmployeeRecordBulkDelete(nonEmployeeRecordBulkDeleteRequest: NonEmployeeRecordBulkDeleteRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nonEmployeeRecordBulkDelete(nonEmployeeRecordBulkDeleteRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This request will create a non-employee record. Requires role context of `idn:nesr:create`
         * @summary Create Non-Employee Record
         * @param {NonEmployeeRequestBody} nonEmployeeRequestBody Non-Employee record creation request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async nonEmployeeRecordCreation(nonEmployeeRequestBody: NonEmployeeRequestBody, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nonEmployeeRecordCreation(nonEmployeeRequestBody, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This request will delete a non-employee record. Requires role context of `idn:nesr:delete`
         * @summary Delete Non-Employee Record
         * @param {string} id Non-Employee record id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async nonEmployeeRecordDelete(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nonEmployeeRecordDelete(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a non-employee record. Requires role context of `idn:nesr:read`
         * @summary Get a Non-Employee Record
         * @param {string} id Non-Employee record id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async nonEmployeeRecordGet(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nonEmployeeRecordGet(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a list of non-employee records. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can get a list of all of the non-employees.   2. The user is an account manager, in which case they can get a list of the non-employees that they manage.
         * @summary List Non-Employee Records
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407#toc-hId-2058949) Sorting is supported for the following fields: **id, accountName, sourceId, manager, firstName, lastName, email, phone, startDate, endDate, created, modified**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407) Filtering is supported for the following fields and operators: **sourceId**: *eq*  *Example:* sourceId eq \&quot;2c91808568c529c60168cca6f90c1313\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async nonEmployeeRecordList(limit?: number, offset?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NonEmployeeRecord>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nonEmployeeRecordList(limit, offset, count, sorters, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This request will patch a non-employee record. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:update`, in which case they update all available fields.   2. The user is owner of the source, in this case they can only update the end date.
         * @summary Patch Non-Employee Record
         * @param {string} id Non-employee record id (UUID)
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of non-employee update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Attributes are restricted by user type. Owner of source can update end date. Organization admins can update all available fields.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async nonEmployeeRecordPatch(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nonEmployeeRecordPatch(id, jsonPatchOperation, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This request will update a non-employee record. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:update`, in which case they update all available fields.   2. The user is owner of the source, in this case they can only update the end date.
         * @summary Update Non-Employee Record
         * @param {string} id Non-employee record id (UUID)
         * @param {NonEmployeeRequestBody} nonEmployeeRequestBody Non-employee record creation request body. Attributes are restricted by user type. Owner of source can update end date. Organization admins can update all available fields.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async nonEmployeeRecordUpdate(id: string, nonEmployeeRequestBody: NonEmployeeRequestBody, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nonEmployeeRecordUpdate(id, nonEmployeeRequestBody, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This post will import, or update, Non-Employee records found in the CSV. Requires role context of `idn:nesr:create`
         * @summary Imports, or Updates, Non-Employee Records
         * @param {string} id Source Id (UUID)
         * @param {string} data 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async nonEmployeeRecordsBulkUpload(id: string, data: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeBulkUploadJob>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nonEmployeeRecordsBulkUpload(id, data, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This requests a CSV download for all non-employees from a provided source. Requires role context of `idn:nesr:read`
         * @summary Exports Non-Employee Records to CSV
         * @param {string} id Source Id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async nonEmployeeRecordsExport(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nonEmployeeRecordsExport(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint will reject an approval item request and notify user. The current user must be the requested approver.
         * @summary Reject a Non-Employee Request
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {NonEmployeeRejectApprovalDecision} nonEmployeeRejectApprovalDecision 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async nonEmployeeRejectRequest(id: string, nonEmployeeRejectApprovalDecision: NonEmployeeRejectApprovalDecision, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeApprovalItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nonEmployeeRejectRequest(id, nonEmployeeRejectApprovalDecision, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This request will create a non-employee request and notify the approver. Requires role context of `idn:nesr:create` or the user must own the source.
         * @summary Create Non-Employee Request
         * @param {NonEmployeeRequestBody} nonEmployeeRequestBody Non-Employee creation request body
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async nonEmployeeRequestCreation(nonEmployeeRequestBody: NonEmployeeRequestBody, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nonEmployeeRequestCreation(nonEmployeeRequestBody, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This request will delete a non-employee request.  Requires role context of `idn:nesr:delete`
         * @summary Delete Non-Employee Request
         * @param {string} id Non-Employee request id in the UUID format
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async nonEmployeeRequestDeletion(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nonEmployeeRequestDeletion(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a non-employee request. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in this case the user can get the non-employee request for any user.   2. The user must be the owner of the non-employee request.
         * @summary Get a Non-Employee Request
         * @param {string} id Non-Employee request id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async nonEmployeeRequestGet(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nonEmployeeRequestGet(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a list of non-employee requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a list non-employee requests assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a list of the non-employee requests in the source(s) he or she manages.
         * @summary List Non-Employee Requests
         * @param {string} requestedFor The identity for whom the request was made. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407#toc-hId-2058949) Sorting is supported for the following fields: **created, approvalStatus, firstName, lastName, email, phone, accountName, startDate, endDate**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407) Filtering is supported for the following fields and operators: **sourceId**: *eq*  *Example:* sourceId eq \&quot;2c91808568c529c60168cca6f90c1313\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async nonEmployeeRequestList(requestedFor: string, limit?: number, offset?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NonEmployeeRequest>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nonEmployeeRequestList(requestedFor, limit, offset, count, sorters, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This request will retrieve a summary of non-employee requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a summary of all non-employee approval requests assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a summary of the non-employee requests in the source(s) he or she manages.
         * @summary Get Summary of Non-Employee Requests
         * @param {string} requestedFor The identity (UUID) of the non-employee account manager for whom the summary is being retrieved. Use \&quot;me\&quot; instead to indicate the current user.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async nonEmployeeRequestSummaryGet(requestedFor: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeRequestSummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nonEmployeeRequestSummaryGet(requestedFor, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This request will delete a non-employee source. Requires role context of `idn:nesr:delete`.
         * @summary Delete Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async nonEmployeeSourceDelete(sourceId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nonEmployeeSourceDelete(sourceId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a non-employee source. There are two contextual uses for the requested-for path parameter:    1. The user has the role context of `idn:nesr:read`, in which case he or she may request any source.   2. The current user is an account manager, in which case the user can only request sources that they own.
         * @summary Get a Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async nonEmployeeSourceGet(sourceId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeSource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nonEmployeeSourceGet(sourceId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * patch a non-employee source. (partial update) <br/> Patchable field: **name, description, approvers, accountManagers** Requires role context of `idn:nesr:update`.
         * @summary Patch a Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of non-employee source update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async nonEmployeeSourcePatch(sourceId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeSource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nonEmployeeSourcePatch(sourceId, jsonPatchOperation, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This request will create a non-employee source. Requires role context of `idn:nesr:create`
         * @summary Create Non-Employee Source
         * @param {NonEmployeeSourceRequestBody} nonEmployeeSourceRequestBody Non-Employee source creation request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async nonEmployeeSourcesCreation(nonEmployeeSourceRequestBody: NonEmployeeSourceRequestBody, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeSourceWithCloudExternalId>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nonEmployeeSourcesCreation(nonEmployeeSourceRequestBody, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a list of non-employee sources. There are two contextual uses for the requested-for path parameter:    1. The user has the role context of `idn:nesr:read`, in which case he or she may request a list sources assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a list of the sources that he or she owns.
         * @summary List Non-Employee Sources
         * @param {string} requestedFor The identity for whom the request was made. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [nonEmployeeCount] The flag to determine whether return a non-employee count associate with source.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407#toc-hId-2058949) Sorting is supported for the following fields: **name, created**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async nonEmployeeSourcesList(requestedFor: string, limit?: number, offset?: number, count?: boolean, nonEmployeeCount?: boolean, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NonEmployeeSourceWithNECount>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nonEmployeeSourcesList(requestedFor, limit, offset, count, nonEmployeeCount, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This end-point patches a specific schema attribute for a non-employee SourceId. Requires role context of `idn:nesr:update` 
         * @summary Patch a Schema Attribute for Non-Employee Source
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of schema attribute update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. The following properties are allowed for update \&#39;:\&#39; \&#39;label\&#39;, \&#39;helpText\&#39;, \&#39;placeholder\&#39;, \&#39;required\&#39;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchSchemaAttribute(attributeId: string, sourceId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmployeeSchemaAttribute>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchSchemaAttribute(attributeId, sourceId, jsonPatchOperation, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NonEmployeeLifecycleManagementApi - factory interface
 * @export
 */
export const NonEmployeeLifecycleManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NonEmployeeLifecycleManagementApiFp(configuration)
    return {
        /**
         * This API creates a new schema attribute for Non-Employee Source. The schema technical name must be unique in the source. Attempts to create a schema attribute with an existing name will result in a \"400.1.409 Reference conflict\" response. At most, 10 custom attributes can be created per schema. Attempts to create more than 10 will result in a \"400.1.4 Limit violation\" response. Requires role context of `idn:nesr:create`
         * @summary Create a new Schema Attribute for Non-Employee Source
         * @param {string} sourceId The Source id
         * @param {NonEmployeeSchemaAttributeBody} nonEmployeeSchemaAttributeBody 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSchemaAttribute(sourceId: string, nonEmployeeSchemaAttributeBody: NonEmployeeSchemaAttributeBody, axiosOptions?: any): AxiosPromise<NonEmployeeSchemaAttribute> {
            return localVarFp.createSchemaAttribute(sourceId, nonEmployeeSchemaAttributeBody, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This end-point deletes a specific schema attribute for a non-employee source. Requires role context of `idn:nesr:delete` 
         * @summary Delete a Schema Attribute for Non-Employee Source
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSchemaAttribute(attributeId: string, sourceId: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteSchemaAttribute(attributeId, sourceId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This end-point deletes all custom schema attributes for a non-employee source. Requires role context of `idn:nesr:delete`
         * @summary Delete all custom schema attributes for Non-Employee Source
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSchemaAttributes(sourceId: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteSchemaAttributes(sourceId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API gets a schema attribute by Id for the specified Non-Employee SourceId. Requires role context of `idn:nesr:read` or the user must be an account manager of the source.
         * @summary Get Schema Attribute Non-Employee Source
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSchemaAttribute(attributeId: string, sourceId: string, axiosOptions?: any): AxiosPromise<NonEmployeeSchemaAttribute> {
            return localVarFp.getSchemaAttribute(attributeId, sourceId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API gets the list of schema attributes for the specified Non-Employee SourceId. There are 8 mandatory attributes added to each new Non-Employee Source automatically. Additionaly, user can add up to 10 custom attributes. This interface returns all the mandatory attributes followed by any custom attributes. At most, a total of 18 attributes will be returned. Requires role context of `idn:nesr:read` or the user must be an account manager of the source.
         * @summary List Schema Attributes Non-Employee Source
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSchemaAttributes(sourceId: string, axiosOptions?: any): AxiosPromise<Array<NonEmployeeSchemaAttribute>> {
            return localVarFp.getSchemaAttributes(sourceId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Gets a non-employee approval item detail. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can get any approval.   2. The user owns the requested approval.
         * @summary Get a non-employee approval item detail
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {boolean} [includeDetail] The object nonEmployeeRequest will not be included detail when set to false. *Default value is true*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        nonEmployeeApprovalGet(id: string, includeDetail?: boolean, axiosOptions?: any): AxiosPromise<NonEmployeeApprovalItemDetail> {
            return localVarFp.nonEmployeeApprovalGet(id, includeDetail, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a list of non-employee approval requests. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can list the approvals for any approver.   2. The user owns the requested approval.
         * @summary Get List of Non-Employee Approval Requests
         * @param {string} [requestedFor] The identity for whom the request was made. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407) Filtering is supported for the following fields and operators: **approvalStatus**: *eq*  *Example:* approvalStatus eq \&quot;PENDING\&quot;
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407#toc-hId-2058949) Sorting is supported for the following fields: **created, modified**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        nonEmployeeApprovalList(requestedFor?: string, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<NonEmployeeApprovalItem>> {
            return localVarFp.nonEmployeeApprovalList(requestedFor, limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will retrieve a summary of non-employee approval requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a summary of all non-employee approval requests assigned to a particular approver by passing in that approver\'s id.   2. The current user is an approver, in which case \"me\" should be provided as the `requested-for` value. This will provide the approver with a summary of the approval items assigned to him or her.
         * @summary Get Summary of Non-Employee Approval Requests
         * @param {string} requestedFor The identity (UUID) of the approver for whom for whom the summary is being retrieved. Use \&quot;me\&quot; instead to indicate the current user.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        nonEmployeeApprovalSummary(requestedFor: string, axiosOptions?: any): AxiosPromise<NonEmployeeApprovalSummary> {
            return localVarFp.nonEmployeeApprovalSummary(requestedFor, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Approves a non-employee approval request and notifies the next approver. The current user must be the requested approver.
         * @summary Approve a Non-Employee Request
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {NonEmployeeApprovalDecision} nonEmployeeApprovalDecision 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        nonEmployeeApproveRequest(id: string, nonEmployeeApprovalDecision: NonEmployeeApprovalDecision, axiosOptions?: any): AxiosPromise<NonEmployeeApprovalItem> {
            return localVarFp.nonEmployeeApproveRequest(id, nonEmployeeApprovalDecision, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * The nonEmployeeBulkUploadStatus API returns the status of the newest bulk upload job for the specified source. Requires role context of `idn:nesr:read` 
         * @summary Obtain the status of bulk upload on the source
         * @param {string} id Source ID (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        nonEmployeeBulkUploadStatus(id: string, axiosOptions?: any): AxiosPromise<NonEmployeeBulkUploadStatus> {
            return localVarFp.nonEmployeeBulkUploadStatus(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This requests a download for the Source Schema Template for a provided source. Requires role context of `idn:nesr:read`
         * @summary Exports Source Schema Template
         * @param {string} id Source Id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        nonEmployeeExportSourceSchemaTemplate(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.nonEmployeeExportSourceSchemaTemplate(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will delete multiple non-employee records based on the non-employee ids provided. Requires role context of `idn:nesr:delete`
         * @summary Delete Multiple Non-Employee Records
         * @param {NonEmployeeRecordBulkDeleteRequest} nonEmployeeRecordBulkDeleteRequest Non-Employee bulk delete request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        nonEmployeeRecordBulkDelete(nonEmployeeRecordBulkDeleteRequest: NonEmployeeRecordBulkDeleteRequest, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.nonEmployeeRecordBulkDelete(nonEmployeeRecordBulkDeleteRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will create a non-employee record. Requires role context of `idn:nesr:create`
         * @summary Create Non-Employee Record
         * @param {NonEmployeeRequestBody} nonEmployeeRequestBody Non-Employee record creation request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        nonEmployeeRecordCreation(nonEmployeeRequestBody: NonEmployeeRequestBody, axiosOptions?: any): AxiosPromise<NonEmployeeRecord> {
            return localVarFp.nonEmployeeRecordCreation(nonEmployeeRequestBody, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will delete a non-employee record. Requires role context of `idn:nesr:delete`
         * @summary Delete Non-Employee Record
         * @param {string} id Non-Employee record id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        nonEmployeeRecordDelete(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.nonEmployeeRecordDelete(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a non-employee record. Requires role context of `idn:nesr:read`
         * @summary Get a Non-Employee Record
         * @param {string} id Non-Employee record id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        nonEmployeeRecordGet(id: string, axiosOptions?: any): AxiosPromise<NonEmployeeRecord> {
            return localVarFp.nonEmployeeRecordGet(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a list of non-employee records. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can get a list of all of the non-employees.   2. The user is an account manager, in which case they can get a list of the non-employees that they manage.
         * @summary List Non-Employee Records
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407#toc-hId-2058949) Sorting is supported for the following fields: **id, accountName, sourceId, manager, firstName, lastName, email, phone, startDate, endDate, created, modified**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407) Filtering is supported for the following fields and operators: **sourceId**: *eq*  *Example:* sourceId eq \&quot;2c91808568c529c60168cca6f90c1313\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        nonEmployeeRecordList(limit?: number, offset?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions?: any): AxiosPromise<Array<NonEmployeeRecord>> {
            return localVarFp.nonEmployeeRecordList(limit, offset, count, sorters, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will patch a non-employee record. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:update`, in which case they update all available fields.   2. The user is owner of the source, in this case they can only update the end date.
         * @summary Patch Non-Employee Record
         * @param {string} id Non-employee record id (UUID)
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of non-employee update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Attributes are restricted by user type. Owner of source can update end date. Organization admins can update all available fields.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        nonEmployeeRecordPatch(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: any): AxiosPromise<NonEmployeeRecord> {
            return localVarFp.nonEmployeeRecordPatch(id, jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will update a non-employee record. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:update`, in which case they update all available fields.   2. The user is owner of the source, in this case they can only update the end date.
         * @summary Update Non-Employee Record
         * @param {string} id Non-employee record id (UUID)
         * @param {NonEmployeeRequestBody} nonEmployeeRequestBody Non-employee record creation request body. Attributes are restricted by user type. Owner of source can update end date. Organization admins can update all available fields.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        nonEmployeeRecordUpdate(id: string, nonEmployeeRequestBody: NonEmployeeRequestBody, axiosOptions?: any): AxiosPromise<NonEmployeeRecord> {
            return localVarFp.nonEmployeeRecordUpdate(id, nonEmployeeRequestBody, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This post will import, or update, Non-Employee records found in the CSV. Requires role context of `idn:nesr:create`
         * @summary Imports, or Updates, Non-Employee Records
         * @param {string} id Source Id (UUID)
         * @param {string} data 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        nonEmployeeRecordsBulkUpload(id: string, data: string, axiosOptions?: any): AxiosPromise<NonEmployeeBulkUploadJob> {
            return localVarFp.nonEmployeeRecordsBulkUpload(id, data, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This requests a CSV download for all non-employees from a provided source. Requires role context of `idn:nesr:read`
         * @summary Exports Non-Employee Records to CSV
         * @param {string} id Source Id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        nonEmployeeRecordsExport(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.nonEmployeeRecordsExport(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will reject an approval item request and notify user. The current user must be the requested approver.
         * @summary Reject a Non-Employee Request
         * @param {string} id Non-Employee approval item id (UUID)
         * @param {NonEmployeeRejectApprovalDecision} nonEmployeeRejectApprovalDecision 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        nonEmployeeRejectRequest(id: string, nonEmployeeRejectApprovalDecision: NonEmployeeRejectApprovalDecision, axiosOptions?: any): AxiosPromise<NonEmployeeApprovalItem> {
            return localVarFp.nonEmployeeRejectRequest(id, nonEmployeeRejectApprovalDecision, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will create a non-employee request and notify the approver. Requires role context of `idn:nesr:create` or the user must own the source.
         * @summary Create Non-Employee Request
         * @param {NonEmployeeRequestBody} nonEmployeeRequestBody Non-Employee creation request body
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        nonEmployeeRequestCreation(nonEmployeeRequestBody: NonEmployeeRequestBody, axiosOptions?: any): AxiosPromise<NonEmployeeRequest> {
            return localVarFp.nonEmployeeRequestCreation(nonEmployeeRequestBody, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will delete a non-employee request.  Requires role context of `idn:nesr:delete`
         * @summary Delete Non-Employee Request
         * @param {string} id Non-Employee request id in the UUID format
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        nonEmployeeRequestDeletion(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.nonEmployeeRequestDeletion(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a non-employee request. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in this case the user can get the non-employee request for any user.   2. The user must be the owner of the non-employee request.
         * @summary Get a Non-Employee Request
         * @param {string} id Non-Employee request id (UUID)
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        nonEmployeeRequestGet(id: string, axiosOptions?: any): AxiosPromise<NonEmployeeRequest> {
            return localVarFp.nonEmployeeRequestGet(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a list of non-employee requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a list non-employee requests assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a list of the non-employee requests in the source(s) he or she manages.
         * @summary List Non-Employee Requests
         * @param {string} requestedFor The identity for whom the request was made. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407#toc-hId-2058949) Sorting is supported for the following fields: **created, approvalStatus, firstName, lastName, email, phone, accountName, startDate, endDate**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407) Filtering is supported for the following fields and operators: **sourceId**: *eq*  *Example:* sourceId eq \&quot;2c91808568c529c60168cca6f90c1313\&quot;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        nonEmployeeRequestList(requestedFor: string, limit?: number, offset?: number, count?: boolean, sorters?: string, filters?: string, axiosOptions?: any): AxiosPromise<Array<NonEmployeeRequest>> {
            return localVarFp.nonEmployeeRequestList(requestedFor, limit, offset, count, sorters, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will retrieve a summary of non-employee requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a summary of all non-employee approval requests assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a summary of the non-employee requests in the source(s) he or she manages.
         * @summary Get Summary of Non-Employee Requests
         * @param {string} requestedFor The identity (UUID) of the non-employee account manager for whom the summary is being retrieved. Use \&quot;me\&quot; instead to indicate the current user.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        nonEmployeeRequestSummaryGet(requestedFor: string, axiosOptions?: any): AxiosPromise<NonEmployeeRequestSummary> {
            return localVarFp.nonEmployeeRequestSummaryGet(requestedFor, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will delete a non-employee source. Requires role context of `idn:nesr:delete`.
         * @summary Delete Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        nonEmployeeSourceDelete(sourceId: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.nonEmployeeSourceDelete(sourceId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a non-employee source. There are two contextual uses for the requested-for path parameter:    1. The user has the role context of `idn:nesr:read`, in which case he or she may request any source.   2. The current user is an account manager, in which case the user can only request sources that they own.
         * @summary Get a Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        nonEmployeeSourceGet(sourceId: string, axiosOptions?: any): AxiosPromise<NonEmployeeSource> {
            return localVarFp.nonEmployeeSourceGet(sourceId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * patch a non-employee source. (partial update) <br/> Patchable field: **name, description, approvers, accountManagers** Requires role context of `idn:nesr:update`.
         * @summary Patch a Non-Employee Source
         * @param {string} sourceId Source Id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of non-employee source update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        nonEmployeeSourcePatch(sourceId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: any): AxiosPromise<NonEmployeeSource> {
            return localVarFp.nonEmployeeSourcePatch(sourceId, jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This request will create a non-employee source. Requires role context of `idn:nesr:create`
         * @summary Create Non-Employee Source
         * @param {NonEmployeeSourceRequestBody} nonEmployeeSourceRequestBody Non-Employee source creation request body.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        nonEmployeeSourcesCreation(nonEmployeeSourceRequestBody: NonEmployeeSourceRequestBody, axiosOptions?: any): AxiosPromise<NonEmployeeSourceWithCloudExternalId> {
            return localVarFp.nonEmployeeSourcesCreation(nonEmployeeSourceRequestBody, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a list of non-employee sources. There are two contextual uses for the requested-for path parameter:    1. The user has the role context of `idn:nesr:read`, in which case he or she may request a list sources assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a list of the sources that he or she owns.
         * @summary List Non-Employee Sources
         * @param {string} requestedFor The identity for whom the request was made. *me* indicates the current user.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [nonEmployeeCount] The flag to determine whether return a non-employee count associate with source.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407#toc-hId-2058949) Sorting is supported for the following fields: **name, created**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        nonEmployeeSourcesList(requestedFor: string, limit?: number, offset?: number, count?: boolean, nonEmployeeCount?: boolean, sorters?: string, axiosOptions?: any): AxiosPromise<Array<NonEmployeeSourceWithNECount>> {
            return localVarFp.nonEmployeeSourcesList(requestedFor, limit, offset, count, nonEmployeeCount, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This end-point patches a specific schema attribute for a non-employee SourceId. Requires role context of `idn:nesr:update` 
         * @summary Patch a Schema Attribute for Non-Employee Source
         * @param {string} attributeId The Schema Attribute Id (UUID)
         * @param {string} sourceId The Source id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of schema attribute update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. The following properties are allowed for update \&#39;:\&#39; \&#39;label\&#39;, \&#39;helpText\&#39;, \&#39;placeholder\&#39;, \&#39;required\&#39;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchSchemaAttribute(attributeId: string, sourceId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: any): AxiosPromise<NonEmployeeSchemaAttribute> {
            return localVarFp.patchSchemaAttribute(attributeId, sourceId, jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createSchemaAttribute operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiCreateSchemaAttributeRequest
 */
export interface NonEmployeeLifecycleManagementApiCreateSchemaAttributeRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiCreateSchemaAttribute
     */
    readonly sourceId: string

    /**
     * 
     * @type {NonEmployeeSchemaAttributeBody}
     * @memberof NonEmployeeLifecycleManagementApiCreateSchemaAttribute
     */
    readonly nonEmployeeSchemaAttributeBody: NonEmployeeSchemaAttributeBody
}

/**
 * Request parameters for deleteSchemaAttribute operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiDeleteSchemaAttributeRequest
 */
export interface NonEmployeeLifecycleManagementApiDeleteSchemaAttributeRequest {
    /**
     * The Schema Attribute Id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiDeleteSchemaAttribute
     */
    readonly attributeId: string

    /**
     * The Source id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiDeleteSchemaAttribute
     */
    readonly sourceId: string
}

/**
 * Request parameters for deleteSchemaAttributes operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiDeleteSchemaAttributesRequest
 */
export interface NonEmployeeLifecycleManagementApiDeleteSchemaAttributesRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiDeleteSchemaAttributes
     */
    readonly sourceId: string
}

/**
 * Request parameters for getSchemaAttribute operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiGetSchemaAttributeRequest
 */
export interface NonEmployeeLifecycleManagementApiGetSchemaAttributeRequest {
    /**
     * The Schema Attribute Id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiGetSchemaAttribute
     */
    readonly attributeId: string

    /**
     * The Source id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiGetSchemaAttribute
     */
    readonly sourceId: string
}

/**
 * Request parameters for getSchemaAttributes operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiGetSchemaAttributesRequest
 */
export interface NonEmployeeLifecycleManagementApiGetSchemaAttributesRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiGetSchemaAttributes
     */
    readonly sourceId: string
}

/**
 * Request parameters for nonEmployeeApprovalGet operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiNonEmployeeApprovalGetRequest
 */
export interface NonEmployeeLifecycleManagementApiNonEmployeeApprovalGetRequest {
    /**
     * Non-Employee approval item id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiNonEmployeeApprovalGet
     */
    readonly id: string

    /**
     * The object nonEmployeeRequest will not be included detail when set to false. *Default value is true*
     * @type {boolean}
     * @memberof NonEmployeeLifecycleManagementApiNonEmployeeApprovalGet
     */
    readonly includeDetail?: boolean
}

/**
 * Request parameters for nonEmployeeApprovalList operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiNonEmployeeApprovalListRequest
 */
export interface NonEmployeeLifecycleManagementApiNonEmployeeApprovalListRequest {
    /**
     * The identity for whom the request was made. *me* indicates the current user.
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiNonEmployeeApprovalList
     */
    readonly requestedFor?: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NonEmployeeLifecycleManagementApiNonEmployeeApprovalList
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NonEmployeeLifecycleManagementApiNonEmployeeApprovalList
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof NonEmployeeLifecycleManagementApiNonEmployeeApprovalList
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407) Filtering is supported for the following fields and operators: **approvalStatus**: *eq*  *Example:* approvalStatus eq \&quot;PENDING\&quot;
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiNonEmployeeApprovalList
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407#toc-hId-2058949) Sorting is supported for the following fields: **created, modified**
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiNonEmployeeApprovalList
     */
    readonly sorters?: string
}

/**
 * Request parameters for nonEmployeeApprovalSummary operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiNonEmployeeApprovalSummaryRequest
 */
export interface NonEmployeeLifecycleManagementApiNonEmployeeApprovalSummaryRequest {
    /**
     * The identity (UUID) of the approver for whom for whom the summary is being retrieved. Use \&quot;me\&quot; instead to indicate the current user.
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiNonEmployeeApprovalSummary
     */
    readonly requestedFor: string
}

/**
 * Request parameters for nonEmployeeApproveRequest operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiNonEmployeeApproveRequestRequest
 */
export interface NonEmployeeLifecycleManagementApiNonEmployeeApproveRequestRequest {
    /**
     * Non-Employee approval item id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiNonEmployeeApproveRequest
     */
    readonly id: string

    /**
     * 
     * @type {NonEmployeeApprovalDecision}
     * @memberof NonEmployeeLifecycleManagementApiNonEmployeeApproveRequest
     */
    readonly nonEmployeeApprovalDecision: NonEmployeeApprovalDecision
}

/**
 * Request parameters for nonEmployeeBulkUploadStatus operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiNonEmployeeBulkUploadStatusRequest
 */
export interface NonEmployeeLifecycleManagementApiNonEmployeeBulkUploadStatusRequest {
    /**
     * Source ID (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiNonEmployeeBulkUploadStatus
     */
    readonly id: string
}

/**
 * Request parameters for nonEmployeeExportSourceSchemaTemplate operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiNonEmployeeExportSourceSchemaTemplateRequest
 */
export interface NonEmployeeLifecycleManagementApiNonEmployeeExportSourceSchemaTemplateRequest {
    /**
     * Source Id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiNonEmployeeExportSourceSchemaTemplate
     */
    readonly id: string
}

/**
 * Request parameters for nonEmployeeRecordBulkDelete operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiNonEmployeeRecordBulkDeleteRequest
 */
export interface NonEmployeeLifecycleManagementApiNonEmployeeRecordBulkDeleteRequest {
    /**
     * Non-Employee bulk delete request body.
     * @type {NonEmployeeRecordBulkDeleteRequest}
     * @memberof NonEmployeeLifecycleManagementApiNonEmployeeRecordBulkDelete
     */
    readonly nonEmployeeRecordBulkDeleteRequest: NonEmployeeRecordBulkDeleteRequest
}

/**
 * Request parameters for nonEmployeeRecordCreation operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiNonEmployeeRecordCreationRequest
 */
export interface NonEmployeeLifecycleManagementApiNonEmployeeRecordCreationRequest {
    /**
     * Non-Employee record creation request body.
     * @type {NonEmployeeRequestBody}
     * @memberof NonEmployeeLifecycleManagementApiNonEmployeeRecordCreation
     */
    readonly nonEmployeeRequestBody: NonEmployeeRequestBody
}

/**
 * Request parameters for nonEmployeeRecordDelete operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiNonEmployeeRecordDeleteRequest
 */
export interface NonEmployeeLifecycleManagementApiNonEmployeeRecordDeleteRequest {
    /**
     * Non-Employee record id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiNonEmployeeRecordDelete
     */
    readonly id: string
}

/**
 * Request parameters for nonEmployeeRecordGet operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiNonEmployeeRecordGetRequest
 */
export interface NonEmployeeLifecycleManagementApiNonEmployeeRecordGetRequest {
    /**
     * Non-Employee record id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiNonEmployeeRecordGet
     */
    readonly id: string
}

/**
 * Request parameters for nonEmployeeRecordList operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiNonEmployeeRecordListRequest
 */
export interface NonEmployeeLifecycleManagementApiNonEmployeeRecordListRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NonEmployeeLifecycleManagementApiNonEmployeeRecordList
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NonEmployeeLifecycleManagementApiNonEmployeeRecordList
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof NonEmployeeLifecycleManagementApiNonEmployeeRecordList
     */
    readonly count?: boolean

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407#toc-hId-2058949) Sorting is supported for the following fields: **id, accountName, sourceId, manager, firstName, lastName, email, phone, startDate, endDate, created, modified**
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiNonEmployeeRecordList
     */
    readonly sorters?: string

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407) Filtering is supported for the following fields and operators: **sourceId**: *eq*  *Example:* sourceId eq \&quot;2c91808568c529c60168cca6f90c1313\&quot;
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiNonEmployeeRecordList
     */
    readonly filters?: string
}

/**
 * Request parameters for nonEmployeeRecordPatch operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiNonEmployeeRecordPatchRequest
 */
export interface NonEmployeeLifecycleManagementApiNonEmployeeRecordPatchRequest {
    /**
     * Non-employee record id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiNonEmployeeRecordPatch
     */
    readonly id: string

    /**
     * A list of non-employee update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Attributes are restricted by user type. Owner of source can update end date. Organization admins can update all available fields.
     * @type {Array<JsonPatchOperation>}
     * @memberof NonEmployeeLifecycleManagementApiNonEmployeeRecordPatch
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * Request parameters for nonEmployeeRecordUpdate operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiNonEmployeeRecordUpdateRequest
 */
export interface NonEmployeeLifecycleManagementApiNonEmployeeRecordUpdateRequest {
    /**
     * Non-employee record id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiNonEmployeeRecordUpdate
     */
    readonly id: string

    /**
     * Non-employee record creation request body. Attributes are restricted by user type. Owner of source can update end date. Organization admins can update all available fields.
     * @type {NonEmployeeRequestBody}
     * @memberof NonEmployeeLifecycleManagementApiNonEmployeeRecordUpdate
     */
    readonly nonEmployeeRequestBody: NonEmployeeRequestBody
}

/**
 * Request parameters for nonEmployeeRecordsBulkUpload operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiNonEmployeeRecordsBulkUploadRequest
 */
export interface NonEmployeeLifecycleManagementApiNonEmployeeRecordsBulkUploadRequest {
    /**
     * Source Id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiNonEmployeeRecordsBulkUpload
     */
    readonly id: string

    /**
     * 
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiNonEmployeeRecordsBulkUpload
     */
    readonly data: string
}

/**
 * Request parameters for nonEmployeeRecordsExport operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiNonEmployeeRecordsExportRequest
 */
export interface NonEmployeeLifecycleManagementApiNonEmployeeRecordsExportRequest {
    /**
     * Source Id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiNonEmployeeRecordsExport
     */
    readonly id: string
}

/**
 * Request parameters for nonEmployeeRejectRequest operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiNonEmployeeRejectRequestRequest
 */
export interface NonEmployeeLifecycleManagementApiNonEmployeeRejectRequestRequest {
    /**
     * Non-Employee approval item id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiNonEmployeeRejectRequest
     */
    readonly id: string

    /**
     * 
     * @type {NonEmployeeRejectApprovalDecision}
     * @memberof NonEmployeeLifecycleManagementApiNonEmployeeRejectRequest
     */
    readonly nonEmployeeRejectApprovalDecision: NonEmployeeRejectApprovalDecision
}

/**
 * Request parameters for nonEmployeeRequestCreation operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiNonEmployeeRequestCreationRequest
 */
export interface NonEmployeeLifecycleManagementApiNonEmployeeRequestCreationRequest {
    /**
     * Non-Employee creation request body
     * @type {NonEmployeeRequestBody}
     * @memberof NonEmployeeLifecycleManagementApiNonEmployeeRequestCreation
     */
    readonly nonEmployeeRequestBody: NonEmployeeRequestBody
}

/**
 * Request parameters for nonEmployeeRequestDeletion operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiNonEmployeeRequestDeletionRequest
 */
export interface NonEmployeeLifecycleManagementApiNonEmployeeRequestDeletionRequest {
    /**
     * Non-Employee request id in the UUID format
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiNonEmployeeRequestDeletion
     */
    readonly id: string
}

/**
 * Request parameters for nonEmployeeRequestGet operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiNonEmployeeRequestGetRequest
 */
export interface NonEmployeeLifecycleManagementApiNonEmployeeRequestGetRequest {
    /**
     * Non-Employee request id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiNonEmployeeRequestGet
     */
    readonly id: string
}

/**
 * Request parameters for nonEmployeeRequestList operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiNonEmployeeRequestListRequest
 */
export interface NonEmployeeLifecycleManagementApiNonEmployeeRequestListRequest {
    /**
     * The identity for whom the request was made. *me* indicates the current user.
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiNonEmployeeRequestList
     */
    readonly requestedFor: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NonEmployeeLifecycleManagementApiNonEmployeeRequestList
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NonEmployeeLifecycleManagementApiNonEmployeeRequestList
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof NonEmployeeLifecycleManagementApiNonEmployeeRequestList
     */
    readonly count?: boolean

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407#toc-hId-2058949) Sorting is supported for the following fields: **created, approvalStatus, firstName, lastName, email, phone, accountName, startDate, endDate**
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiNonEmployeeRequestList
     */
    readonly sorters?: string

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407) Filtering is supported for the following fields and operators: **sourceId**: *eq*  *Example:* sourceId eq \&quot;2c91808568c529c60168cca6f90c1313\&quot;
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiNonEmployeeRequestList
     */
    readonly filters?: string
}

/**
 * Request parameters for nonEmployeeRequestSummaryGet operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiNonEmployeeRequestSummaryGetRequest
 */
export interface NonEmployeeLifecycleManagementApiNonEmployeeRequestSummaryGetRequest {
    /**
     * The identity (UUID) of the non-employee account manager for whom the summary is being retrieved. Use \&quot;me\&quot; instead to indicate the current user.
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiNonEmployeeRequestSummaryGet
     */
    readonly requestedFor: string
}

/**
 * Request parameters for nonEmployeeSourceDelete operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiNonEmployeeSourceDeleteRequest
 */
export interface NonEmployeeLifecycleManagementApiNonEmployeeSourceDeleteRequest {
    /**
     * Source Id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiNonEmployeeSourceDelete
     */
    readonly sourceId: string
}

/**
 * Request parameters for nonEmployeeSourceGet operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiNonEmployeeSourceGetRequest
 */
export interface NonEmployeeLifecycleManagementApiNonEmployeeSourceGetRequest {
    /**
     * Source Id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiNonEmployeeSourceGet
     */
    readonly sourceId: string
}

/**
 * Request parameters for nonEmployeeSourcePatch operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiNonEmployeeSourcePatchRequest
 */
export interface NonEmployeeLifecycleManagementApiNonEmployeeSourcePatchRequest {
    /**
     * Source Id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiNonEmployeeSourcePatch
     */
    readonly sourceId: string

    /**
     * A list of non-employee source update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.
     * @type {Array<JsonPatchOperation>}
     * @memberof NonEmployeeLifecycleManagementApiNonEmployeeSourcePatch
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * Request parameters for nonEmployeeSourcesCreation operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiNonEmployeeSourcesCreationRequest
 */
export interface NonEmployeeLifecycleManagementApiNonEmployeeSourcesCreationRequest {
    /**
     * Non-Employee source creation request body.
     * @type {NonEmployeeSourceRequestBody}
     * @memberof NonEmployeeLifecycleManagementApiNonEmployeeSourcesCreation
     */
    readonly nonEmployeeSourceRequestBody: NonEmployeeSourceRequestBody
}

/**
 * Request parameters for nonEmployeeSourcesList operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiNonEmployeeSourcesListRequest
 */
export interface NonEmployeeLifecycleManagementApiNonEmployeeSourcesListRequest {
    /**
     * The identity for whom the request was made. *me* indicates the current user.
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiNonEmployeeSourcesList
     */
    readonly requestedFor: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NonEmployeeLifecycleManagementApiNonEmployeeSourcesList
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof NonEmployeeLifecycleManagementApiNonEmployeeSourcesList
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof NonEmployeeLifecycleManagementApiNonEmployeeSourcesList
     */
    readonly count?: boolean

    /**
     * The flag to determine whether return a non-employee count associate with source.
     * @type {boolean}
     * @memberof NonEmployeeLifecycleManagementApiNonEmployeeSourcesList
     */
    readonly nonEmployeeCount?: boolean

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://community.sailpoint.com/t5/IdentityNow-Wiki/V3-API-Standard-Collection-Parameters/ta-p/156407#toc-hId-2058949) Sorting is supported for the following fields: **name, created**
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiNonEmployeeSourcesList
     */
    readonly sorters?: string
}

/**
 * Request parameters for patchSchemaAttribute operation in NonEmployeeLifecycleManagementApi.
 * @export
 * @interface NonEmployeeLifecycleManagementApiPatchSchemaAttributeRequest
 */
export interface NonEmployeeLifecycleManagementApiPatchSchemaAttributeRequest {
    /**
     * The Schema Attribute Id (UUID)
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiPatchSchemaAttribute
     */
    readonly attributeId: string

    /**
     * The Source id
     * @type {string}
     * @memberof NonEmployeeLifecycleManagementApiPatchSchemaAttribute
     */
    readonly sourceId: string

    /**
     * A list of schema attribute update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. The following properties are allowed for update \&#39;:\&#39; \&#39;label\&#39;, \&#39;helpText\&#39;, \&#39;placeholder\&#39;, \&#39;required\&#39;.
     * @type {Array<JsonPatchOperation>}
     * @memberof NonEmployeeLifecycleManagementApiPatchSchemaAttribute
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * NonEmployeeLifecycleManagementApi - object-oriented interface
 * @export
 * @class NonEmployeeLifecycleManagementApi
 * @extends {BaseAPI}
 */
export class NonEmployeeLifecycleManagementApi extends BaseAPI {
    /**
     * This API creates a new schema attribute for Non-Employee Source. The schema technical name must be unique in the source. Attempts to create a schema attribute with an existing name will result in a \"400.1.409 Reference conflict\" response. At most, 10 custom attributes can be created per schema. Attempts to create more than 10 will result in a \"400.1.4 Limit violation\" response. Requires role context of `idn:nesr:create`
     * @summary Create a new Schema Attribute for Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiCreateSchemaAttributeRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public createSchemaAttribute(requestParameters: NonEmployeeLifecycleManagementApiCreateSchemaAttributeRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).createSchemaAttribute(requestParameters.sourceId, requestParameters.nonEmployeeSchemaAttributeBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point deletes a specific schema attribute for a non-employee source. Requires role context of `idn:nesr:delete` 
     * @summary Delete a Schema Attribute for Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiDeleteSchemaAttributeRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public deleteSchemaAttribute(requestParameters: NonEmployeeLifecycleManagementApiDeleteSchemaAttributeRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).deleteSchemaAttribute(requestParameters.attributeId, requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point deletes all custom schema attributes for a non-employee source. Requires role context of `idn:nesr:delete`
     * @summary Delete all custom schema attributes for Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiDeleteSchemaAttributesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public deleteSchemaAttributes(requestParameters: NonEmployeeLifecycleManagementApiDeleteSchemaAttributesRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).deleteSchemaAttributes(requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API gets a schema attribute by Id for the specified Non-Employee SourceId. Requires role context of `idn:nesr:read` or the user must be an account manager of the source.
     * @summary Get Schema Attribute Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiGetSchemaAttributeRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public getSchemaAttribute(requestParameters: NonEmployeeLifecycleManagementApiGetSchemaAttributeRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).getSchemaAttribute(requestParameters.attributeId, requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API gets the list of schema attributes for the specified Non-Employee SourceId. There are 8 mandatory attributes added to each new Non-Employee Source automatically. Additionaly, user can add up to 10 custom attributes. This interface returns all the mandatory attributes followed by any custom attributes. At most, a total of 18 attributes will be returned. Requires role context of `idn:nesr:read` or the user must be an account manager of the source.
     * @summary List Schema Attributes Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiGetSchemaAttributesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public getSchemaAttributes(requestParameters: NonEmployeeLifecycleManagementApiGetSchemaAttributesRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).getSchemaAttributes(requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a non-employee approval item detail. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can get any approval.   2. The user owns the requested approval.
     * @summary Get a non-employee approval item detail
     * @param {NonEmployeeLifecycleManagementApiNonEmployeeApprovalGetRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public nonEmployeeApprovalGet(requestParameters: NonEmployeeLifecycleManagementApiNonEmployeeApprovalGetRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).nonEmployeeApprovalGet(requestParameters.id, requestParameters.includeDetail, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a list of non-employee approval requests. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can list the approvals for any approver.   2. The user owns the requested approval.
     * @summary Get List of Non-Employee Approval Requests
     * @param {NonEmployeeLifecycleManagementApiNonEmployeeApprovalListRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public nonEmployeeApprovalList(requestParameters: NonEmployeeLifecycleManagementApiNonEmployeeApprovalListRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).nonEmployeeApprovalList(requestParameters.requestedFor, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will retrieve a summary of non-employee approval requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a summary of all non-employee approval requests assigned to a particular approver by passing in that approver\'s id.   2. The current user is an approver, in which case \"me\" should be provided as the `requested-for` value. This will provide the approver with a summary of the approval items assigned to him or her.
     * @summary Get Summary of Non-Employee Approval Requests
     * @param {NonEmployeeLifecycleManagementApiNonEmployeeApprovalSummaryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public nonEmployeeApprovalSummary(requestParameters: NonEmployeeLifecycleManagementApiNonEmployeeApprovalSummaryRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).nonEmployeeApprovalSummary(requestParameters.requestedFor, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Approves a non-employee approval request and notifies the next approver. The current user must be the requested approver.
     * @summary Approve a Non-Employee Request
     * @param {NonEmployeeLifecycleManagementApiNonEmployeeApproveRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public nonEmployeeApproveRequest(requestParameters: NonEmployeeLifecycleManagementApiNonEmployeeApproveRequestRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).nonEmployeeApproveRequest(requestParameters.id, requestParameters.nonEmployeeApprovalDecision, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The nonEmployeeBulkUploadStatus API returns the status of the newest bulk upload job for the specified source. Requires role context of `idn:nesr:read` 
     * @summary Obtain the status of bulk upload on the source
     * @param {NonEmployeeLifecycleManagementApiNonEmployeeBulkUploadStatusRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public nonEmployeeBulkUploadStatus(requestParameters: NonEmployeeLifecycleManagementApiNonEmployeeBulkUploadStatusRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).nonEmployeeBulkUploadStatus(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This requests a download for the Source Schema Template for a provided source. Requires role context of `idn:nesr:read`
     * @summary Exports Source Schema Template
     * @param {NonEmployeeLifecycleManagementApiNonEmployeeExportSourceSchemaTemplateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public nonEmployeeExportSourceSchemaTemplate(requestParameters: NonEmployeeLifecycleManagementApiNonEmployeeExportSourceSchemaTemplateRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).nonEmployeeExportSourceSchemaTemplate(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will delete multiple non-employee records based on the non-employee ids provided. Requires role context of `idn:nesr:delete`
     * @summary Delete Multiple Non-Employee Records
     * @param {NonEmployeeLifecycleManagementApiNonEmployeeRecordBulkDeleteRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public nonEmployeeRecordBulkDelete(requestParameters: NonEmployeeLifecycleManagementApiNonEmployeeRecordBulkDeleteRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).nonEmployeeRecordBulkDelete(requestParameters.nonEmployeeRecordBulkDeleteRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will create a non-employee record. Requires role context of `idn:nesr:create`
     * @summary Create Non-Employee Record
     * @param {NonEmployeeLifecycleManagementApiNonEmployeeRecordCreationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public nonEmployeeRecordCreation(requestParameters: NonEmployeeLifecycleManagementApiNonEmployeeRecordCreationRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).nonEmployeeRecordCreation(requestParameters.nonEmployeeRequestBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will delete a non-employee record. Requires role context of `idn:nesr:delete`
     * @summary Delete Non-Employee Record
     * @param {NonEmployeeLifecycleManagementApiNonEmployeeRecordDeleteRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public nonEmployeeRecordDelete(requestParameters: NonEmployeeLifecycleManagementApiNonEmployeeRecordDeleteRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).nonEmployeeRecordDelete(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a non-employee record. Requires role context of `idn:nesr:read`
     * @summary Get a Non-Employee Record
     * @param {NonEmployeeLifecycleManagementApiNonEmployeeRecordGetRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public nonEmployeeRecordGet(requestParameters: NonEmployeeLifecycleManagementApiNonEmployeeRecordGetRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).nonEmployeeRecordGet(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a list of non-employee records. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in which case they can get a list of all of the non-employees.   2. The user is an account manager, in which case they can get a list of the non-employees that they manage.
     * @summary List Non-Employee Records
     * @param {NonEmployeeLifecycleManagementApiNonEmployeeRecordListRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public nonEmployeeRecordList(requestParameters: NonEmployeeLifecycleManagementApiNonEmployeeRecordListRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).nonEmployeeRecordList(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.sorters, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will patch a non-employee record. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:update`, in which case they update all available fields.   2. The user is owner of the source, in this case they can only update the end date.
     * @summary Patch Non-Employee Record
     * @param {NonEmployeeLifecycleManagementApiNonEmployeeRecordPatchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public nonEmployeeRecordPatch(requestParameters: NonEmployeeLifecycleManagementApiNonEmployeeRecordPatchRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).nonEmployeeRecordPatch(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will update a non-employee record. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:update`, in which case they update all available fields.   2. The user is owner of the source, in this case they can only update the end date.
     * @summary Update Non-Employee Record
     * @param {NonEmployeeLifecycleManagementApiNonEmployeeRecordUpdateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public nonEmployeeRecordUpdate(requestParameters: NonEmployeeLifecycleManagementApiNonEmployeeRecordUpdateRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).nonEmployeeRecordUpdate(requestParameters.id, requestParameters.nonEmployeeRequestBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This post will import, or update, Non-Employee records found in the CSV. Requires role context of `idn:nesr:create`
     * @summary Imports, or Updates, Non-Employee Records
     * @param {NonEmployeeLifecycleManagementApiNonEmployeeRecordsBulkUploadRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public nonEmployeeRecordsBulkUpload(requestParameters: NonEmployeeLifecycleManagementApiNonEmployeeRecordsBulkUploadRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).nonEmployeeRecordsBulkUpload(requestParameters.id, requestParameters.data, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This requests a CSV download for all non-employees from a provided source. Requires role context of `idn:nesr:read`
     * @summary Exports Non-Employee Records to CSV
     * @param {NonEmployeeLifecycleManagementApiNonEmployeeRecordsExportRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public nonEmployeeRecordsExport(requestParameters: NonEmployeeLifecycleManagementApiNonEmployeeRecordsExportRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).nonEmployeeRecordsExport(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint will reject an approval item request and notify user. The current user must be the requested approver.
     * @summary Reject a Non-Employee Request
     * @param {NonEmployeeLifecycleManagementApiNonEmployeeRejectRequestRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public nonEmployeeRejectRequest(requestParameters: NonEmployeeLifecycleManagementApiNonEmployeeRejectRequestRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).nonEmployeeRejectRequest(requestParameters.id, requestParameters.nonEmployeeRejectApprovalDecision, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will create a non-employee request and notify the approver. Requires role context of `idn:nesr:create` or the user must own the source.
     * @summary Create Non-Employee Request
     * @param {NonEmployeeLifecycleManagementApiNonEmployeeRequestCreationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public nonEmployeeRequestCreation(requestParameters: NonEmployeeLifecycleManagementApiNonEmployeeRequestCreationRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).nonEmployeeRequestCreation(requestParameters.nonEmployeeRequestBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will delete a non-employee request.  Requires role context of `idn:nesr:delete`
     * @summary Delete Non-Employee Request
     * @param {NonEmployeeLifecycleManagementApiNonEmployeeRequestDeletionRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public nonEmployeeRequestDeletion(requestParameters: NonEmployeeLifecycleManagementApiNonEmployeeRequestDeletionRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).nonEmployeeRequestDeletion(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a non-employee request. There are two contextual uses for this endpoint:   1. The user has the role context of `idn:nesr:read`, in this case the user can get the non-employee request for any user.   2. The user must be the owner of the non-employee request.
     * @summary Get a Non-Employee Request
     * @param {NonEmployeeLifecycleManagementApiNonEmployeeRequestGetRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public nonEmployeeRequestGet(requestParameters: NonEmployeeLifecycleManagementApiNonEmployeeRequestGetRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).nonEmployeeRequestGet(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a list of non-employee requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a list non-employee requests assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a list of the non-employee requests in the source(s) he or she manages.
     * @summary List Non-Employee Requests
     * @param {NonEmployeeLifecycleManagementApiNonEmployeeRequestListRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public nonEmployeeRequestList(requestParameters: NonEmployeeLifecycleManagementApiNonEmployeeRequestListRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).nonEmployeeRequestList(requestParameters.requestedFor, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.sorters, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will retrieve a summary of non-employee requests. There are two contextual uses for the `requested-for` path parameter:   1. The user has the role context of `idn:nesr:read`, in which case he or she may request a summary of all non-employee approval requests assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a summary of the non-employee requests in the source(s) he or she manages.
     * @summary Get Summary of Non-Employee Requests
     * @param {NonEmployeeLifecycleManagementApiNonEmployeeRequestSummaryGetRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public nonEmployeeRequestSummaryGet(requestParameters: NonEmployeeLifecycleManagementApiNonEmployeeRequestSummaryGetRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).nonEmployeeRequestSummaryGet(requestParameters.requestedFor, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will delete a non-employee source. Requires role context of `idn:nesr:delete`.
     * @summary Delete Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiNonEmployeeSourceDeleteRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public nonEmployeeSourceDelete(requestParameters: NonEmployeeLifecycleManagementApiNonEmployeeSourceDeleteRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).nonEmployeeSourceDelete(requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a non-employee source. There are two contextual uses for the requested-for path parameter:    1. The user has the role context of `idn:nesr:read`, in which case he or she may request any source.   2. The current user is an account manager, in which case the user can only request sources that they own.
     * @summary Get a Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiNonEmployeeSourceGetRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public nonEmployeeSourceGet(requestParameters: NonEmployeeLifecycleManagementApiNonEmployeeSourceGetRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).nonEmployeeSourceGet(requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * patch a non-employee source. (partial update) <br/> Patchable field: **name, description, approvers, accountManagers** Requires role context of `idn:nesr:update`.
     * @summary Patch a Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiNonEmployeeSourcePatchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public nonEmployeeSourcePatch(requestParameters: NonEmployeeLifecycleManagementApiNonEmployeeSourcePatchRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).nonEmployeeSourcePatch(requestParameters.sourceId, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will create a non-employee source. Requires role context of `idn:nesr:create`
     * @summary Create Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiNonEmployeeSourcesCreationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public nonEmployeeSourcesCreation(requestParameters: NonEmployeeLifecycleManagementApiNonEmployeeSourcesCreationRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).nonEmployeeSourcesCreation(requestParameters.nonEmployeeSourceRequestBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a list of non-employee sources. There are two contextual uses for the requested-for path parameter:    1. The user has the role context of `idn:nesr:read`, in which case he or she may request a list sources assigned to a particular account manager by passing in that manager\'s id.   2. The current user is an account manager, in which case \"me\" should be provided as the `requested-for` value. This will provide the user with a list of the sources that he or she owns.
     * @summary List Non-Employee Sources
     * @param {NonEmployeeLifecycleManagementApiNonEmployeeSourcesListRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public nonEmployeeSourcesList(requestParameters: NonEmployeeLifecycleManagementApiNonEmployeeSourcesListRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).nonEmployeeSourcesList(requestParameters.requestedFor, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.nonEmployeeCount, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point patches a specific schema attribute for a non-employee SourceId. Requires role context of `idn:nesr:update` 
     * @summary Patch a Schema Attribute for Non-Employee Source
     * @param {NonEmployeeLifecycleManagementApiPatchSchemaAttributeRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof NonEmployeeLifecycleManagementApi
     */
    public patchSchemaAttribute(requestParameters: NonEmployeeLifecycleManagementApiPatchSchemaAttributeRequest, axiosOptions?: AxiosRequestConfig) {
        return NonEmployeeLifecycleManagementApiFp(this.configuration).patchSchemaAttribute(requestParameters.attributeId, requestParameters.sourceId, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OAuthClientsApi - axios parameter creator
 * @export
 */
export const OAuthClientsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This creates an OAuth client.
         * @summary Create OAuth Client
         * @param {CreateOAuthClientRequest} createOAuthClientRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createOauthClient: async (createOAuthClientRequest: CreateOAuthClientRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOAuthClientRequest' is not null or undefined
            assertParamExists('createOauthClient', 'createOAuthClientRequest', createOAuthClientRequest)
            const localVarPath = `/oauth-clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOAuthClientRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This deletes an OAuth client.
         * @summary Delete OAuth Client
         * @param {string} id The OAuth client id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteOauthClient: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteOauthClient', 'id', id)
            const localVarPath = `/oauth-clients/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets details of an OAuth client.
         * @summary Get OAuth Client
         * @param {string} id The OAuth client id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getOauthClient: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOauthClient', 'id', id)
            const localVarPath = `/oauth-clients/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a list of OAuth clients.
         * @summary List OAuth Clients
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listOauthClients: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/oauth-clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This performs a targeted update to the field(s) of an OAuth client.
         * @summary Patch OAuth Client
         * @param {string} id The OAuth client id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of OAuth client update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * tenant * businessName * homepageUrl * name * description * accessTokenValiditySeconds * refreshTokenValiditySeconds * redirectUris * grantTypes * accessType * enabled * strongAuthSupported * claimsSupported 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchOauthClient: async (id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchOauthClient', 'id', id)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('patchOauthClient', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/oauth-clients/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * OAuthClientsApi - functional programming interface
 * @export
 */
export const OAuthClientsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OAuthClientsApiAxiosParamCreator(configuration)
    return {
        /**
         * This creates an OAuth client.
         * @summary Create OAuth Client
         * @param {CreateOAuthClientRequest} createOAuthClientRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createOauthClient(createOAuthClientRequest: CreateOAuthClientRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOAuthClientResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOauthClient(createOAuthClientRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This deletes an OAuth client.
         * @summary Delete OAuth Client
         * @param {string} id The OAuth client id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOauthClient(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOauthClient(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets details of an OAuth client.
         * @summary Get OAuth Client
         * @param {string} id The OAuth client id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getOauthClient(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOAuthClientResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOauthClient(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a list of OAuth clients.
         * @summary List OAuth Clients
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listOauthClients(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetOAuthClientResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOauthClients(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This performs a targeted update to the field(s) of an OAuth client.
         * @summary Patch OAuth Client
         * @param {string} id The OAuth client id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of OAuth client update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * tenant * businessName * homepageUrl * name * description * accessTokenValiditySeconds * refreshTokenValiditySeconds * redirectUris * grantTypes * accessType * enabled * strongAuthSupported * claimsSupported 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchOauthClient(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOAuthClientResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchOauthClient(id, jsonPatchOperation, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OAuthClientsApi - factory interface
 * @export
 */
export const OAuthClientsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OAuthClientsApiFp(configuration)
    return {
        /**
         * This creates an OAuth client.
         * @summary Create OAuth Client
         * @param {CreateOAuthClientRequest} createOAuthClientRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createOauthClient(createOAuthClientRequest: CreateOAuthClientRequest, axiosOptions?: any): AxiosPromise<CreateOAuthClientResponse> {
            return localVarFp.createOauthClient(createOAuthClientRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This deletes an OAuth client.
         * @summary Delete OAuth Client
         * @param {string} id The OAuth client id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteOauthClient(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteOauthClient(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets details of an OAuth client.
         * @summary Get OAuth Client
         * @param {string} id The OAuth client id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getOauthClient(id: string, axiosOptions?: any): AxiosPromise<GetOAuthClientResponse> {
            return localVarFp.getOauthClient(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a list of OAuth clients.
         * @summary List OAuth Clients
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listOauthClients(axiosOptions?: any): AxiosPromise<Array<GetOAuthClientResponse>> {
            return localVarFp.listOauthClients(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This performs a targeted update to the field(s) of an OAuth client.
         * @summary Patch OAuth Client
         * @param {string} id The OAuth client id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of OAuth client update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * tenant * businessName * homepageUrl * name * description * accessTokenValiditySeconds * refreshTokenValiditySeconds * redirectUris * grantTypes * accessType * enabled * strongAuthSupported * claimsSupported 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchOauthClient(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: any): AxiosPromise<GetOAuthClientResponse> {
            return localVarFp.patchOauthClient(id, jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createOauthClient operation in OAuthClientsApi.
 * @export
 * @interface OAuthClientsApiCreateOauthClientRequest
 */
export interface OAuthClientsApiCreateOauthClientRequest {
    /**
     * 
     * @type {CreateOAuthClientRequest}
     * @memberof OAuthClientsApiCreateOauthClient
     */
    readonly createOAuthClientRequest: CreateOAuthClientRequest
}

/**
 * Request parameters for deleteOauthClient operation in OAuthClientsApi.
 * @export
 * @interface OAuthClientsApiDeleteOauthClientRequest
 */
export interface OAuthClientsApiDeleteOauthClientRequest {
    /**
     * The OAuth client id
     * @type {string}
     * @memberof OAuthClientsApiDeleteOauthClient
     */
    readonly id: string
}

/**
 * Request parameters for getOauthClient operation in OAuthClientsApi.
 * @export
 * @interface OAuthClientsApiGetOauthClientRequest
 */
export interface OAuthClientsApiGetOauthClientRequest {
    /**
     * The OAuth client id
     * @type {string}
     * @memberof OAuthClientsApiGetOauthClient
     */
    readonly id: string
}

/**
 * Request parameters for patchOauthClient operation in OAuthClientsApi.
 * @export
 * @interface OAuthClientsApiPatchOauthClientRequest
 */
export interface OAuthClientsApiPatchOauthClientRequest {
    /**
     * The OAuth client id
     * @type {string}
     * @memberof OAuthClientsApiPatchOauthClient
     */
    readonly id: string

    /**
     * A list of OAuth client update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * tenant * businessName * homepageUrl * name * description * accessTokenValiditySeconds * refreshTokenValiditySeconds * redirectUris * grantTypes * accessType * enabled * strongAuthSupported * claimsSupported 
     * @type {Array<JsonPatchOperation>}
     * @memberof OAuthClientsApiPatchOauthClient
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * OAuthClientsApi - object-oriented interface
 * @export
 * @class OAuthClientsApi
 * @extends {BaseAPI}
 */
export class OAuthClientsApi extends BaseAPI {
    /**
     * This creates an OAuth client.
     * @summary Create OAuth Client
     * @param {OAuthClientsApiCreateOauthClientRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthClientsApi
     */
    public createOauthClient(requestParameters: OAuthClientsApiCreateOauthClientRequest, axiosOptions?: AxiosRequestConfig) {
        return OAuthClientsApiFp(this.configuration).createOauthClient(requestParameters.createOAuthClientRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This deletes an OAuth client.
     * @summary Delete OAuth Client
     * @param {OAuthClientsApiDeleteOauthClientRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthClientsApi
     */
    public deleteOauthClient(requestParameters: OAuthClientsApiDeleteOauthClientRequest, axiosOptions?: AxiosRequestConfig) {
        return OAuthClientsApiFp(this.configuration).deleteOauthClient(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets details of an OAuth client.
     * @summary Get OAuth Client
     * @param {OAuthClientsApiGetOauthClientRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthClientsApi
     */
    public getOauthClient(requestParameters: OAuthClientsApiGetOauthClientRequest, axiosOptions?: AxiosRequestConfig) {
        return OAuthClientsApiFp(this.configuration).getOauthClient(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a list of OAuth clients.
     * @summary List OAuth Clients
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthClientsApi
     */
    public listOauthClients(axiosOptions?: AxiosRequestConfig) {
        return OAuthClientsApiFp(this.configuration).listOauthClients(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This performs a targeted update to the field(s) of an OAuth client.
     * @summary Patch OAuth Client
     * @param {OAuthClientsApiPatchOauthClientRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthClientsApi
     */
    public patchOauthClient(requestParameters: OAuthClientsApiPatchOauthClientRequest, axiosOptions?: AxiosRequestConfig) {
        return OAuthClientsApiFp(this.configuration).patchOauthClient(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PasswordManagementApi - axios parameter creator
 * @export
 */
export const PasswordManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API returns the status of a password change request. A token with identity owner or trusted API client application authority is required to call this API.
         * @summary Get Password Change Request Status
         * @param {string} id Password change request ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordChangeStatus: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPasswordChangeStatus', 'id', id)
            const localVarPath = `/password-change-status/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API is used to query password related information.   A token with [API authority](https://developer.sailpoint.com/idn/api/authentication#client-credentials-grant-flow)  is required to call this API.  \"API authority\" refers to a token that only has the \"client_credentials\"  grant type, and therefore no user context. A [personal access token](https://developer.sailpoint.com/idn/api/authentication#personal-access-tokens)  or a token generated with the [authorization_code](https://developer.sailpoint.com/idn/api/authentication#authorization-code-grant-flow)  grant type will **NOT** work on this endpoint, and a `403 Forbidden` response  will be returned. 
         * @summary Query Password Info
         * @param {PasswordInfoQueryDTO} passwordInfoQueryDTO 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        queryPasswordInfo: async (passwordInfoQueryDTO: PasswordInfoQueryDTO, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordInfoQueryDTO' is not null or undefined
            assertParamExists('queryPasswordInfo', 'passwordInfoQueryDTO', passwordInfoQueryDTO)
            const localVarPath = `/query-password-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordInfoQueryDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API is used to set a password for an identity.   An identity can change their own password if they use a token generated by their IDN user, such as a [personal access token](https://developer.sailpoint.com/idn/api/authentication#personal-access-tokens) or [\"authorization_code\" derived OAuth token](https://developer.sailpoint.com/idn/api/authentication#authorization-code-grant-flow).  A token with [API authority](https://developer.sailpoint.com/idn/api/authentication#client-credentials-grant-flow) can be used to change **any** identity\'s password.  \"API authority\" refers to a token that only has the \"client_credentials\" grant type. 
         * @summary Set Identity\'s Password
         * @param {PasswordChangeRequest} passwordChangeRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setPassword: async (passwordChangeRequest: PasswordChangeRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordChangeRequest' is not null or undefined
            assertParamExists('setPassword', 'passwordChangeRequest', passwordChangeRequest)
            const localVarPath = `/set-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordChangeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * PasswordManagementApi - functional programming interface
 * @export
 */
export const PasswordManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PasswordManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * This API returns the status of a password change request. A token with identity owner or trusted API client application authority is required to call this API.
         * @summary Get Password Change Request Status
         * @param {string} id Password change request ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getPasswordChangeStatus(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPasswordChangeStatus(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API is used to query password related information.   A token with [API authority](https://developer.sailpoint.com/idn/api/authentication#client-credentials-grant-flow)  is required to call this API.  \"API authority\" refers to a token that only has the \"client_credentials\"  grant type, and therefore no user context. A [personal access token](https://developer.sailpoint.com/idn/api/authentication#personal-access-tokens)  or a token generated with the [authorization_code](https://developer.sailpoint.com/idn/api/authentication#authorization-code-grant-flow)  grant type will **NOT** work on this endpoint, and a `403 Forbidden` response  will be returned. 
         * @summary Query Password Info
         * @param {PasswordInfoQueryDTO} passwordInfoQueryDTO 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async queryPasswordInfo(passwordInfoQueryDTO: PasswordInfoQueryDTO, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryPasswordInfo(passwordInfoQueryDTO, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API is used to set a password for an identity.   An identity can change their own password if they use a token generated by their IDN user, such as a [personal access token](https://developer.sailpoint.com/idn/api/authentication#personal-access-tokens) or [\"authorization_code\" derived OAuth token](https://developer.sailpoint.com/idn/api/authentication#authorization-code-grant-flow).  A token with [API authority](https://developer.sailpoint.com/idn/api/authentication#client-credentials-grant-flow) can be used to change **any** identity\'s password.  \"API authority\" refers to a token that only has the \"client_credentials\" grant type. 
         * @summary Set Identity\'s Password
         * @param {PasswordChangeRequest} passwordChangeRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async setPassword(passwordChangeRequest: PasswordChangeRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordChangeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setPassword(passwordChangeRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PasswordManagementApi - factory interface
 * @export
 */
export const PasswordManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PasswordManagementApiFp(configuration)
    return {
        /**
         * This API returns the status of a password change request. A token with identity owner or trusted API client application authority is required to call this API.
         * @summary Get Password Change Request Status
         * @param {string} id Password change request ID
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordChangeStatus(id: string, axiosOptions?: any): AxiosPromise<PasswordStatus> {
            return localVarFp.getPasswordChangeStatus(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API is used to query password related information.   A token with [API authority](https://developer.sailpoint.com/idn/api/authentication#client-credentials-grant-flow)  is required to call this API.  \"API authority\" refers to a token that only has the \"client_credentials\"  grant type, and therefore no user context. A [personal access token](https://developer.sailpoint.com/idn/api/authentication#personal-access-tokens)  or a token generated with the [authorization_code](https://developer.sailpoint.com/idn/api/authentication#authorization-code-grant-flow)  grant type will **NOT** work on this endpoint, and a `403 Forbidden` response  will be returned. 
         * @summary Query Password Info
         * @param {PasswordInfoQueryDTO} passwordInfoQueryDTO 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        queryPasswordInfo(passwordInfoQueryDTO: PasswordInfoQueryDTO, axiosOptions?: any): AxiosPromise<PasswordInfo> {
            return localVarFp.queryPasswordInfo(passwordInfoQueryDTO, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API is used to set a password for an identity.   An identity can change their own password if they use a token generated by their IDN user, such as a [personal access token](https://developer.sailpoint.com/idn/api/authentication#personal-access-tokens) or [\"authorization_code\" derived OAuth token](https://developer.sailpoint.com/idn/api/authentication#authorization-code-grant-flow).  A token with [API authority](https://developer.sailpoint.com/idn/api/authentication#client-credentials-grant-flow) can be used to change **any** identity\'s password.  \"API authority\" refers to a token that only has the \"client_credentials\" grant type. 
         * @summary Set Identity\'s Password
         * @param {PasswordChangeRequest} passwordChangeRequest 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        setPassword(passwordChangeRequest: PasswordChangeRequest, axiosOptions?: any): AxiosPromise<PasswordChangeResponse> {
            return localVarFp.setPassword(passwordChangeRequest, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getPasswordChangeStatus operation in PasswordManagementApi.
 * @export
 * @interface PasswordManagementApiGetPasswordChangeStatusRequest
 */
export interface PasswordManagementApiGetPasswordChangeStatusRequest {
    /**
     * Password change request ID
     * @type {string}
     * @memberof PasswordManagementApiGetPasswordChangeStatus
     */
    readonly id: string
}

/**
 * Request parameters for queryPasswordInfo operation in PasswordManagementApi.
 * @export
 * @interface PasswordManagementApiQueryPasswordInfoRequest
 */
export interface PasswordManagementApiQueryPasswordInfoRequest {
    /**
     * 
     * @type {PasswordInfoQueryDTO}
     * @memberof PasswordManagementApiQueryPasswordInfo
     */
    readonly passwordInfoQueryDTO: PasswordInfoQueryDTO
}

/**
 * Request parameters for setPassword operation in PasswordManagementApi.
 * @export
 * @interface PasswordManagementApiSetPasswordRequest
 */
export interface PasswordManagementApiSetPasswordRequest {
    /**
     * 
     * @type {PasswordChangeRequest}
     * @memberof PasswordManagementApiSetPassword
     */
    readonly passwordChangeRequest: PasswordChangeRequest
}

/**
 * PasswordManagementApi - object-oriented interface
 * @export
 * @class PasswordManagementApi
 * @extends {BaseAPI}
 */
export class PasswordManagementApi extends BaseAPI {
    /**
     * This API returns the status of a password change request. A token with identity owner or trusted API client application authority is required to call this API.
     * @summary Get Password Change Request Status
     * @param {PasswordManagementApiGetPasswordChangeStatusRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordManagementApi
     */
    public getPasswordChangeStatus(requestParameters: PasswordManagementApiGetPasswordChangeStatusRequest, axiosOptions?: AxiosRequestConfig) {
        return PasswordManagementApiFp(this.configuration).getPasswordChangeStatus(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API is used to query password related information.   A token with [API authority](https://developer.sailpoint.com/idn/api/authentication#client-credentials-grant-flow)  is required to call this API.  \"API authority\" refers to a token that only has the \"client_credentials\"  grant type, and therefore no user context. A [personal access token](https://developer.sailpoint.com/idn/api/authentication#personal-access-tokens)  or a token generated with the [authorization_code](https://developer.sailpoint.com/idn/api/authentication#authorization-code-grant-flow)  grant type will **NOT** work on this endpoint, and a `403 Forbidden` response  will be returned. 
     * @summary Query Password Info
     * @param {PasswordManagementApiQueryPasswordInfoRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordManagementApi
     */
    public queryPasswordInfo(requestParameters: PasswordManagementApiQueryPasswordInfoRequest, axiosOptions?: AxiosRequestConfig) {
        return PasswordManagementApiFp(this.configuration).queryPasswordInfo(requestParameters.passwordInfoQueryDTO, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API is used to set a password for an identity.   An identity can change their own password if they use a token generated by their IDN user, such as a [personal access token](https://developer.sailpoint.com/idn/api/authentication#personal-access-tokens) or [\"authorization_code\" derived OAuth token](https://developer.sailpoint.com/idn/api/authentication#authorization-code-grant-flow).  A token with [API authority](https://developer.sailpoint.com/idn/api/authentication#client-credentials-grant-flow) can be used to change **any** identity\'s password.  \"API authority\" refers to a token that only has the \"client_credentials\" grant type. 
     * @summary Set Identity\'s Password
     * @param {PasswordManagementApiSetPasswordRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordManagementApi
     */
    public setPassword(requestParameters: PasswordManagementApiSetPasswordRequest, axiosOptions?: AxiosRequestConfig) {
        return PasswordManagementApiFp(this.configuration).setPassword(requestParameters.passwordChangeRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PersonalAccessTokensApi - axios parameter creator
 * @export
 */
export const PersonalAccessTokensApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This creates a personal access token.
         * @summary Create Personal Access Token
         * @param {CreatePersonalAccessTokenRequest} createPersonalAccessTokenRequest Name and scope of personal access token.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createPersonalAccessToken: async (createPersonalAccessTokenRequest: CreatePersonalAccessTokenRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPersonalAccessTokenRequest' is not null or undefined
            assertParamExists('createPersonalAccessToken', 'createPersonalAccessTokenRequest', createPersonalAccessTokenRequest)
            const localVarPath = `/personal-access-tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPersonalAccessTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This deletes a personal access token.
         * @summary Delete Personal Access Token
         * @param {string} id The personal access token id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deletePersonalAccessToken: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePersonalAccessToken', 'id', id)
            const localVarPath = `/personal-access-tokens/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a collection of personal access tokens associated with the optional `owner-id`.  query parameter. If the `owner-id` query parameter is omitted, all personal access tokens  for a tenant will be retrieved, but the caller must have the \'idn:all-personal-access-tokens:read\' right.
         * @summary List Personal Access Tokens
         * @param {string} [ownerId] The identity ID of the owner whose personal access tokens should be listed.  If \&quot;me\&quot;, the caller should have the following right: \&#39;idn:my-personal-access-tokens:read\&#39; If an actual owner ID or if the &#x60;owner-id&#x60; parameter is omitted in the request,  the caller should have the following right: \&#39;idn:all-personal-access-tokens:read\&#39;.  If the caller has the following right, then managed personal access tokens associated with &#x60;owner-id&#x60;  will be retrieved: \&#39;idn:managed-personal-access-tokens:read\&#39;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listPersonalAccessTokens: async (ownerId?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/personal-access-tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['owner-id'] = ownerId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This performs a targeted update to the field(s) of a Personal Access Token.
         * @summary Patch Personal Access Token
         * @param {string} id The Personal Access Token id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of OAuth client update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * scope 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchPersonalAccessToken: async (id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchPersonalAccessToken', 'id', id)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('patchPersonalAccessToken', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/personal-access-tokens/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonalAccessTokensApi - functional programming interface
 * @export
 */
export const PersonalAccessTokensApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PersonalAccessTokensApiAxiosParamCreator(configuration)
    return {
        /**
         * This creates a personal access token.
         * @summary Create Personal Access Token
         * @param {CreatePersonalAccessTokenRequest} createPersonalAccessTokenRequest Name and scope of personal access token.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createPersonalAccessToken(createPersonalAccessTokenRequest: CreatePersonalAccessTokenRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePersonalAccessTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPersonalAccessToken(createPersonalAccessTokenRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This deletes a personal access token.
         * @summary Delete Personal Access Token
         * @param {string} id The personal access token id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deletePersonalAccessToken(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePersonalAccessToken(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a collection of personal access tokens associated with the optional `owner-id`.  query parameter. If the `owner-id` query parameter is omitted, all personal access tokens  for a tenant will be retrieved, but the caller must have the \'idn:all-personal-access-tokens:read\' right.
         * @summary List Personal Access Tokens
         * @param {string} [ownerId] The identity ID of the owner whose personal access tokens should be listed.  If \&quot;me\&quot;, the caller should have the following right: \&#39;idn:my-personal-access-tokens:read\&#39; If an actual owner ID or if the &#x60;owner-id&#x60; parameter is omitted in the request,  the caller should have the following right: \&#39;idn:all-personal-access-tokens:read\&#39;.  If the caller has the following right, then managed personal access tokens associated with &#x60;owner-id&#x60;  will be retrieved: \&#39;idn:managed-personal-access-tokens:read\&#39;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listPersonalAccessTokens(ownerId?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetPersonalAccessTokenResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPersonalAccessTokens(ownerId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This performs a targeted update to the field(s) of a Personal Access Token.
         * @summary Patch Personal Access Token
         * @param {string} id The Personal Access Token id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of OAuth client update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * scope 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchPersonalAccessToken(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPersonalAccessTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchPersonalAccessToken(id, jsonPatchOperation, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PersonalAccessTokensApi - factory interface
 * @export
 */
export const PersonalAccessTokensApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PersonalAccessTokensApiFp(configuration)
    return {
        /**
         * This creates a personal access token.
         * @summary Create Personal Access Token
         * @param {CreatePersonalAccessTokenRequest} createPersonalAccessTokenRequest Name and scope of personal access token.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createPersonalAccessToken(createPersonalAccessTokenRequest: CreatePersonalAccessTokenRequest, axiosOptions?: any): AxiosPromise<CreatePersonalAccessTokenResponse> {
            return localVarFp.createPersonalAccessToken(createPersonalAccessTokenRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This deletes a personal access token.
         * @summary Delete Personal Access Token
         * @param {string} id The personal access token id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deletePersonalAccessToken(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deletePersonalAccessToken(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a collection of personal access tokens associated with the optional `owner-id`.  query parameter. If the `owner-id` query parameter is omitted, all personal access tokens  for a tenant will be retrieved, but the caller must have the \'idn:all-personal-access-tokens:read\' right.
         * @summary List Personal Access Tokens
         * @param {string} [ownerId] The identity ID of the owner whose personal access tokens should be listed.  If \&quot;me\&quot;, the caller should have the following right: \&#39;idn:my-personal-access-tokens:read\&#39; If an actual owner ID or if the &#x60;owner-id&#x60; parameter is omitted in the request,  the caller should have the following right: \&#39;idn:all-personal-access-tokens:read\&#39;.  If the caller has the following right, then managed personal access tokens associated with &#x60;owner-id&#x60;  will be retrieved: \&#39;idn:managed-personal-access-tokens:read\&#39;
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listPersonalAccessTokens(ownerId?: string, axiosOptions?: any): AxiosPromise<Array<GetPersonalAccessTokenResponse>> {
            return localVarFp.listPersonalAccessTokens(ownerId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This performs a targeted update to the field(s) of a Personal Access Token.
         * @summary Patch Personal Access Token
         * @param {string} id The Personal Access Token id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of OAuth client update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * scope 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchPersonalAccessToken(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: any): AxiosPromise<GetPersonalAccessTokenResponse> {
            return localVarFp.patchPersonalAccessToken(id, jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createPersonalAccessToken operation in PersonalAccessTokensApi.
 * @export
 * @interface PersonalAccessTokensApiCreatePersonalAccessTokenRequest
 */
export interface PersonalAccessTokensApiCreatePersonalAccessTokenRequest {
    /**
     * Name and scope of personal access token.
     * @type {CreatePersonalAccessTokenRequest}
     * @memberof PersonalAccessTokensApiCreatePersonalAccessToken
     */
    readonly createPersonalAccessTokenRequest: CreatePersonalAccessTokenRequest
}

/**
 * Request parameters for deletePersonalAccessToken operation in PersonalAccessTokensApi.
 * @export
 * @interface PersonalAccessTokensApiDeletePersonalAccessTokenRequest
 */
export interface PersonalAccessTokensApiDeletePersonalAccessTokenRequest {
    /**
     * The personal access token id
     * @type {string}
     * @memberof PersonalAccessTokensApiDeletePersonalAccessToken
     */
    readonly id: string
}

/**
 * Request parameters for listPersonalAccessTokens operation in PersonalAccessTokensApi.
 * @export
 * @interface PersonalAccessTokensApiListPersonalAccessTokensRequest
 */
export interface PersonalAccessTokensApiListPersonalAccessTokensRequest {
    /**
     * The identity ID of the owner whose personal access tokens should be listed.  If \&quot;me\&quot;, the caller should have the following right: \&#39;idn:my-personal-access-tokens:read\&#39; If an actual owner ID or if the &#x60;owner-id&#x60; parameter is omitted in the request,  the caller should have the following right: \&#39;idn:all-personal-access-tokens:read\&#39;.  If the caller has the following right, then managed personal access tokens associated with &#x60;owner-id&#x60;  will be retrieved: \&#39;idn:managed-personal-access-tokens:read\&#39;
     * @type {string}
     * @memberof PersonalAccessTokensApiListPersonalAccessTokens
     */
    readonly ownerId?: string
}

/**
 * Request parameters for patchPersonalAccessToken operation in PersonalAccessTokensApi.
 * @export
 * @interface PersonalAccessTokensApiPatchPersonalAccessTokenRequest
 */
export interface PersonalAccessTokensApiPatchPersonalAccessTokenRequest {
    /**
     * The Personal Access Token id
     * @type {string}
     * @memberof PersonalAccessTokensApiPatchPersonalAccessToken
     */
    readonly id: string

    /**
     * A list of OAuth client update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  The following fields are patchable: * name * scope 
     * @type {Array<JsonPatchOperation>}
     * @memberof PersonalAccessTokensApiPatchPersonalAccessToken
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * PersonalAccessTokensApi - object-oriented interface
 * @export
 * @class PersonalAccessTokensApi
 * @extends {BaseAPI}
 */
export class PersonalAccessTokensApi extends BaseAPI {
    /**
     * This creates a personal access token.
     * @summary Create Personal Access Token
     * @param {PersonalAccessTokensApiCreatePersonalAccessTokenRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccessTokensApi
     */
    public createPersonalAccessToken(requestParameters: PersonalAccessTokensApiCreatePersonalAccessTokenRequest, axiosOptions?: AxiosRequestConfig) {
        return PersonalAccessTokensApiFp(this.configuration).createPersonalAccessToken(requestParameters.createPersonalAccessTokenRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This deletes a personal access token.
     * @summary Delete Personal Access Token
     * @param {PersonalAccessTokensApiDeletePersonalAccessTokenRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccessTokensApi
     */
    public deletePersonalAccessToken(requestParameters: PersonalAccessTokensApiDeletePersonalAccessTokenRequest, axiosOptions?: AxiosRequestConfig) {
        return PersonalAccessTokensApiFp(this.configuration).deletePersonalAccessToken(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a collection of personal access tokens associated with the optional `owner-id`.  query parameter. If the `owner-id` query parameter is omitted, all personal access tokens  for a tenant will be retrieved, but the caller must have the \'idn:all-personal-access-tokens:read\' right.
     * @summary List Personal Access Tokens
     * @param {PersonalAccessTokensApiListPersonalAccessTokensRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccessTokensApi
     */
    public listPersonalAccessTokens(requestParameters: PersonalAccessTokensApiListPersonalAccessTokensRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return PersonalAccessTokensApiFp(this.configuration).listPersonalAccessTokens(requestParameters.ownerId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This performs a targeted update to the field(s) of a Personal Access Token.
     * @summary Patch Personal Access Token
     * @param {PersonalAccessTokensApiPatchPersonalAccessTokenRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccessTokensApi
     */
    public patchPersonalAccessToken(requestParameters: PersonalAccessTokensApiPatchPersonalAccessTokenRequest, axiosOptions?: AxiosRequestConfig) {
        return PersonalAccessTokensApiFp(this.configuration).patchPersonalAccessToken(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PublicIdentitiesApi - axios parameter creator
 * @export
 */
export const PublicIdentitiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a list of public identities
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **alias**: *eq, sw*  **email**: *eq, sw*  **firstname**: *eq, sw*  **lastname**: *eq, sw*
         * @param {boolean} [addCoreFilters] If *true*, only get identities which satisfy ALL the following criteria in addition to any criteria specified by *filters*:   - Should be either correlated or protected.   - Should not be \&quot;spadmin\&quot; or \&quot;cloudadmin\&quot;.   - uid should not be null.   - lastname should not be null.   - email should not be null.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPublicIdentities: async (limit?: number, offset?: number, count?: boolean, filters?: string, addCoreFilters?: boolean, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/public-identities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (addCoreFilters !== undefined) {
                localVarQueryParameter['add-core-filters'] = addCoreFilters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * PublicIdentitiesApi - functional programming interface
 * @export
 */
export const PublicIdentitiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PublicIdentitiesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a list of public identities
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **alias**: *eq, sw*  **email**: *eq, sw*  **firstname**: *eq, sw*  **lastname**: *eq, sw*
         * @param {boolean} [addCoreFilters] If *true*, only get identities which satisfy ALL the following criteria in addition to any criteria specified by *filters*:   - Should be either correlated or protected.   - Should not be \&quot;spadmin\&quot; or \&quot;cloudadmin\&quot;.   - uid should not be null.   - lastname should not be null.   - email should not be null.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicIdentities(limit?: number, offset?: number, count?: boolean, filters?: string, addCoreFilters?: boolean, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PublicIdentity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicIdentities(limit, offset, count, filters, addCoreFilters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PublicIdentitiesApi - factory interface
 * @export
 */
export const PublicIdentitiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PublicIdentitiesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a list of public identities
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **alias**: *eq, sw*  **email**: *eq, sw*  **firstname**: *eq, sw*  **lastname**: *eq, sw*
         * @param {boolean} [addCoreFilters] If *true*, only get identities which satisfy ALL the following criteria in addition to any criteria specified by *filters*:   - Should be either correlated or protected.   - Should not be \&quot;spadmin\&quot; or \&quot;cloudadmin\&quot;.   - uid should not be null.   - lastname should not be null.   - email should not be null.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPublicIdentities(limit?: number, offset?: number, count?: boolean, filters?: string, addCoreFilters?: boolean, sorters?: string, axiosOptions?: any): AxiosPromise<Array<PublicIdentity>> {
            return localVarFp.getPublicIdentities(limit, offset, count, filters, addCoreFilters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getPublicIdentities operation in PublicIdentitiesApi.
 * @export
 * @interface PublicIdentitiesApiGetPublicIdentitiesRequest
 */
export interface PublicIdentitiesApiGetPublicIdentitiesRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof PublicIdentitiesApiGetPublicIdentities
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof PublicIdentitiesApiGetPublicIdentities
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof PublicIdentitiesApiGetPublicIdentities
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **alias**: *eq, sw*  **email**: *eq, sw*  **firstname**: *eq, sw*  **lastname**: *eq, sw*
     * @type {string}
     * @memberof PublicIdentitiesApiGetPublicIdentities
     */
    readonly filters?: string

    /**
     * If *true*, only get identities which satisfy ALL the following criteria in addition to any criteria specified by *filters*:   - Should be either correlated or protected.   - Should not be \&quot;spadmin\&quot; or \&quot;cloudadmin\&quot;.   - uid should not be null.   - lastname should not be null.   - email should not be null.
     * @type {boolean}
     * @memberof PublicIdentitiesApiGetPublicIdentities
     */
    readonly addCoreFilters?: boolean

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
     * @type {string}
     * @memberof PublicIdentitiesApiGetPublicIdentities
     */
    readonly sorters?: string
}

/**
 * PublicIdentitiesApi - object-oriented interface
 * @export
 * @class PublicIdentitiesApi
 * @extends {BaseAPI}
 */
export class PublicIdentitiesApi extends BaseAPI {
    /**
     * 
     * @summary Get a list of public identities
     * @param {PublicIdentitiesApiGetPublicIdentitiesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicIdentitiesApi
     */
    public getPublicIdentities(requestParameters: PublicIdentitiesApiGetPublicIdentitiesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return PublicIdentitiesApiFp(this.configuration).getPublicIdentities(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.addCoreFilters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PublicIdentitiesConfigApi - axios parameter creator
 * @export
 */
export const PublicIdentitiesConfigApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the publicly visible attributes of an identity available to request approvers for Access Requests and Certification Campaigns. A token with ORG ADMIN authority is required to call this API.
         * @summary Get the Public Identities Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPublicIdentityConfig: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/public-identities-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Updates the publicly visible attributes of an identity available to request approvers for Access Requests and Certification Campaigns. A token with ORG ADMIN authority is required to call this API.
         * @summary Update the Public Identities Configuration
         * @param {PublicIdentityConfig} publicIdentityConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updatePublicIdentityConfig: async (publicIdentityConfig: PublicIdentityConfig, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'publicIdentityConfig' is not null or undefined
            assertParamExists('updatePublicIdentityConfig', 'publicIdentityConfig', publicIdentityConfig)
            const localVarPath = `/public-identities-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(publicIdentityConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * PublicIdentitiesConfigApi - functional programming interface
 * @export
 */
export const PublicIdentitiesConfigApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PublicIdentitiesConfigApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the publicly visible attributes of an identity available to request approvers for Access Requests and Certification Campaigns. A token with ORG ADMIN authority is required to call this API.
         * @summary Get the Public Identities Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicIdentityConfig(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicIdentityConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicIdentityConfig(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the publicly visible attributes of an identity available to request approvers for Access Requests and Certification Campaigns. A token with ORG ADMIN authority is required to call this API.
         * @summary Update the Public Identities Configuration
         * @param {PublicIdentityConfig} publicIdentityConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updatePublicIdentityConfig(publicIdentityConfig: PublicIdentityConfig, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicIdentityConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePublicIdentityConfig(publicIdentityConfig, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PublicIdentitiesConfigApi - factory interface
 * @export
 */
export const PublicIdentitiesConfigApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PublicIdentitiesConfigApiFp(configuration)
    return {
        /**
         * Returns the publicly visible attributes of an identity available to request approvers for Access Requests and Certification Campaigns. A token with ORG ADMIN authority is required to call this API.
         * @summary Get the Public Identities Configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPublicIdentityConfig(axiosOptions?: any): AxiosPromise<PublicIdentityConfig> {
            return localVarFp.getPublicIdentityConfig(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Updates the publicly visible attributes of an identity available to request approvers for Access Requests and Certification Campaigns. A token with ORG ADMIN authority is required to call this API.
         * @summary Update the Public Identities Configuration
         * @param {PublicIdentityConfig} publicIdentityConfig 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updatePublicIdentityConfig(publicIdentityConfig: PublicIdentityConfig, axiosOptions?: any): AxiosPromise<PublicIdentityConfig> {
            return localVarFp.updatePublicIdentityConfig(publicIdentityConfig, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for updatePublicIdentityConfig operation in PublicIdentitiesConfigApi.
 * @export
 * @interface PublicIdentitiesConfigApiUpdatePublicIdentityConfigRequest
 */
export interface PublicIdentitiesConfigApiUpdatePublicIdentityConfigRequest {
    /**
     * 
     * @type {PublicIdentityConfig}
     * @memberof PublicIdentitiesConfigApiUpdatePublicIdentityConfig
     */
    readonly publicIdentityConfig: PublicIdentityConfig
}

/**
 * PublicIdentitiesConfigApi - object-oriented interface
 * @export
 * @class PublicIdentitiesConfigApi
 * @extends {BaseAPI}
 */
export class PublicIdentitiesConfigApi extends BaseAPI {
    /**
     * Returns the publicly visible attributes of an identity available to request approvers for Access Requests and Certification Campaigns. A token with ORG ADMIN authority is required to call this API.
     * @summary Get the Public Identities Configuration
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicIdentitiesConfigApi
     */
    public getPublicIdentityConfig(axiosOptions?: AxiosRequestConfig) {
        return PublicIdentitiesConfigApiFp(this.configuration).getPublicIdentityConfig(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the publicly visible attributes of an identity available to request approvers for Access Requests and Certification Campaigns. A token with ORG ADMIN authority is required to call this API.
     * @summary Update the Public Identities Configuration
     * @param {PublicIdentitiesConfigApiUpdatePublicIdentityConfigRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicIdentitiesConfigApi
     */
    public updatePublicIdentityConfig(requestParameters: PublicIdentitiesConfigApiUpdatePublicIdentityConfigRequest, axiosOptions?: AxiosRequestConfig) {
        return PublicIdentitiesConfigApiFp(this.configuration).updatePublicIdentityConfig(requestParameters.publicIdentityConfig, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RequestableObjectsApi - axios parameter creator
 * @export
 */
export const RequestableObjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint returns a list of acccess items that that can be requested through the Access Request endpoints. Access items are marked with AVAILABLE, PENDING or ASSIGNED with respect to the identity provided using *identity-id* query param. Any authenticated token can call this endpoint to see their requestable access items. A token with ORG_ADMIN authority is required to call this endpoint to return a list of all of the requestable access items for the org or for another identity.
         * @summary Requestable Objects List
         * @param {string} [identityId] If present, the value returns only requestable objects for the specified identity.  * Admin users can call this with any identity ID value.  * Non-admin users can only specify *me* or pass their own identity ID value.  * If absent, returns a list of all requestable objects for the tenant. Only admin users can make such a call. In this case, the available, pending, assigned accesses will not be annotated in the result.
         * @param {Array<RequestableObjectType>} [types] Filters the results to the specified type/types, where each type is one of ROLE or ACCESS_PROFILE. If absent, all types are returned. Support for additional types may be added in the future without notice.
         * @param {string} [term] It allows searching requestable access items with a partial match on the name or description. If term is provided, then the *filter* query parameter will be ignored.
         * @param {Array<RequestableObjectRequestStatus>} [statuses] Filters the result to the specified status/statuses, where each status is one of AVAILABLE, ASSIGNED, or PENDING. It is an error to specify this parameter without also specifying an *identity-id* parameter. Additional statuses may be added in the future without notice.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, in, sw* 
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name** 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listRequestableObjects: async (identityId?: string, types?: Array<RequestableObjectType>, term?: string, statuses?: Array<RequestableObjectRequestStatus>, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/requestable-objects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (identityId !== undefined) {
                localVarQueryParameter['identity-id'] = identityId;
            }

            if (types) {
                localVarQueryParameter['types'] = types.join(COLLECTION_FORMATS.csv);
            }

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }

            if (statuses) {
                localVarQueryParameter['statuses'] = statuses.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * RequestableObjectsApi - functional programming interface
 * @export
 */
export const RequestableObjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RequestableObjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint returns a list of acccess items that that can be requested through the Access Request endpoints. Access items are marked with AVAILABLE, PENDING or ASSIGNED with respect to the identity provided using *identity-id* query param. Any authenticated token can call this endpoint to see their requestable access items. A token with ORG_ADMIN authority is required to call this endpoint to return a list of all of the requestable access items for the org or for another identity.
         * @summary Requestable Objects List
         * @param {string} [identityId] If present, the value returns only requestable objects for the specified identity.  * Admin users can call this with any identity ID value.  * Non-admin users can only specify *me* or pass their own identity ID value.  * If absent, returns a list of all requestable objects for the tenant. Only admin users can make such a call. In this case, the available, pending, assigned accesses will not be annotated in the result.
         * @param {Array<RequestableObjectType>} [types] Filters the results to the specified type/types, where each type is one of ROLE or ACCESS_PROFILE. If absent, all types are returned. Support for additional types may be added in the future without notice.
         * @param {string} [term] It allows searching requestable access items with a partial match on the name or description. If term is provided, then the *filter* query parameter will be ignored.
         * @param {Array<RequestableObjectRequestStatus>} [statuses] Filters the result to the specified status/statuses, where each status is one of AVAILABLE, ASSIGNED, or PENDING. It is an error to specify this parameter without also specifying an *identity-id* parameter. Additional statuses may be added in the future without notice.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, in, sw* 
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name** 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listRequestableObjects(identityId?: string, types?: Array<RequestableObjectType>, term?: string, statuses?: Array<RequestableObjectRequestStatus>, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RequestableObject>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRequestableObjects(identityId, types, term, statuses, limit, offset, count, filters, sorters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RequestableObjectsApi - factory interface
 * @export
 */
export const RequestableObjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RequestableObjectsApiFp(configuration)
    return {
        /**
         * This endpoint returns a list of acccess items that that can be requested through the Access Request endpoints. Access items are marked with AVAILABLE, PENDING or ASSIGNED with respect to the identity provided using *identity-id* query param. Any authenticated token can call this endpoint to see their requestable access items. A token with ORG_ADMIN authority is required to call this endpoint to return a list of all of the requestable access items for the org or for another identity.
         * @summary Requestable Objects List
         * @param {string} [identityId] If present, the value returns only requestable objects for the specified identity.  * Admin users can call this with any identity ID value.  * Non-admin users can only specify *me* or pass their own identity ID value.  * If absent, returns a list of all requestable objects for the tenant. Only admin users can make such a call. In this case, the available, pending, assigned accesses will not be annotated in the result.
         * @param {Array<RequestableObjectType>} [types] Filters the results to the specified type/types, where each type is one of ROLE or ACCESS_PROFILE. If absent, all types are returned. Support for additional types may be added in the future without notice.
         * @param {string} [term] It allows searching requestable access items with a partial match on the name or description. If term is provided, then the *filter* query parameter will be ignored.
         * @param {Array<RequestableObjectRequestStatus>} [statuses] Filters the result to the specified status/statuses, where each status is one of AVAILABLE, ASSIGNED, or PENDING. It is an error to specify this parameter without also specifying an *identity-id* parameter. Additional statuses may be added in the future without notice.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, in, sw* 
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name** 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listRequestableObjects(identityId?: string, types?: Array<RequestableObjectType>, term?: string, statuses?: Array<RequestableObjectRequestStatus>, limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, axiosOptions?: any): AxiosPromise<Array<RequestableObject>> {
            return localVarFp.listRequestableObjects(identityId, types, term, statuses, limit, offset, count, filters, sorters, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for listRequestableObjects operation in RequestableObjectsApi.
 * @export
 * @interface RequestableObjectsApiListRequestableObjectsRequest
 */
export interface RequestableObjectsApiListRequestableObjectsRequest {
    /**
     * If present, the value returns only requestable objects for the specified identity.  * Admin users can call this with any identity ID value.  * Non-admin users can only specify *me* or pass their own identity ID value.  * If absent, returns a list of all requestable objects for the tenant. Only admin users can make such a call. In this case, the available, pending, assigned accesses will not be annotated in the result.
     * @type {string}
     * @memberof RequestableObjectsApiListRequestableObjects
     */
    readonly identityId?: string

    /**
     * Filters the results to the specified type/types, where each type is one of ROLE or ACCESS_PROFILE. If absent, all types are returned. Support for additional types may be added in the future without notice.
     * @type {Array<RequestableObjectType>}
     * @memberof RequestableObjectsApiListRequestableObjects
     */
    readonly types?: Array<RequestableObjectType>

    /**
     * It allows searching requestable access items with a partial match on the name or description. If term is provided, then the *filter* query parameter will be ignored.
     * @type {string}
     * @memberof RequestableObjectsApiListRequestableObjects
     */
    readonly term?: string

    /**
     * Filters the result to the specified status/statuses, where each status is one of AVAILABLE, ASSIGNED, or PENDING. It is an error to specify this parameter without also specifying an *identity-id* parameter. Additional statuses may be added in the future without notice.
     * @type {Array<RequestableObjectRequestStatus>}
     * @memberof RequestableObjectsApiListRequestableObjects
     */
    readonly statuses?: Array<RequestableObjectRequestStatus>

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof RequestableObjectsApiListRequestableObjects
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof RequestableObjectsApiListRequestableObjects
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof RequestableObjectsApiListRequestableObjects
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq, in, sw* 
     * @type {string}
     * @memberof RequestableObjectsApiListRequestableObjects
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name** 
     * @type {string}
     * @memberof RequestableObjectsApiListRequestableObjects
     */
    readonly sorters?: string
}

/**
 * RequestableObjectsApi - object-oriented interface
 * @export
 * @class RequestableObjectsApi
 * @extends {BaseAPI}
 */
export class RequestableObjectsApi extends BaseAPI {
    /**
     * This endpoint returns a list of acccess items that that can be requested through the Access Request endpoints. Access items are marked with AVAILABLE, PENDING or ASSIGNED with respect to the identity provided using *identity-id* query param. Any authenticated token can call this endpoint to see their requestable access items. A token with ORG_ADMIN authority is required to call this endpoint to return a list of all of the requestable access items for the org or for another identity.
     * @summary Requestable Objects List
     * @param {RequestableObjectsApiListRequestableObjectsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestableObjectsApi
     */
    public listRequestableObjects(requestParameters: RequestableObjectsApiListRequestableObjectsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return RequestableObjectsApiFp(this.configuration).listRequestableObjects(requestParameters.identityId, requestParameters.types, requestParameters.term, requestParameters.statuses, requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SavedSearchApi - axios parameter creator
 * @export
 */
export const SavedSearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new saved search. 
         * @summary Create a saved search
         * @param {SavedSearchCreateRequest} savedSearchCreateRequest The saved search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        savedSearchCreate: async (savedSearchCreateRequest: SavedSearchCreateRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'savedSearchCreateRequest' is not null or undefined
            assertParamExists('savedSearchCreate', 'savedSearchCreateRequest', savedSearchCreateRequest)
            const localVarPath = `/saved-searches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(savedSearchCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Deletes the specified saved search. 
         * @summary Delete a document by ID
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        savedSearchDelete: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('savedSearchDelete', 'id', id)
            const localVarPath = `/saved-searches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Executes the specified saved search. 
         * @summary Execute a saved search by ID
         * @param {string} id ID of the requested document.
         * @param {SearchArguments} searchArguments When saved search execution is triggered by a scheduled search, *scheduleId* will specify the ID of the triggering scheduled search.  If *scheduleId* is not specified (when execution is triggered by a UI test), the *owner* and *recipients* arguments must be provided. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        savedSearchExecute: async (id: string, searchArguments: SearchArguments, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('savedSearchExecute', 'id', id)
            // verify required parameter 'searchArguments' is not null or undefined
            assertParamExists('savedSearchExecute', 'searchArguments', searchArguments)
            const localVarPath = `/saved-searches/{id}/execute`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchArguments, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified saved search. 
         * @summary Return a saved search by ID
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        savedSearchGet: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('savedSearchGet', 'id', id)
            const localVarPath = `/saved-searches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of saved searches. 
         * @summary Return a list of Saved Searches
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] An expression used to constrain the result set using the filtering syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results).  Allowed filter properties: *owner.id*, *public*  Allowed filter operator: *eq*  **Example filters**:  &#x60;&#x60;&#x60;owner.id eq \&quot;0de46054-fe90-434a-b84e-c6b3359d0c64\&quot;&#x60;&#x60;&#x60; -- returns saved searches for the specified owner ID  &#x60;&#x60;&#x60;public eq true&#x60;&#x60;&#x60; -- returns all public saved searches  &#x60;&#x60;&#x60;owner.id eq me or public eq true&#x60;&#x60;&#x60; -- returns all of the current user\&#39;s saved searches as well as all public saved searches belonging to other users in the current org 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        savedSearchList: async (offset?: number, limit?: number, count?: boolean, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/saved-searches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing saved search. 
         * @summary Updates an existing saved search 
         * @param {string} id ID of the requested document.
         * @param {SavedSearch} savedSearch The saved search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        savedSearchUpdate: async (id: string, savedSearch: SavedSearch, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('savedSearchUpdate', 'id', id)
            // verify required parameter 'savedSearch' is not null or undefined
            assertParamExists('savedSearchUpdate', 'savedSearch', savedSearch)
            const localVarPath = `/saved-searches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(savedSearch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * SavedSearchApi - functional programming interface
 * @export
 */
export const SavedSearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SavedSearchApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new saved search. 
         * @summary Create a saved search
         * @param {SavedSearchCreateRequest} savedSearchCreateRequest The saved search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async savedSearchCreate(savedSearchCreateRequest: SavedSearchCreateRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SavedSearch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.savedSearchCreate(savedSearchCreateRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the specified saved search. 
         * @summary Delete a document by ID
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async savedSearchDelete(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.savedSearchDelete(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Executes the specified saved search. 
         * @summary Execute a saved search by ID
         * @param {string} id ID of the requested document.
         * @param {SearchArguments} searchArguments When saved search execution is triggered by a scheduled search, *scheduleId* will specify the ID of the triggering scheduled search.  If *scheduleId* is not specified (when execution is triggered by a UI test), the *owner* and *recipients* arguments must be provided. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async savedSearchExecute(id: string, searchArguments: SearchArguments, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.savedSearchExecute(id, searchArguments, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the specified saved search. 
         * @summary Return a saved search by ID
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async savedSearchGet(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SavedSearch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.savedSearchGet(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of saved searches. 
         * @summary Return a list of Saved Searches
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] An expression used to constrain the result set using the filtering syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results).  Allowed filter properties: *owner.id*, *public*  Allowed filter operator: *eq*  **Example filters**:  &#x60;&#x60;&#x60;owner.id eq \&quot;0de46054-fe90-434a-b84e-c6b3359d0c64\&quot;&#x60;&#x60;&#x60; -- returns saved searches for the specified owner ID  &#x60;&#x60;&#x60;public eq true&#x60;&#x60;&#x60; -- returns all public saved searches  &#x60;&#x60;&#x60;owner.id eq me or public eq true&#x60;&#x60;&#x60; -- returns all of the current user\&#39;s saved searches as well as all public saved searches belonging to other users in the current org 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async savedSearchList(offset?: number, limit?: number, count?: boolean, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SavedSearch>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.savedSearchList(offset, limit, count, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates an existing saved search. 
         * @summary Updates an existing saved search 
         * @param {string} id ID of the requested document.
         * @param {SavedSearch} savedSearch The saved search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async savedSearchUpdate(id: string, savedSearch: SavedSearch, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SavedSearch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.savedSearchUpdate(id, savedSearch, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SavedSearchApi - factory interface
 * @export
 */
export const SavedSearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SavedSearchApiFp(configuration)
    return {
        /**
         * Creates a new saved search. 
         * @summary Create a saved search
         * @param {SavedSearchCreateRequest} savedSearchCreateRequest The saved search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        savedSearchCreate(savedSearchCreateRequest: SavedSearchCreateRequest, axiosOptions?: any): AxiosPromise<SavedSearch> {
            return localVarFp.savedSearchCreate(savedSearchCreateRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the specified saved search. 
         * @summary Delete a document by ID
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        savedSearchDelete(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.savedSearchDelete(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Executes the specified saved search. 
         * @summary Execute a saved search by ID
         * @param {string} id ID of the requested document.
         * @param {SearchArguments} searchArguments When saved search execution is triggered by a scheduled search, *scheduleId* will specify the ID of the triggering scheduled search.  If *scheduleId* is not specified (when execution is triggered by a UI test), the *owner* and *recipients* arguments must be provided. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        savedSearchExecute(id: string, searchArguments: SearchArguments, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.savedSearchExecute(id, searchArguments, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Returns the specified saved search. 
         * @summary Return a saved search by ID
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        savedSearchGet(id: string, axiosOptions?: any): AxiosPromise<SavedSearch> {
            return localVarFp.savedSearchGet(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of saved searches. 
         * @summary Return a list of Saved Searches
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] An expression used to constrain the result set using the filtering syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results).  Allowed filter properties: *owner.id*, *public*  Allowed filter operator: *eq*  **Example filters**:  &#x60;&#x60;&#x60;owner.id eq \&quot;0de46054-fe90-434a-b84e-c6b3359d0c64\&quot;&#x60;&#x60;&#x60; -- returns saved searches for the specified owner ID  &#x60;&#x60;&#x60;public eq true&#x60;&#x60;&#x60; -- returns all public saved searches  &#x60;&#x60;&#x60;owner.id eq me or public eq true&#x60;&#x60;&#x60; -- returns all of the current user\&#39;s saved searches as well as all public saved searches belonging to other users in the current org 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        savedSearchList(offset?: number, limit?: number, count?: boolean, filters?: string, axiosOptions?: any): AxiosPromise<Array<SavedSearch>> {
            return localVarFp.savedSearchList(offset, limit, count, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing saved search. 
         * @summary Updates an existing saved search 
         * @param {string} id ID of the requested document.
         * @param {SavedSearch} savedSearch The saved search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        savedSearchUpdate(id: string, savedSearch: SavedSearch, axiosOptions?: any): AxiosPromise<SavedSearch> {
            return localVarFp.savedSearchUpdate(id, savedSearch, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for savedSearchCreate operation in SavedSearchApi.
 * @export
 * @interface SavedSearchApiSavedSearchCreateRequest
 */
export interface SavedSearchApiSavedSearchCreateRequest {
    /**
     * The saved search to persist.
     * @type {SavedSearchCreateRequest}
     * @memberof SavedSearchApiSavedSearchCreate
     */
    readonly savedSearchCreateRequest: SavedSearchCreateRequest
}

/**
 * Request parameters for savedSearchDelete operation in SavedSearchApi.
 * @export
 * @interface SavedSearchApiSavedSearchDeleteRequest
 */
export interface SavedSearchApiSavedSearchDeleteRequest {
    /**
     * ID of the requested document.
     * @type {string}
     * @memberof SavedSearchApiSavedSearchDelete
     */
    readonly id: string
}

/**
 * Request parameters for savedSearchExecute operation in SavedSearchApi.
 * @export
 * @interface SavedSearchApiSavedSearchExecuteRequest
 */
export interface SavedSearchApiSavedSearchExecuteRequest {
    /**
     * ID of the requested document.
     * @type {string}
     * @memberof SavedSearchApiSavedSearchExecute
     */
    readonly id: string

    /**
     * When saved search execution is triggered by a scheduled search, *scheduleId* will specify the ID of the triggering scheduled search.  If *scheduleId* is not specified (when execution is triggered by a UI test), the *owner* and *recipients* arguments must be provided. 
     * @type {SearchArguments}
     * @memberof SavedSearchApiSavedSearchExecute
     */
    readonly searchArguments: SearchArguments
}

/**
 * Request parameters for savedSearchGet operation in SavedSearchApi.
 * @export
 * @interface SavedSearchApiSavedSearchGetRequest
 */
export interface SavedSearchApiSavedSearchGetRequest {
    /**
     * ID of the requested document.
     * @type {string}
     * @memberof SavedSearchApiSavedSearchGet
     */
    readonly id: string
}

/**
 * Request parameters for savedSearchList operation in SavedSearchApi.
 * @export
 * @interface SavedSearchApiSavedSearchListRequest
 */
export interface SavedSearchApiSavedSearchListRequest {
    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SavedSearchApiSavedSearchList
     */
    readonly offset?: number

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SavedSearchApiSavedSearchList
     */
    readonly limit?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof SavedSearchApiSavedSearchList
     */
    readonly count?: boolean

    /**
     * An expression used to constrain the result set using the filtering syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results).  Allowed filter properties: *owner.id*, *public*  Allowed filter operator: *eq*  **Example filters**:  &#x60;&#x60;&#x60;owner.id eq \&quot;0de46054-fe90-434a-b84e-c6b3359d0c64\&quot;&#x60;&#x60;&#x60; -- returns saved searches for the specified owner ID  &#x60;&#x60;&#x60;public eq true&#x60;&#x60;&#x60; -- returns all public saved searches  &#x60;&#x60;&#x60;owner.id eq me or public eq true&#x60;&#x60;&#x60; -- returns all of the current user\&#39;s saved searches as well as all public saved searches belonging to other users in the current org 
     * @type {string}
     * @memberof SavedSearchApiSavedSearchList
     */
    readonly filters?: string
}

/**
 * Request parameters for savedSearchUpdate operation in SavedSearchApi.
 * @export
 * @interface SavedSearchApiSavedSearchUpdateRequest
 */
export interface SavedSearchApiSavedSearchUpdateRequest {
    /**
     * ID of the requested document.
     * @type {string}
     * @memberof SavedSearchApiSavedSearchUpdate
     */
    readonly id: string

    /**
     * The saved search to persist.
     * @type {SavedSearch}
     * @memberof SavedSearchApiSavedSearchUpdate
     */
    readonly savedSearch: SavedSearch
}

/**
 * SavedSearchApi - object-oriented interface
 * @export
 * @class SavedSearchApi
 * @extends {BaseAPI}
 */
export class SavedSearchApi extends BaseAPI {
    /**
     * Creates a new saved search. 
     * @summary Create a saved search
     * @param {SavedSearchApiSavedSearchCreateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedSearchApi
     */
    public savedSearchCreate(requestParameters: SavedSearchApiSavedSearchCreateRequest, axiosOptions?: AxiosRequestConfig) {
        return SavedSearchApiFp(this.configuration).savedSearchCreate(requestParameters.savedSearchCreateRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the specified saved search. 
     * @summary Delete a document by ID
     * @param {SavedSearchApiSavedSearchDeleteRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedSearchApi
     */
    public savedSearchDelete(requestParameters: SavedSearchApiSavedSearchDeleteRequest, axiosOptions?: AxiosRequestConfig) {
        return SavedSearchApiFp(this.configuration).savedSearchDelete(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Executes the specified saved search. 
     * @summary Execute a saved search by ID
     * @param {SavedSearchApiSavedSearchExecuteRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedSearchApi
     */
    public savedSearchExecute(requestParameters: SavedSearchApiSavedSearchExecuteRequest, axiosOptions?: AxiosRequestConfig) {
        return SavedSearchApiFp(this.configuration).savedSearchExecute(requestParameters.id, requestParameters.searchArguments, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the specified saved search. 
     * @summary Return a saved search by ID
     * @param {SavedSearchApiSavedSearchGetRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedSearchApi
     */
    public savedSearchGet(requestParameters: SavedSearchApiSavedSearchGetRequest, axiosOptions?: AxiosRequestConfig) {
        return SavedSearchApiFp(this.configuration).savedSearchGet(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of saved searches. 
     * @summary Return a list of Saved Searches
     * @param {SavedSearchApiSavedSearchListRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedSearchApi
     */
    public savedSearchList(requestParameters: SavedSearchApiSavedSearchListRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return SavedSearchApiFp(this.configuration).savedSearchList(requestParameters.offset, requestParameters.limit, requestParameters.count, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing saved search. 
     * @summary Updates an existing saved search 
     * @param {SavedSearchApiSavedSearchUpdateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedSearchApi
     */
    public savedSearchUpdate(requestParameters: SavedSearchApiSavedSearchUpdateRequest, axiosOptions?: AxiosRequestConfig) {
        return SavedSearchApiFp(this.configuration).savedSearchUpdate(requestParameters.id, requestParameters.savedSearch, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ScheduledSearchApi - axios parameter creator
 * @export
 */
export const ScheduledSearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new scheduled search. 
         * @summary Create a new scheduled search
         * @param {ScheduledSearchCreateRequest} scheduledSearchCreateRequest The scheduled search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        scheduledSearchCreate: async (scheduledSearchCreateRequest: ScheduledSearchCreateRequest, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduledSearchCreateRequest' is not null or undefined
            assertParamExists('scheduledSearchCreate', 'scheduledSearchCreateRequest', scheduledSearchCreateRequest)
            const localVarPath = `/scheduled-searches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scheduledSearchCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Deletes the specified scheduled search. 
         * @summary Delete a Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        scheduledSearchDelete: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('scheduledSearchDelete', 'id', id)
            const localVarPath = `/scheduled-searches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified scheduled search.
         * @summary Get a Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        scheduledSearchGet: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('scheduledSearchGet', 'id', id)
            const localVarPath = `/scheduled-searches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of scheduled searches. 
         * @summary List scheduled searches
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] An expression used to constrain the result set using the filtering syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results).  Allowed filter properties: *owner.id*, *savedSearchId*  Allowed filter operator: *eq*  **Example filters**:  &#x60;&#x60;&#x60;owner.id eq \&quot;0de46054-fe90-434a-b84e-c6b3359d0c64\&quot;&#x60;&#x60;&#x60; -- returns scheduled searches for the specified owner ID  &#x60;&#x60;&#x60;savedSearchId eq \&quot;6cc0945d-9eeb-4948-9033-72d066e1153e\&quot;&#x60;&#x60;&#x60; -- returns scheduled searches that reference the specified saved search  &#x60;&#x60;&#x60;owner.id eq me or savedSearchId eq \&quot;6cc0945d-9eeb-4948-9033-72d066e1153e\&quot;&#x60;&#x60;&#x60; -- returns all of the current user\&#39;s scheduled searches as well as all scheduled searches that reference the specified saved search 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        scheduledSearchList: async (offset?: number, limit?: number, count?: boolean, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/scheduled-searches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Unsubscribes a recipient from the specified scheduled search. 
         * @summary Unsubscribe a recipient from Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {TypedReference} typedReference The recipient to be removed from the scheduled search. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        scheduledSearchUnsubscribe: async (id: string, typedReference: TypedReference, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('scheduledSearchUnsubscribe', 'id', id)
            // verify required parameter 'typedReference' is not null or undefined
            assertParamExists('scheduledSearchUnsubscribe', 'typedReference', typedReference)
            const localVarPath = `/scheduled-searches/{id}/unsubscribe`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typedReference, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing scheduled search. 
         * @summary Update an existing Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {ScheduledSearch} scheduledSearch The scheduled search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        scheduledSearchUpdate: async (id: string, scheduledSearch: ScheduledSearch, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('scheduledSearchUpdate', 'id', id)
            // verify required parameter 'scheduledSearch' is not null or undefined
            assertParamExists('scheduledSearchUpdate', 'scheduledSearch', scheduledSearch)
            const localVarPath = `/scheduled-searches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scheduledSearch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScheduledSearchApi - functional programming interface
 * @export
 */
export const ScheduledSearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ScheduledSearchApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new scheduled search. 
         * @summary Create a new scheduled search
         * @param {ScheduledSearchCreateRequest} scheduledSearchCreateRequest The scheduled search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async scheduledSearchCreate(scheduledSearchCreateRequest: ScheduledSearchCreateRequest, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduledSearch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scheduledSearchCreate(scheduledSearchCreateRequest, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the specified scheduled search. 
         * @summary Delete a Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async scheduledSearchDelete(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scheduledSearchDelete(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the specified scheduled search.
         * @summary Get a Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async scheduledSearchGet(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduledSearch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scheduledSearchGet(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of scheduled searches. 
         * @summary List scheduled searches
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] An expression used to constrain the result set using the filtering syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results).  Allowed filter properties: *owner.id*, *savedSearchId*  Allowed filter operator: *eq*  **Example filters**:  &#x60;&#x60;&#x60;owner.id eq \&quot;0de46054-fe90-434a-b84e-c6b3359d0c64\&quot;&#x60;&#x60;&#x60; -- returns scheduled searches for the specified owner ID  &#x60;&#x60;&#x60;savedSearchId eq \&quot;6cc0945d-9eeb-4948-9033-72d066e1153e\&quot;&#x60;&#x60;&#x60; -- returns scheduled searches that reference the specified saved search  &#x60;&#x60;&#x60;owner.id eq me or savedSearchId eq \&quot;6cc0945d-9eeb-4948-9033-72d066e1153e\&quot;&#x60;&#x60;&#x60; -- returns all of the current user\&#39;s scheduled searches as well as all scheduled searches that reference the specified saved search 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async scheduledSearchList(offset?: number, limit?: number, count?: boolean, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScheduledSearch>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scheduledSearchList(offset, limit, count, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Unsubscribes a recipient from the specified scheduled search. 
         * @summary Unsubscribe a recipient from Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {TypedReference} typedReference The recipient to be removed from the scheduled search. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async scheduledSearchUnsubscribe(id: string, typedReference: TypedReference, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scheduledSearchUnsubscribe(id, typedReference, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates an existing scheduled search. 
         * @summary Update an existing Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {ScheduledSearch} scheduledSearch The scheduled search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async scheduledSearchUpdate(id: string, scheduledSearch: ScheduledSearch, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduledSearch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scheduledSearchUpdate(id, scheduledSearch, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ScheduledSearchApi - factory interface
 * @export
 */
export const ScheduledSearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ScheduledSearchApiFp(configuration)
    return {
        /**
         * Creates a new scheduled search. 
         * @summary Create a new scheduled search
         * @param {ScheduledSearchCreateRequest} scheduledSearchCreateRequest The scheduled search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        scheduledSearchCreate(scheduledSearchCreateRequest: ScheduledSearchCreateRequest, axiosOptions?: any): AxiosPromise<ScheduledSearch> {
            return localVarFp.scheduledSearchCreate(scheduledSearchCreateRequest, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the specified scheduled search. 
         * @summary Delete a Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        scheduledSearchDelete(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.scheduledSearchDelete(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Returns the specified scheduled search.
         * @summary Get a Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        scheduledSearchGet(id: string, axiosOptions?: any): AxiosPromise<ScheduledSearch> {
            return localVarFp.scheduledSearchGet(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of scheduled searches. 
         * @summary List scheduled searches
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] An expression used to constrain the result set using the filtering syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results).  Allowed filter properties: *owner.id*, *savedSearchId*  Allowed filter operator: *eq*  **Example filters**:  &#x60;&#x60;&#x60;owner.id eq \&quot;0de46054-fe90-434a-b84e-c6b3359d0c64\&quot;&#x60;&#x60;&#x60; -- returns scheduled searches for the specified owner ID  &#x60;&#x60;&#x60;savedSearchId eq \&quot;6cc0945d-9eeb-4948-9033-72d066e1153e\&quot;&#x60;&#x60;&#x60; -- returns scheduled searches that reference the specified saved search  &#x60;&#x60;&#x60;owner.id eq me or savedSearchId eq \&quot;6cc0945d-9eeb-4948-9033-72d066e1153e\&quot;&#x60;&#x60;&#x60; -- returns all of the current user\&#39;s scheduled searches as well as all scheduled searches that reference the specified saved search 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        scheduledSearchList(offset?: number, limit?: number, count?: boolean, filters?: string, axiosOptions?: any): AxiosPromise<Array<ScheduledSearch>> {
            return localVarFp.scheduledSearchList(offset, limit, count, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Unsubscribes a recipient from the specified scheduled search. 
         * @summary Unsubscribe a recipient from Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {TypedReference} typedReference The recipient to be removed from the scheduled search. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        scheduledSearchUnsubscribe(id: string, typedReference: TypedReference, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.scheduledSearchUnsubscribe(id, typedReference, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing scheduled search. 
         * @summary Update an existing Scheduled Search
         * @param {string} id ID of the requested document.
         * @param {ScheduledSearch} scheduledSearch The scheduled search to persist.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        scheduledSearchUpdate(id: string, scheduledSearch: ScheduledSearch, axiosOptions?: any): AxiosPromise<ScheduledSearch> {
            return localVarFp.scheduledSearchUpdate(id, scheduledSearch, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for scheduledSearchCreate operation in ScheduledSearchApi.
 * @export
 * @interface ScheduledSearchApiScheduledSearchCreateRequest
 */
export interface ScheduledSearchApiScheduledSearchCreateRequest {
    /**
     * The scheduled search to persist.
     * @type {ScheduledSearchCreateRequest}
     * @memberof ScheduledSearchApiScheduledSearchCreate
     */
    readonly scheduledSearchCreateRequest: ScheduledSearchCreateRequest
}

/**
 * Request parameters for scheduledSearchDelete operation in ScheduledSearchApi.
 * @export
 * @interface ScheduledSearchApiScheduledSearchDeleteRequest
 */
export interface ScheduledSearchApiScheduledSearchDeleteRequest {
    /**
     * ID of the requested document.
     * @type {string}
     * @memberof ScheduledSearchApiScheduledSearchDelete
     */
    readonly id: string
}

/**
 * Request parameters for scheduledSearchGet operation in ScheduledSearchApi.
 * @export
 * @interface ScheduledSearchApiScheduledSearchGetRequest
 */
export interface ScheduledSearchApiScheduledSearchGetRequest {
    /**
     * ID of the requested document.
     * @type {string}
     * @memberof ScheduledSearchApiScheduledSearchGet
     */
    readonly id: string
}

/**
 * Request parameters for scheduledSearchList operation in ScheduledSearchApi.
 * @export
 * @interface ScheduledSearchApiScheduledSearchListRequest
 */
export interface ScheduledSearchApiScheduledSearchListRequest {
    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof ScheduledSearchApiScheduledSearchList
     */
    readonly offset?: number

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof ScheduledSearchApiScheduledSearchList
     */
    readonly limit?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof ScheduledSearchApiScheduledSearchList
     */
    readonly count?: boolean

    /**
     * An expression used to constrain the result set using the filtering syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results).  Allowed filter properties: *owner.id*, *savedSearchId*  Allowed filter operator: *eq*  **Example filters**:  &#x60;&#x60;&#x60;owner.id eq \&quot;0de46054-fe90-434a-b84e-c6b3359d0c64\&quot;&#x60;&#x60;&#x60; -- returns scheduled searches for the specified owner ID  &#x60;&#x60;&#x60;savedSearchId eq \&quot;6cc0945d-9eeb-4948-9033-72d066e1153e\&quot;&#x60;&#x60;&#x60; -- returns scheduled searches that reference the specified saved search  &#x60;&#x60;&#x60;owner.id eq me or savedSearchId eq \&quot;6cc0945d-9eeb-4948-9033-72d066e1153e\&quot;&#x60;&#x60;&#x60; -- returns all of the current user\&#39;s scheduled searches as well as all scheduled searches that reference the specified saved search 
     * @type {string}
     * @memberof ScheduledSearchApiScheduledSearchList
     */
    readonly filters?: string
}

/**
 * Request parameters for scheduledSearchUnsubscribe operation in ScheduledSearchApi.
 * @export
 * @interface ScheduledSearchApiScheduledSearchUnsubscribeRequest
 */
export interface ScheduledSearchApiScheduledSearchUnsubscribeRequest {
    /**
     * ID of the requested document.
     * @type {string}
     * @memberof ScheduledSearchApiScheduledSearchUnsubscribe
     */
    readonly id: string

    /**
     * The recipient to be removed from the scheduled search. 
     * @type {TypedReference}
     * @memberof ScheduledSearchApiScheduledSearchUnsubscribe
     */
    readonly typedReference: TypedReference
}

/**
 * Request parameters for scheduledSearchUpdate operation in ScheduledSearchApi.
 * @export
 * @interface ScheduledSearchApiScheduledSearchUpdateRequest
 */
export interface ScheduledSearchApiScheduledSearchUpdateRequest {
    /**
     * ID of the requested document.
     * @type {string}
     * @memberof ScheduledSearchApiScheduledSearchUpdate
     */
    readonly id: string

    /**
     * The scheduled search to persist.
     * @type {ScheduledSearch}
     * @memberof ScheduledSearchApiScheduledSearchUpdate
     */
    readonly scheduledSearch: ScheduledSearch
}

/**
 * ScheduledSearchApi - object-oriented interface
 * @export
 * @class ScheduledSearchApi
 * @extends {BaseAPI}
 */
export class ScheduledSearchApi extends BaseAPI {
    /**
     * Creates a new scheduled search. 
     * @summary Create a new scheduled search
     * @param {ScheduledSearchApiScheduledSearchCreateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledSearchApi
     */
    public scheduledSearchCreate(requestParameters: ScheduledSearchApiScheduledSearchCreateRequest, axiosOptions?: AxiosRequestConfig) {
        return ScheduledSearchApiFp(this.configuration).scheduledSearchCreate(requestParameters.scheduledSearchCreateRequest, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the specified scheduled search. 
     * @summary Delete a Scheduled Search
     * @param {ScheduledSearchApiScheduledSearchDeleteRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledSearchApi
     */
    public scheduledSearchDelete(requestParameters: ScheduledSearchApiScheduledSearchDeleteRequest, axiosOptions?: AxiosRequestConfig) {
        return ScheduledSearchApiFp(this.configuration).scheduledSearchDelete(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the specified scheduled search.
     * @summary Get a Scheduled Search
     * @param {ScheduledSearchApiScheduledSearchGetRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledSearchApi
     */
    public scheduledSearchGet(requestParameters: ScheduledSearchApiScheduledSearchGetRequest, axiosOptions?: AxiosRequestConfig) {
        return ScheduledSearchApiFp(this.configuration).scheduledSearchGet(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of scheduled searches. 
     * @summary List scheduled searches
     * @param {ScheduledSearchApiScheduledSearchListRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledSearchApi
     */
    public scheduledSearchList(requestParameters: ScheduledSearchApiScheduledSearchListRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return ScheduledSearchApiFp(this.configuration).scheduledSearchList(requestParameters.offset, requestParameters.limit, requestParameters.count, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unsubscribes a recipient from the specified scheduled search. 
     * @summary Unsubscribe a recipient from Scheduled Search
     * @param {ScheduledSearchApiScheduledSearchUnsubscribeRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledSearchApi
     */
    public scheduledSearchUnsubscribe(requestParameters: ScheduledSearchApiScheduledSearchUnsubscribeRequest, axiosOptions?: AxiosRequestConfig) {
        return ScheduledSearchApiFp(this.configuration).scheduledSearchUnsubscribe(requestParameters.id, requestParameters.typedReference, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing scheduled search. 
     * @summary Update an existing Scheduled Search
     * @param {ScheduledSearchApiScheduledSearchUpdateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledSearchApi
     */
    public scheduledSearchUpdate(requestParameters: ScheduledSearchApiScheduledSearchUpdateRequest, axiosOptions?: AxiosRequestConfig) {
        return ScheduledSearchApiFp(this.configuration).scheduledSearchUpdate(requestParameters.id, requestParameters.scheduledSearch, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SearchApi - axios parameter creator
 * @export
 */
export const SearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Performs a search query aggregation and returns the aggregation result. By default, you can page a maximum of 10,000 search result records.  To page past 10,000 records, you can use searchAfter paging.  Refer to [Paginating Search Queries](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-search-queries) for more information about how to implement searchAfter paging. 
         * @summary Perform a Search Query Aggregation
         * @param {Search} search 
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchAggregate: async (search: Search, offset?: number, limit?: number, count?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'search' is not null or undefined
            assertParamExists('searchAggregate', 'search', search)
            const localVarPath = `/search/aggregate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(search, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Performs a search with a provided query and returns the count of results in the X-Total-Count header.
         * @summary Count Documents Satisfying a Query
         * @param {Search} search 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchCount: async (search: Search, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'search' is not null or undefined
            assertParamExists('searchCount', 'search', search)
            const localVarPath = `/search/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(search, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Fetches a single document from the specified index, using the specified document ID.
         * @summary Get a Document by ID
         * @param {string} index The index from which to fetch the specified document.  The currently supported index names are: *accessprofiles*, *accountactivities*, *accounts*, *aggregations*, *entitlements*, *events*, *identities*, and *roles*. 
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchGet: async (index: string, id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'index' is not null or undefined
            assertParamExists('searchGet', 'index', index)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('searchGet', 'id', id)
            const localVarPath = `/search/{index}/{id}`
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Performs a search with the provided query and returns a matching result collection. By default, you can page a maximum of 10,000 search result records.  To page past 10,000 records, you can use searchAfter paging.  Refer to [Paginating Search Queries](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-search-queries) for more information about how to implement searchAfter paging. 
         * @summary Perform Search
         * @param {Search} search 
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchPost: async (search: Search, offset?: number, limit?: number, count?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'search' is not null or undefined
            assertParamExists('searchPost', 'search', search)
            const localVarPath = `/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(search, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SearchApiAxiosParamCreator(configuration)
    return {
        /**
         * Performs a search query aggregation and returns the aggregation result. By default, you can page a maximum of 10,000 search result records.  To page past 10,000 records, you can use searchAfter paging.  Refer to [Paginating Search Queries](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-search-queries) for more information about how to implement searchAfter paging. 
         * @summary Perform a Search Query Aggregation
         * @param {Search} search 
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async searchAggregate(search: Search, offset?: number, limit?: number, count?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AggregationResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchAggregate(search, offset, limit, count, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Performs a search with a provided query and returns the count of results in the X-Total-Count header.
         * @summary Count Documents Satisfying a Query
         * @param {Search} search 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async searchCount(search: Search, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchCount(search, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetches a single document from the specified index, using the specified document ID.
         * @summary Get a Document by ID
         * @param {string} index The index from which to fetch the specified document.  The currently supported index names are: *accessprofiles*, *accountactivities*, *accounts*, *aggregations*, *entitlements*, *events*, *identities*, and *roles*. 
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async searchGet(index: string, id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchDocument>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchGet(index, id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Performs a search with the provided query and returns a matching result collection. By default, you can page a maximum of 10,000 search result records.  To page past 10,000 records, you can use searchAfter paging.  Refer to [Paginating Search Queries](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-search-queries) for more information about how to implement searchAfter paging. 
         * @summary Perform Search
         * @param {Search} search 
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async searchPost(search: Search, offset?: number, limit?: number, count?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SearchDocument>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchPost(search, offset, limit, count, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SearchApiFp(configuration)
    return {
        /**
         * Performs a search query aggregation and returns the aggregation result. By default, you can page a maximum of 10,000 search result records.  To page past 10,000 records, you can use searchAfter paging.  Refer to [Paginating Search Queries](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-search-queries) for more information about how to implement searchAfter paging. 
         * @summary Perform a Search Query Aggregation
         * @param {Search} search 
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchAggregate(search: Search, offset?: number, limit?: number, count?: boolean, axiosOptions?: any): AxiosPromise<AggregationResult> {
            return localVarFp.searchAggregate(search, offset, limit, count, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Performs a search with a provided query and returns the count of results in the X-Total-Count header.
         * @summary Count Documents Satisfying a Query
         * @param {Search} search 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchCount(search: Search, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.searchCount(search, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Fetches a single document from the specified index, using the specified document ID.
         * @summary Get a Document by ID
         * @param {string} index The index from which to fetch the specified document.  The currently supported index names are: *accessprofiles*, *accountactivities*, *accounts*, *aggregations*, *entitlements*, *events*, *identities*, and *roles*. 
         * @param {string} id ID of the requested document.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchGet(index: string, id: string, axiosOptions?: any): AxiosPromise<SearchDocument> {
            return localVarFp.searchGet(index, id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Performs a search with the provided query and returns a matching result collection. By default, you can page a maximum of 10,000 search result records.  To page past 10,000 records, you can use searchAfter paging.  Refer to [Paginating Search Queries](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-search-queries) for more information about how to implement searchAfter paging. 
         * @summary Perform Search
         * @param {Search} search 
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        searchPost(search: Search, offset?: number, limit?: number, count?: boolean, axiosOptions?: any): AxiosPromise<Array<SearchDocument>> {
            return localVarFp.searchPost(search, offset, limit, count, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for searchAggregate operation in SearchApi.
 * @export
 * @interface SearchApiSearchAggregateRequest
 */
export interface SearchApiSearchAggregateRequest {
    /**
     * 
     * @type {Search}
     * @memberof SearchApiSearchAggregate
     */
    readonly search: Search

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SearchApiSearchAggregate
     */
    readonly offset?: number

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SearchApiSearchAggregate
     */
    readonly limit?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof SearchApiSearchAggregate
     */
    readonly count?: boolean
}

/**
 * Request parameters for searchCount operation in SearchApi.
 * @export
 * @interface SearchApiSearchCountRequest
 */
export interface SearchApiSearchCountRequest {
    /**
     * 
     * @type {Search}
     * @memberof SearchApiSearchCount
     */
    readonly search: Search
}

/**
 * Request parameters for searchGet operation in SearchApi.
 * @export
 * @interface SearchApiSearchGetRequest
 */
export interface SearchApiSearchGetRequest {
    /**
     * The index from which to fetch the specified document.  The currently supported index names are: *accessprofiles*, *accountactivities*, *accounts*, *aggregations*, *entitlements*, *events*, *identities*, and *roles*. 
     * @type {string}
     * @memberof SearchApiSearchGet
     */
    readonly index: string

    /**
     * ID of the requested document.
     * @type {string}
     * @memberof SearchApiSearchGet
     */
    readonly id: string
}

/**
 * Request parameters for searchPost operation in SearchApi.
 * @export
 * @interface SearchApiSearchPostRequest
 */
export interface SearchApiSearchPostRequest {
    /**
     * 
     * @type {Search}
     * @memberof SearchApiSearchPost
     */
    readonly search: Search

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SearchApiSearchPost
     */
    readonly offset?: number

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SearchApiSearchPost
     */
    readonly limit?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof SearchApiSearchPost
     */
    readonly count?: boolean
}

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI {
    /**
     * Performs a search query aggregation and returns the aggregation result. By default, you can page a maximum of 10,000 search result records.  To page past 10,000 records, you can use searchAfter paging.  Refer to [Paginating Search Queries](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-search-queries) for more information about how to implement searchAfter paging. 
     * @summary Perform a Search Query Aggregation
     * @param {SearchApiSearchAggregateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchAggregate(requestParameters: SearchApiSearchAggregateRequest, axiosOptions?: AxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchAggregate(requestParameters.search, requestParameters.offset, requestParameters.limit, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Performs a search with a provided query and returns the count of results in the X-Total-Count header.
     * @summary Count Documents Satisfying a Query
     * @param {SearchApiSearchCountRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchCount(requestParameters: SearchApiSearchCountRequest, axiosOptions?: AxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchCount(requestParameters.search, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches a single document from the specified index, using the specified document ID.
     * @summary Get a Document by ID
     * @param {SearchApiSearchGetRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchGet(requestParameters: SearchApiSearchGetRequest, axiosOptions?: AxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchGet(requestParameters.index, requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Performs a search with the provided query and returns a matching result collection. By default, you can page a maximum of 10,000 search result records.  To page past 10,000 records, you can use searchAfter paging.  Refer to [Paginating Search Queries](https://developer.sailpoint.com/idn/api/standard-collection-parameters#paginating-search-queries) for more information about how to implement searchAfter paging. 
     * @summary Perform Search
     * @param {SearchApiSearchPostRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchPost(requestParameters: SearchApiSearchPostRequest, axiosOptions?: AxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchPost(requestParameters.search, requestParameters.offset, requestParameters.limit, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ServiceDeskIntegrationApi - axios parameter creator
 * @export
 */
export const ServiceDeskIntegrationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new Service Desk Integrations.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Create a new Service Desk integration
         * @param {ServiceDeskIntegrationDto} serviceDeskIntegrationDto The specifics of a new integration to create
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createServiceDeskIntegration: async (serviceDeskIntegrationDto: ServiceDeskIntegrationDto, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceDeskIntegrationDto' is not null or undefined
            assertParamExists('createServiceDeskIntegration', 'serviceDeskIntegrationDto', serviceDeskIntegrationDto)
            const localVarPath = `/service-desk-integrations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serviceDeskIntegrationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing Service Desk integration by ID.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Delete a Service Desk integration by ID
         * @param {string} id ID of Service Desk integration to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteServiceDeskIntegration: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteServiceDeskIntegration', 'id', id)
            const localVarPath = `/service-desk-integrations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get an existing Service Desk integration by ID.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Get a Service Desk integration by ID
         * @param {string} id ID of the Service Desk integration to get
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegration: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getServiceDeskIntegration', 'id', id)
            const localVarPath = `/service-desk-integrations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get a list of ServiceDeskIntegrationDto for existing Service Desk Integrations.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary List existing Service Desk Integrations
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq*  **type**: *eq, in*  **cluster**: *eq, in*
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegrationList: async (offset?: number, limit?: number, sorters?: string, filters?: string, count?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/service-desk-integrations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API endpoint returns an existing Service Desk integration template by scriptName.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Service Desk integration template by scriptName.
         * @param {string} scriptName The scriptName value of the Service Desk integration template to get
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegrationTemplate: async (scriptName: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scriptName' is not null or undefined
            assertParamExists('getServiceDeskIntegrationTemplate', 'scriptName', scriptName)
            const localVarPath = `/service-desk-integrations/templates/{scriptName}`
                .replace(`{${"scriptName"}}`, encodeURIComponent(String(scriptName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API endpoint returns the current list of supported Service Desk integration types.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Service Desk Integration Types List.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegrationTypes: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/service-desk-integrations/types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get the time check configuration of queued SDIM tickets.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Get the time check configuration of queued SDIM tickets
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getStatusCheckDetails: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/service-desk-integrations/status-check-configuration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Update an existing ServiceDeskIntegration by ID with a PATCH request.
         * @summary Service Desk Integration Update - PATCH
         * @param {string} id ID of the Service Desk integration to update
         * @param {JsonPatch} jsonPatch A list of SDIM update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  PATCH can only be applied to the following fields:   *   \&quot;beforeProvisioningRule\&quot;  A 403 Forbidden Error indicates that you attempted to PATCH a field that is not allowed. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchServiceDeskIntegration: async (id: string, jsonPatch: JsonPatch, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchServiceDeskIntegration', 'id', id)
            // verify required parameter 'jsonPatch' is not null or undefined
            assertParamExists('patchServiceDeskIntegration', 'jsonPatch', jsonPatch)
            const localVarPath = `/service-desk-integrations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Update an existing Service Desk integration by ID with updated value in JSON form as the request body.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Update a Service Desk integration by ID
         * @param {string} id ID of the Service Desk integration to update
         * @param {ServiceDeskIntegrationDto} serviceDeskIntegrationDto The specifics of the integration to update
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateServiceDeskIntegration: async (id: string, serviceDeskIntegrationDto: ServiceDeskIntegrationDto, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateServiceDeskIntegration', 'id', id)
            // verify required parameter 'serviceDeskIntegrationDto' is not null or undefined
            assertParamExists('updateServiceDeskIntegration', 'serviceDeskIntegrationDto', serviceDeskIntegrationDto)
            const localVarPath = `/service-desk-integrations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serviceDeskIntegrationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Update the time check configuration of queued SDIM tickets.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Update the time check configuration of queued SDIM tickets
         * @param {QueuedCheckConfigDetails} queuedCheckConfigDetails the modified time check configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateStatusCheckDetails: async (queuedCheckConfigDetails: QueuedCheckConfigDetails, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queuedCheckConfigDetails' is not null or undefined
            assertParamExists('updateStatusCheckDetails', 'queuedCheckConfigDetails', queuedCheckConfigDetails)
            const localVarPath = `/service-desk-integrations/status-check-configuration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(queuedCheckConfigDetails, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServiceDeskIntegrationApi - functional programming interface
 * @export
 */
export const ServiceDeskIntegrationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServiceDeskIntegrationApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new Service Desk Integrations.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Create a new Service Desk integration
         * @param {ServiceDeskIntegrationDto} serviceDeskIntegrationDto The specifics of a new integration to create
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createServiceDeskIntegration(serviceDeskIntegrationDto: ServiceDeskIntegrationDto, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceDeskIntegrationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createServiceDeskIntegration(serviceDeskIntegrationDto, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an existing Service Desk integration by ID.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Delete a Service Desk integration by ID
         * @param {string} id ID of Service Desk integration to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteServiceDeskIntegration(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteServiceDeskIntegration(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get an existing Service Desk integration by ID.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Get a Service Desk integration by ID
         * @param {string} id ID of the Service Desk integration to get
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceDeskIntegration(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceDeskIntegrationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceDeskIntegration(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of ServiceDeskIntegrationDto for existing Service Desk Integrations.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary List existing Service Desk Integrations
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq*  **type**: *eq, in*  **cluster**: *eq, in*
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceDeskIntegrationList(offset?: number, limit?: number, sorters?: string, filters?: string, count?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ServiceDeskIntegrationDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceDeskIntegrationList(offset, limit, sorters, filters, count, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API endpoint returns an existing Service Desk integration template by scriptName.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Service Desk integration template by scriptName.
         * @param {string} scriptName The scriptName value of the Service Desk integration template to get
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceDeskIntegrationTemplate(scriptName: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceDeskIntegrationTemplateDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceDeskIntegrationTemplate(scriptName, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API endpoint returns the current list of supported Service Desk integration types.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Service Desk Integration Types List.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceDeskIntegrationTypes(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ServiceDeskIntegrationTemplateType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceDeskIntegrationTypes(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the time check configuration of queued SDIM tickets.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Get the time check configuration of queued SDIM tickets
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getStatusCheckDetails(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedCheckConfigDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatusCheckDetails(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing ServiceDeskIntegration by ID with a PATCH request.
         * @summary Service Desk Integration Update - PATCH
         * @param {string} id ID of the Service Desk integration to update
         * @param {JsonPatch} jsonPatch A list of SDIM update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  PATCH can only be applied to the following fields:   *   \&quot;beforeProvisioningRule\&quot;  A 403 Forbidden Error indicates that you attempted to PATCH a field that is not allowed. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async patchServiceDeskIntegration(id: string, jsonPatch: JsonPatch, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceDeskIntegrationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchServiceDeskIntegration(id, jsonPatch, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing Service Desk integration by ID with updated value in JSON form as the request body.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Update a Service Desk integration by ID
         * @param {string} id ID of the Service Desk integration to update
         * @param {ServiceDeskIntegrationDto} serviceDeskIntegrationDto The specifics of the integration to update
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateServiceDeskIntegration(id: string, serviceDeskIntegrationDto: ServiceDeskIntegrationDto, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceDeskIntegrationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateServiceDeskIntegration(id, serviceDeskIntegrationDto, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the time check configuration of queued SDIM tickets.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Update the time check configuration of queued SDIM tickets
         * @param {QueuedCheckConfigDetails} queuedCheckConfigDetails the modified time check configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateStatusCheckDetails(queuedCheckConfigDetails: QueuedCheckConfigDetails, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedCheckConfigDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStatusCheckDetails(queuedCheckConfigDetails, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ServiceDeskIntegrationApi - factory interface
 * @export
 */
export const ServiceDeskIntegrationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServiceDeskIntegrationApiFp(configuration)
    return {
        /**
         * Create a new Service Desk Integrations.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Create a new Service Desk integration
         * @param {ServiceDeskIntegrationDto} serviceDeskIntegrationDto The specifics of a new integration to create
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createServiceDeskIntegration(serviceDeskIntegrationDto: ServiceDeskIntegrationDto, axiosOptions?: any): AxiosPromise<ServiceDeskIntegrationDto> {
            return localVarFp.createServiceDeskIntegration(serviceDeskIntegrationDto, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing Service Desk integration by ID.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Delete a Service Desk integration by ID
         * @param {string} id ID of Service Desk integration to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteServiceDeskIntegration(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteServiceDeskIntegration(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Get an existing Service Desk integration by ID.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Get a Service Desk integration by ID
         * @param {string} id ID of the Service Desk integration to get
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegration(id: string, axiosOptions?: any): AxiosPromise<ServiceDeskIntegrationDto> {
            return localVarFp.getServiceDeskIntegration(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of ServiceDeskIntegrationDto for existing Service Desk Integrations.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary List existing Service Desk Integrations
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq*  **type**: *eq, in*  **cluster**: *eq, in*
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegrationList(offset?: number, limit?: number, sorters?: string, filters?: string, count?: boolean, axiosOptions?: any): AxiosPromise<Array<ServiceDeskIntegrationDto>> {
            return localVarFp.getServiceDeskIntegrationList(offset, limit, sorters, filters, count, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API endpoint returns an existing Service Desk integration template by scriptName.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Service Desk integration template by scriptName.
         * @param {string} scriptName The scriptName value of the Service Desk integration template to get
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegrationTemplate(scriptName: string, axiosOptions?: any): AxiosPromise<ServiceDeskIntegrationTemplateDto> {
            return localVarFp.getServiceDeskIntegrationTemplate(scriptName, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API endpoint returns the current list of supported Service Desk integration types.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Service Desk Integration Types List.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDeskIntegrationTypes(axiosOptions?: any): AxiosPromise<Array<ServiceDeskIntegrationTemplateType>> {
            return localVarFp.getServiceDeskIntegrationTypes(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Get the time check configuration of queued SDIM tickets.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Get the time check configuration of queued SDIM tickets
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getStatusCheckDetails(axiosOptions?: any): AxiosPromise<QueuedCheckConfigDetails> {
            return localVarFp.getStatusCheckDetails(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing ServiceDeskIntegration by ID with a PATCH request.
         * @summary Service Desk Integration Update - PATCH
         * @param {string} id ID of the Service Desk integration to update
         * @param {JsonPatch} jsonPatch A list of SDIM update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  PATCH can only be applied to the following fields:   *   \&quot;beforeProvisioningRule\&quot;  A 403 Forbidden Error indicates that you attempted to PATCH a field that is not allowed. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        patchServiceDeskIntegration(id: string, jsonPatch: JsonPatch, axiosOptions?: any): AxiosPromise<ServiceDeskIntegrationDto> {
            return localVarFp.patchServiceDeskIntegration(id, jsonPatch, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing Service Desk integration by ID with updated value in JSON form as the request body.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Update a Service Desk integration by ID
         * @param {string} id ID of the Service Desk integration to update
         * @param {ServiceDeskIntegrationDto} serviceDeskIntegrationDto The specifics of the integration to update
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateServiceDeskIntegration(id: string, serviceDeskIntegrationDto: ServiceDeskIntegrationDto, axiosOptions?: any): AxiosPromise<ServiceDeskIntegrationDto> {
            return localVarFp.updateServiceDeskIntegration(id, serviceDeskIntegrationDto, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Update the time check configuration of queued SDIM tickets.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
         * @summary Update the time check configuration of queued SDIM tickets
         * @param {QueuedCheckConfigDetails} queuedCheckConfigDetails the modified time check configuration
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateStatusCheckDetails(queuedCheckConfigDetails: QueuedCheckConfigDetails, axiosOptions?: any): AxiosPromise<QueuedCheckConfigDetails> {
            return localVarFp.updateStatusCheckDetails(queuedCheckConfigDetails, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createServiceDeskIntegration operation in ServiceDeskIntegrationApi.
 * @export
 * @interface ServiceDeskIntegrationApiCreateServiceDeskIntegrationRequest
 */
export interface ServiceDeskIntegrationApiCreateServiceDeskIntegrationRequest {
    /**
     * The specifics of a new integration to create
     * @type {ServiceDeskIntegrationDto}
     * @memberof ServiceDeskIntegrationApiCreateServiceDeskIntegration
     */
    readonly serviceDeskIntegrationDto: ServiceDeskIntegrationDto
}

/**
 * Request parameters for deleteServiceDeskIntegration operation in ServiceDeskIntegrationApi.
 * @export
 * @interface ServiceDeskIntegrationApiDeleteServiceDeskIntegrationRequest
 */
export interface ServiceDeskIntegrationApiDeleteServiceDeskIntegrationRequest {
    /**
     * ID of Service Desk integration to delete
     * @type {string}
     * @memberof ServiceDeskIntegrationApiDeleteServiceDeskIntegration
     */
    readonly id: string
}

/**
 * Request parameters for getServiceDeskIntegration operation in ServiceDeskIntegrationApi.
 * @export
 * @interface ServiceDeskIntegrationApiGetServiceDeskIntegrationRequest
 */
export interface ServiceDeskIntegrationApiGetServiceDeskIntegrationRequest {
    /**
     * ID of the Service Desk integration to get
     * @type {string}
     * @memberof ServiceDeskIntegrationApiGetServiceDeskIntegration
     */
    readonly id: string
}

/**
 * Request parameters for getServiceDeskIntegrationList operation in ServiceDeskIntegrationApi.
 * @export
 * @interface ServiceDeskIntegrationApiGetServiceDeskIntegrationListRequest
 */
export interface ServiceDeskIntegrationApiGetServiceDeskIntegrationListRequest {
    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof ServiceDeskIntegrationApiGetServiceDeskIntegrationList
     */
    readonly offset?: number

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof ServiceDeskIntegrationApiGetServiceDeskIntegrationList
     */
    readonly limit?: number

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **name**
     * @type {string}
     * @memberof ServiceDeskIntegrationApiGetServiceDeskIntegrationList
     */
    readonly sorters?: string

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *eq*  **type**: *eq, in*  **cluster**: *eq, in*
     * @type {string}
     * @memberof ServiceDeskIntegrationApiGetServiceDeskIntegrationList
     */
    readonly filters?: string

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof ServiceDeskIntegrationApiGetServiceDeskIntegrationList
     */
    readonly count?: boolean
}

/**
 * Request parameters for getServiceDeskIntegrationTemplate operation in ServiceDeskIntegrationApi.
 * @export
 * @interface ServiceDeskIntegrationApiGetServiceDeskIntegrationTemplateRequest
 */
export interface ServiceDeskIntegrationApiGetServiceDeskIntegrationTemplateRequest {
    /**
     * The scriptName value of the Service Desk integration template to get
     * @type {string}
     * @memberof ServiceDeskIntegrationApiGetServiceDeskIntegrationTemplate
     */
    readonly scriptName: string
}

/**
 * Request parameters for patchServiceDeskIntegration operation in ServiceDeskIntegrationApi.
 * @export
 * @interface ServiceDeskIntegrationApiPatchServiceDeskIntegrationRequest
 */
export interface ServiceDeskIntegrationApiPatchServiceDeskIntegrationRequest {
    /**
     * ID of the Service Desk integration to update
     * @type {string}
     * @memberof ServiceDeskIntegrationApiPatchServiceDeskIntegration
     */
    readonly id: string

    /**
     * A list of SDIM update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  PATCH can only be applied to the following fields:   *   \&quot;beforeProvisioningRule\&quot;  A 403 Forbidden Error indicates that you attempted to PATCH a field that is not allowed. 
     * @type {JsonPatch}
     * @memberof ServiceDeskIntegrationApiPatchServiceDeskIntegration
     */
    readonly jsonPatch: JsonPatch
}

/**
 * Request parameters for updateServiceDeskIntegration operation in ServiceDeskIntegrationApi.
 * @export
 * @interface ServiceDeskIntegrationApiUpdateServiceDeskIntegrationRequest
 */
export interface ServiceDeskIntegrationApiUpdateServiceDeskIntegrationRequest {
    /**
     * ID of the Service Desk integration to update
     * @type {string}
     * @memberof ServiceDeskIntegrationApiUpdateServiceDeskIntegration
     */
    readonly id: string

    /**
     * The specifics of the integration to update
     * @type {ServiceDeskIntegrationDto}
     * @memberof ServiceDeskIntegrationApiUpdateServiceDeskIntegration
     */
    readonly serviceDeskIntegrationDto: ServiceDeskIntegrationDto
}

/**
 * Request parameters for updateStatusCheckDetails operation in ServiceDeskIntegrationApi.
 * @export
 * @interface ServiceDeskIntegrationApiUpdateStatusCheckDetailsRequest
 */
export interface ServiceDeskIntegrationApiUpdateStatusCheckDetailsRequest {
    /**
     * the modified time check configuration
     * @type {QueuedCheckConfigDetails}
     * @memberof ServiceDeskIntegrationApiUpdateStatusCheckDetails
     */
    readonly queuedCheckConfigDetails: QueuedCheckConfigDetails
}

/**
 * ServiceDeskIntegrationApi - object-oriented interface
 * @export
 * @class ServiceDeskIntegrationApi
 * @extends {BaseAPI}
 */
export class ServiceDeskIntegrationApi extends BaseAPI {
    /**
     * Create a new Service Desk Integrations.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary Create a new Service Desk integration
     * @param {ServiceDeskIntegrationApiCreateServiceDeskIntegrationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    public createServiceDeskIntegration(requestParameters: ServiceDeskIntegrationApiCreateServiceDeskIntegrationRequest, axiosOptions?: AxiosRequestConfig) {
        return ServiceDeskIntegrationApiFp(this.configuration).createServiceDeskIntegration(requestParameters.serviceDeskIntegrationDto, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing Service Desk integration by ID.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary Delete a Service Desk integration by ID
     * @param {ServiceDeskIntegrationApiDeleteServiceDeskIntegrationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    public deleteServiceDeskIntegration(requestParameters: ServiceDeskIntegrationApiDeleteServiceDeskIntegrationRequest, axiosOptions?: AxiosRequestConfig) {
        return ServiceDeskIntegrationApiFp(this.configuration).deleteServiceDeskIntegration(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an existing Service Desk integration by ID.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary Get a Service Desk integration by ID
     * @param {ServiceDeskIntegrationApiGetServiceDeskIntegrationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    public getServiceDeskIntegration(requestParameters: ServiceDeskIntegrationApiGetServiceDeskIntegrationRequest, axiosOptions?: AxiosRequestConfig) {
        return ServiceDeskIntegrationApiFp(this.configuration).getServiceDeskIntegration(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of ServiceDeskIntegrationDto for existing Service Desk Integrations.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary List existing Service Desk Integrations
     * @param {ServiceDeskIntegrationApiGetServiceDeskIntegrationListRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    public getServiceDeskIntegrationList(requestParameters: ServiceDeskIntegrationApiGetServiceDeskIntegrationListRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return ServiceDeskIntegrationApiFp(this.configuration).getServiceDeskIntegrationList(requestParameters.offset, requestParameters.limit, requestParameters.sorters, requestParameters.filters, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API endpoint returns an existing Service Desk integration template by scriptName.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary Service Desk integration template by scriptName.
     * @param {ServiceDeskIntegrationApiGetServiceDeskIntegrationTemplateRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    public getServiceDeskIntegrationTemplate(requestParameters: ServiceDeskIntegrationApiGetServiceDeskIntegrationTemplateRequest, axiosOptions?: AxiosRequestConfig) {
        return ServiceDeskIntegrationApiFp(this.configuration).getServiceDeskIntegrationTemplate(requestParameters.scriptName, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API endpoint returns the current list of supported Service Desk integration types.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary Service Desk Integration Types List.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    public getServiceDeskIntegrationTypes(axiosOptions?: AxiosRequestConfig) {
        return ServiceDeskIntegrationApiFp(this.configuration).getServiceDeskIntegrationTypes(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the time check configuration of queued SDIM tickets.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary Get the time check configuration of queued SDIM tickets
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    public getStatusCheckDetails(axiosOptions?: AxiosRequestConfig) {
        return ServiceDeskIntegrationApiFp(this.configuration).getStatusCheckDetails(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing ServiceDeskIntegration by ID with a PATCH request.
     * @summary Service Desk Integration Update - PATCH
     * @param {ServiceDeskIntegrationApiPatchServiceDeskIntegrationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    public patchServiceDeskIntegration(requestParameters: ServiceDeskIntegrationApiPatchServiceDeskIntegrationRequest, axiosOptions?: AxiosRequestConfig) {
        return ServiceDeskIntegrationApiFp(this.configuration).patchServiceDeskIntegration(requestParameters.id, requestParameters.jsonPatch, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing Service Desk integration by ID with updated value in JSON form as the request body.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary Update a Service Desk integration by ID
     * @param {ServiceDeskIntegrationApiUpdateServiceDeskIntegrationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    public updateServiceDeskIntegration(requestParameters: ServiceDeskIntegrationApiUpdateServiceDeskIntegrationRequest, axiosOptions?: AxiosRequestConfig) {
        return ServiceDeskIntegrationApiFp(this.configuration).updateServiceDeskIntegration(requestParameters.id, requestParameters.serviceDeskIntegrationDto, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the time check configuration of queued SDIM tickets.  A token with Org Admin or Service Desk Admin authority is required to access this endpoint.
     * @summary Update the time check configuration of queued SDIM tickets
     * @param {ServiceDeskIntegrationApiUpdateStatusCheckDetailsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDeskIntegrationApi
     */
    public updateStatusCheckDetails(requestParameters: ServiceDeskIntegrationApiUpdateStatusCheckDetailsRequest, axiosOptions?: AxiosRequestConfig) {
        return ServiceDeskIntegrationApiFp(this.configuration).updateStatusCheckDetails(requestParameters.queuedCheckConfigDetails, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SourcesApi - axios parameter creator
 * @export
 */
export const SourcesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This end-point updates a list of provisioning policies on the specified source in IdentityNow. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Bulk Update Provisioning Policies
         * @param {string} sourceId The Source id.
         * @param {Array<ProvisioningPolicyDto>} provisioningPolicyDto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateProvisioningPolicies: async (sourceId: string, provisioningPolicyDto: Array<ProvisioningPolicyDto>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('bulkUpdateProvisioningPolicies', 'sourceId', sourceId)
            // verify required parameter 'provisioningPolicyDto' is not null or undefined
            assertParamExists('bulkUpdateProvisioningPolicies', 'provisioningPolicyDto', provisioningPolicyDto)
            const localVarPath = `/sources/{sourceId}/provisioning-policies/bulk-update`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(provisioningPolicyDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API generates a create policy/template based on field value transforms. This API is intended for use when setting up JDBC Provisioning type sources, but it will also work on other source types. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Provisioning Policy
         * @param {string} sourceId The Source id
         * @param {ProvisioningPolicyDto} provisioningPolicyDto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createProvisioningPolicy: async (sourceId: string, provisioningPolicyDto: ProvisioningPolicyDto, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('createProvisioningPolicy', 'sourceId', sourceId)
            // verify required parameter 'provisioningPolicyDto' is not null or undefined
            assertParamExists('createProvisioningPolicy', 'provisioningPolicyDto', provisioningPolicyDto)
            const localVarPath = `/sources/{sourceId}/provisioning-policies`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(provisioningPolicyDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Creates a new Schema on the specified Source in IdentityNow. 
         * @summary Create Schema on a Source
         * @param {string} sourceId The Source id.
         * @param {Schema} schema 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSchema: async (sourceId: string, schema: Schema, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('createSchema', 'sourceId', sourceId)
            // verify required parameter 'schema' is not null or undefined
            assertParamExists('createSchema', 'schema', schema)
            const localVarPath = `/sources/{sourceId}/schemas`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(schema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This creates a specific source with a full source JSON representation. Any passwords are submitted as plain-text and encrypted upon receipt in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Creates a source in IdentityNow.
         * @param {Source} source 
         * @param {boolean} [provisionAsCsv] Configures the source as a DelimitedFile type of source.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSource: async (source: Source, provisionAsCsv?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'source' is not null or undefined
            assertParamExists('createSource', 'source', source)
            const localVarPath = `/sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (provisionAsCsv !== undefined) {
                localVarQueryParameter['provisionAsCsv'] = provisionAsCsv;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(source, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Deletes the provisioning policy with the specified usage on an application. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Delete Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageType} usageType The type of ProvisioningPolicy usage.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteProvisioningPolicy: async (sourceId: string, usageType: UsageType, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('deleteProvisioningPolicy', 'sourceId', sourceId)
            // verify required parameter 'usageType' is not null or undefined
            assertParamExists('deleteProvisioningPolicy', 'usageType', usageType)
            const localVarPath = `/sources/{sourceId}/provisioning-policies/{usageType}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)))
                .replace(`{${"usageType"}}`, encodeURIComponent(String(usageType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Source Schema by ID
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSchema: async (sourceId: string, schemaId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('deleteSchema', 'sourceId', sourceId)
            // verify required parameter 'schemaId' is not null or undefined
            assertParamExists('deleteSchema', 'schemaId', schemaId)
            const localVarPath = `/sources/{sourceId}/schemas/{schemaId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)))
                .replace(`{${"schemaId"}}`, encodeURIComponent(String(schemaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point deletes a specific source in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. All of accounts on the source will be removed first, then the source will be deleted. Actual status of task execution can be retrieved via method GET `/task-status/{id}`
         * @summary Delete Source by ID
         * @param {string} id The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSource: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSource', 'id', id)
            const localVarPath = `/sources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API downloads the CSV schema that defines the account attributes on a source. >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Downloads source accounts schema template
         * @param {string} id The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        downloadSourceAccountsSchema: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('downloadSourceAccountsSchema', 'id', id)
            const localVarPath = `/sources/{id}/schemas/accounts`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API downloads the CSV schema that defines the entitlement attributes on a source.  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Downloads source entitlements schema template
         * @param {string} id The Source id
         * @param {string} [schemaName] Name of entitlement schema
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        downloadSourceEntitlementsSchema: async (id: string, schemaName?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('downloadSourceEntitlementsSchema', 'id', id)
            const localVarPath = `/sources/{id}/schemas/entitlements`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (schemaName !== undefined) {
                localVarQueryParameter['schemaName'] = schemaName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point retrieves the ProvisioningPolicy with the specified usage on the specified Source in IdentityNow. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageType} usageType The type of ProvisioningPolicy usage.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getProvisioningPolicy: async (sourceId: string, usageType: UsageType, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('getProvisioningPolicy', 'sourceId', sourceId)
            // verify required parameter 'usageType' is not null or undefined
            assertParamExists('getProvisioningPolicy', 'usageType', usageType)
            const localVarPath = `/sources/{sourceId}/provisioning-policies/{usageType}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)))
                .replace(`{${"usageType"}}`, encodeURIComponent(String(usageType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get the Source Schema by ID in IdentityNow. 
         * @summary Get Source Schema by ID
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSchema: async (sourceId: string, schemaId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('getSchema', 'sourceId', sourceId)
            // verify required parameter 'schemaId' is not null or undefined
            assertParamExists('getSchema', 'schemaId', schemaId)
            const localVarPath = `/sources/{sourceId}/schemas/{schemaId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)))
                .replace(`{${"schemaId"}}`, encodeURIComponent(String(schemaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point gets a specific source in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get Source by ID
         * @param {string} id The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSource: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSource', 'id', id)
            const localVarPath = `/sources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint fetches source health by source\'s id
         * @summary This API fetches source health by source\'s id
         * @param {string} sourceId The Source id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSourceHealth: async (sourceId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('getSourceHealth', 'sourceId', sourceId)
            const localVarPath = `/sources/{sourceId}/source-health`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point lists all the ProvisioningPolicies in IdentityNow. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Lists ProvisioningPolicies
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listProvisioningPolicies: async (sourceId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('listProvisioningPolicies', 'sourceId', sourceId)
            const localVarPath = `/sources/{sourceId}/provisioning-policies`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Lists the Schemas that exist on the specified Source in IdentityNow. 
         * @summary List Schemas on a Source
         * @param {string} sourceId The Source ID.
         * @param {string} [includeTypes] If set to \&#39;group\&#39;, then the account schema is filtered and only group schemas are returned. Only a value of \&#39;group\&#39; is recognized.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSchemas: async (sourceId: string, includeTypes?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('listSchemas', 'sourceId', sourceId)
            const localVarPath = `/sources/{sourceId}/schemas`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (includeTypes !== undefined) {
                localVarQueryParameter['include-types'] = includeTypes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point lists all the sources in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or ROLE_SUBADMIN authority is required to call this API.
         * @summary Lists all sources in IdentityNow.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *co, eq, in, sw*  **type**: *eq, in*  **owner.id**: *eq, in*  **features**: *ca, co*  **created**: *eq*  **modified**: *eq*  **managementWorkgroup.id**: *eq*  **description**: *eq*  **authoritative**: *eq*  **healthy**: *eq*  **status**: *eq, in*  **connectionType**: *eq*  **connectorName**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **type, created, modified, name, owner.name, healthy, status**
         * @param {string} [forSubadmin] Filter the returned list of sources for the identity specified by the parameter, which is the id of an identity with the role SOURCE_SUBADMIN. By convention, the value **me** indicates the identity id of the current user. Subadmins may only view Sources which they are able to administer; all other Sources will be filtered out when this parameter is set. If the current user is a SOURCE_SUBADMIN but fails to pass a valid value for this parameter, a 403 Forbidden is returned.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSources: async (limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, forSubadmin?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sorters !== undefined) {
                localVarQueryParameter['sorters'] = sorters;
            }

            if (forSubadmin !== undefined) {
                localVarQueryParameter['for-subadmin'] = forSubadmin;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This end-point updates the provisioning policy with the specified usage on the specified source in IdentityNow. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Update Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageType} usageType The type of ProvisioningPolicy usage.
         * @param {ProvisioningPolicyDto} provisioningPolicyDto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        replaceProvisioningPolicy: async (sourceId: string, usageType: UsageType, provisioningPolicyDto: ProvisioningPolicyDto, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('replaceProvisioningPolicy', 'sourceId', sourceId)
            // verify required parameter 'usageType' is not null or undefined
            assertParamExists('replaceProvisioningPolicy', 'usageType', usageType)
            // verify required parameter 'provisioningPolicyDto' is not null or undefined
            assertParamExists('replaceProvisioningPolicy', 'provisioningPolicyDto', provisioningPolicyDto)
            const localVarPath = `/sources/{sourceId}/provisioning-policies/{usageType}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)))
                .replace(`{${"usageType"}}`, encodeURIComponent(String(usageType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(provisioningPolicyDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API will completely replace an existing Schema with the submitted payload. Some fields of the Schema cannot be updated. These fields are listed below.  * id * name * created * modified  Any attempt to modify these fields will result in an error response with a status code of 400.  > `id` must remain in the request body, but it cannot be changed.  If `id` is omitted from the request body, the result will be a 400 error. 
         * @summary Update Source Schema (Full)
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {Schema} schema 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        replaceSchema: async (sourceId: string, schemaId: string, schema: Schema, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('replaceSchema', 'sourceId', sourceId)
            // verify required parameter 'schemaId' is not null or undefined
            assertParamExists('replaceSchema', 'schemaId', schemaId)
            // verify required parameter 'schema' is not null or undefined
            assertParamExists('replaceSchema', 'schema', schema)
            const localVarPath = `/sources/{sourceId}/schemas/{schemaId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)))
                .replace(`{${"schemaId"}}`, encodeURIComponent(String(schemaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(schema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API updates a source in IdentityNow, using a full object representation. In other words, the existing Source configuration is completely replaced.  Some fields are immutable and cannot be changed, such as:  * id * type * authoritative * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. 
         * @summary Update Source (Full)
         * @param {string} id The Source id
         * @param {Source} source 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        replaceSource: async (id: string, source: Source, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('replaceSource', 'id', id)
            // verify required parameter 'source' is not null or undefined
            assertParamExists('replaceSource', 'source', source)
            const localVarPath = `/sources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(source, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API selectively updates an existing Provisioning Policy using a JSONPatch payload. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Partial update of Provisioning Policy
         * @param {string} sourceId The Source id.
         * @param {UsageType} usageType The type of ProvisioningPolicy usage.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation The JSONPatch payload used to update the schema.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateProvisioningPolicy: async (sourceId: string, usageType: UsageType, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('updateProvisioningPolicy', 'sourceId', sourceId)
            // verify required parameter 'usageType' is not null or undefined
            assertParamExists('updateProvisioningPolicy', 'usageType', usageType)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('updateProvisioningPolicy', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/sources/{sourceId}/provisioning-policies/{usageType}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)))
                .replace(`{${"usageType"}}`, encodeURIComponent(String(usageType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Use this API to selectively update an existing Schema using a JSONPatch payload.   The following schema fields are immutable and cannot be updated:  - id - name - created - modified   To switch an account attribute to a group entitlement, you need to have the following in place:  - `isEntitlement: true` - Must define a schema for the group and [add it to the source](https://developer.sailpoint.com/idn/api/v3/create-schema) before updating the `isGroup` flag.  For example, here is the `group` account attribute referencing a schema that defines the group: ```json {     \"name\": \"groups\",     \"type\": \"STRING\",     \"schema\": {         \"type\": \"CONNECTOR_SCHEMA\",         \"id\": \"2c9180887671ff8c01767b4671fc7d60\",         \"name\": \"group\"     },     \"description\": \"The groups, roles etc. that reference account group objects\",     \"isMulti\": true,     \"isEntitlement\": true,     \"isGroup\": true } ``` 
         * @summary Update Source Schema (Partial)
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation The JSONPatch payload used to update the schema.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateSchema: async (sourceId: string, schemaId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('updateSchema', 'sourceId', sourceId)
            // verify required parameter 'schemaId' is not null or undefined
            assertParamExists('updateSchema', 'schemaId', schemaId)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('updateSchema', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/sources/{sourceId}/schemas/{schemaId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)))
                .replace(`{${"schemaId"}}`, encodeURIComponent(String(schemaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API partially updates a source in IdentityNow, using a list of patch operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  Some fields are immutable and cannot be changed, such as:  * id * type * authoritative * created * modified * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error.  A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or API authority is required to call this API. 
         * @summary Update Source (Partial)
         * @param {string} id The Source id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of account update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Any password changes are submitted as plain-text and encrypted upon receipt in IdentityNow.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateSource: async (id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSource', 'id', id)
            // verify required parameter 'jsonPatchOperation' is not null or undefined
            assertParamExists('updateSource', 'jsonPatchOperation', jsonPatchOperation)
            const localVarPath = `/sources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonPatchOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This uploads a supplemental source connector file (like jdbc driver jars) to a source\'s S3 bucket. This also sends ETS and Audit events. A token with ORG_ADMIN authority is required to call this API.
         * @summary Upload connector file to source
         * @param {string} sourceId The Source id.
         * @param {any} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        uploadConnectorFile: async (sourceId: string, file?: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('uploadConnectorFile', 'sourceId', sourceId)
            const localVarPath = `/sources/{sourceId}/upload-connector-file`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API uploads a source schema template file to configure a source\'s account attributes.  To retrieve the file to modify and upload, log into Identity Now.   Click **Admin** -> **Connections** -> **Sources** -> **`<SourceName>`** -> **Import Data** -> **Account Schema** -> **Options** -> **Download Schema**  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Uploads source accounts schema template
         * @param {string} id The Source id
         * @param {any} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        uploadSourceAccountsSchema: async (id: string, file?: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('uploadSourceAccountsSchema', 'id', id)
            const localVarPath = `/sources/{id}/schemas/accounts`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API uploads a source schema template file to configure a source\'s entitlement attributes.  To retrieve the file to modify and upload, log into Identity Now.   Click **Admin** -> **Connections** -> **Sources** -> **`<SourceName>`** -> **Import Data** -> **Import Entitlements** -> **Download**  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Uploads source entitlements schema template
         * @param {string} id The Source id
         * @param {string} [schemaName] Name of entitlement schema
         * @param {any} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        uploadSourceEntitlementsSchema: async (id: string, schemaName?: string, file?: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('uploadSourceEntitlementsSchema', 'id', id)
            const localVarPath = `/sources/{id}/schemas/entitlements`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (schemaName !== undefined) {
                localVarQueryParameter['schemaName'] = schemaName;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * SourcesApi - functional programming interface
 * @export
 */
export const SourcesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SourcesApiAxiosParamCreator(configuration)
    return {
        /**
         * This end-point updates a list of provisioning policies on the specified source in IdentityNow. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Bulk Update Provisioning Policies
         * @param {string} sourceId The Source id.
         * @param {Array<ProvisioningPolicyDto>} provisioningPolicyDto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async bulkUpdateProvisioningPolicies(sourceId: string, provisioningPolicyDto: Array<ProvisioningPolicyDto>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProvisioningPolicyDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkUpdateProvisioningPolicies(sourceId, provisioningPolicyDto, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API generates a create policy/template based on field value transforms. This API is intended for use when setting up JDBC Provisioning type sources, but it will also work on other source types. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Provisioning Policy
         * @param {string} sourceId The Source id
         * @param {ProvisioningPolicyDto} provisioningPolicyDto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createProvisioningPolicy(sourceId: string, provisioningPolicyDto: ProvisioningPolicyDto, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvisioningPolicyDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProvisioningPolicy(sourceId, provisioningPolicyDto, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new Schema on the specified Source in IdentityNow. 
         * @summary Create Schema on a Source
         * @param {string} sourceId The Source id.
         * @param {Schema} schema 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createSchema(sourceId: string, schema: Schema, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSchema(sourceId, schema, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This creates a specific source with a full source JSON representation. Any passwords are submitted as plain-text and encrypted upon receipt in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Creates a source in IdentityNow.
         * @param {Source} source 
         * @param {boolean} [provisionAsCsv] Configures the source as a DelimitedFile type of source.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createSource(source: Source, provisionAsCsv?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Source>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSource(source, provisionAsCsv, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the provisioning policy with the specified usage on an application. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Delete Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageType} usageType The type of ProvisioningPolicy usage.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProvisioningPolicy(sourceId: string, usageType: UsageType, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProvisioningPolicy(sourceId, usageType, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Source Schema by ID
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSchema(sourceId: string, schemaId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSchema(sourceId, schemaId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This end-point deletes a specific source in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. All of accounts on the source will be removed first, then the source will be deleted. Actual status of task execution can be retrieved via method GET `/task-status/{id}`
         * @summary Delete Source by ID
         * @param {string} id The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSource(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteSource202Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSource(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API downloads the CSV schema that defines the account attributes on a source. >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Downloads source accounts schema template
         * @param {string} id The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async downloadSourceAccountsSchema(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadSourceAccountsSchema(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API downloads the CSV schema that defines the entitlement attributes on a source.  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Downloads source entitlements schema template
         * @param {string} id The Source id
         * @param {string} [schemaName] Name of entitlement schema
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async downloadSourceEntitlementsSchema(id: string, schemaName?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadSourceEntitlementsSchema(id, schemaName, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This end-point retrieves the ProvisioningPolicy with the specified usage on the specified Source in IdentityNow. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageType} usageType The type of ProvisioningPolicy usage.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getProvisioningPolicy(sourceId: string, usageType: UsageType, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvisioningPolicyDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProvisioningPolicy(sourceId, usageType, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the Source Schema by ID in IdentityNow. 
         * @summary Get Source Schema by ID
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSchema(sourceId: string, schemaId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSchema(sourceId, schemaId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This end-point gets a specific source in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get Source by ID
         * @param {string} id The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSource(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Source>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSource(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint fetches source health by source\'s id
         * @summary This API fetches source health by source\'s id
         * @param {string} sourceId The Source id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSourceHealth(sourceId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceHealthDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSourceHealth(sourceId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This end-point lists all the ProvisioningPolicies in IdentityNow. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Lists ProvisioningPolicies
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listProvisioningPolicies(sourceId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProvisioningPolicyDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProvisioningPolicies(sourceId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists the Schemas that exist on the specified Source in IdentityNow. 
         * @summary List Schemas on a Source
         * @param {string} sourceId The Source ID.
         * @param {string} [includeTypes] If set to \&#39;group\&#39;, then the account schema is filtered and only group schemas are returned. Only a value of \&#39;group\&#39; is recognized.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listSchemas(sourceId: string, includeTypes?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Schema>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSchemas(sourceId, includeTypes, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This end-point lists all the sources in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or ROLE_SUBADMIN authority is required to call this API.
         * @summary Lists all sources in IdentityNow.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *co, eq, in, sw*  **type**: *eq, in*  **owner.id**: *eq, in*  **features**: *ca, co*  **created**: *eq*  **modified**: *eq*  **managementWorkgroup.id**: *eq*  **description**: *eq*  **authoritative**: *eq*  **healthy**: *eq*  **status**: *eq, in*  **connectionType**: *eq*  **connectorName**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **type, created, modified, name, owner.name, healthy, status**
         * @param {string} [forSubadmin] Filter the returned list of sources for the identity specified by the parameter, which is the id of an identity with the role SOURCE_SUBADMIN. By convention, the value **me** indicates the identity id of the current user. Subadmins may only view Sources which they are able to administer; all other Sources will be filtered out when this parameter is set. If the current user is a SOURCE_SUBADMIN but fails to pass a valid value for this parameter, a 403 Forbidden is returned.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listSources(limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, forSubadmin?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Source>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSources(limit, offset, count, filters, sorters, forSubadmin, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This end-point updates the provisioning policy with the specified usage on the specified source in IdentityNow. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Update Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageType} usageType The type of ProvisioningPolicy usage.
         * @param {ProvisioningPolicyDto} provisioningPolicyDto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async replaceProvisioningPolicy(sourceId: string, usageType: UsageType, provisioningPolicyDto: ProvisioningPolicyDto, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvisioningPolicyDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.replaceProvisioningPolicy(sourceId, usageType, provisioningPolicyDto, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API will completely replace an existing Schema with the submitted payload. Some fields of the Schema cannot be updated. These fields are listed below.  * id * name * created * modified  Any attempt to modify these fields will result in an error response with a status code of 400.  > `id` must remain in the request body, but it cannot be changed.  If `id` is omitted from the request body, the result will be a 400 error. 
         * @summary Update Source Schema (Full)
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {Schema} schema 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async replaceSchema(sourceId: string, schemaId: string, schema: Schema, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.replaceSchema(sourceId, schemaId, schema, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API updates a source in IdentityNow, using a full object representation. In other words, the existing Source configuration is completely replaced.  Some fields are immutable and cannot be changed, such as:  * id * type * authoritative * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. 
         * @summary Update Source (Full)
         * @param {string} id The Source id
         * @param {Source} source 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async replaceSource(id: string, source: Source, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Source>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.replaceSource(id, source, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API selectively updates an existing Provisioning Policy using a JSONPatch payload. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Partial update of Provisioning Policy
         * @param {string} sourceId The Source id.
         * @param {UsageType} usageType The type of ProvisioningPolicy usage.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation The JSONPatch payload used to update the schema.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateProvisioningPolicy(sourceId: string, usageType: UsageType, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvisioningPolicyDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProvisioningPolicy(sourceId, usageType, jsonPatchOperation, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this API to selectively update an existing Schema using a JSONPatch payload.   The following schema fields are immutable and cannot be updated:  - id - name - created - modified   To switch an account attribute to a group entitlement, you need to have the following in place:  - `isEntitlement: true` - Must define a schema for the group and [add it to the source](https://developer.sailpoint.com/idn/api/v3/create-schema) before updating the `isGroup` flag.  For example, here is the `group` account attribute referencing a schema that defines the group: ```json {     \"name\": \"groups\",     \"type\": \"STRING\",     \"schema\": {         \"type\": \"CONNECTOR_SCHEMA\",         \"id\": \"2c9180887671ff8c01767b4671fc7d60\",         \"name\": \"group\"     },     \"description\": \"The groups, roles etc. that reference account group objects\",     \"isMulti\": true,     \"isEntitlement\": true,     \"isGroup\": true } ``` 
         * @summary Update Source Schema (Partial)
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation The JSONPatch payload used to update the schema.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateSchema(sourceId: string, schemaId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSchema(sourceId, schemaId, jsonPatchOperation, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API partially updates a source in IdentityNow, using a list of patch operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  Some fields are immutable and cannot be changed, such as:  * id * type * authoritative * created * modified * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error.  A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or API authority is required to call this API. 
         * @summary Update Source (Partial)
         * @param {string} id The Source id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of account update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Any password changes are submitted as plain-text and encrypted upon receipt in IdentityNow.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateSource(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Source>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSource(id, jsonPatchOperation, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This uploads a supplemental source connector file (like jdbc driver jars) to a source\'s S3 bucket. This also sends ETS and Audit events. A token with ORG_ADMIN authority is required to call this API.
         * @summary Upload connector file to source
         * @param {string} sourceId The Source id.
         * @param {any} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async uploadConnectorFile(sourceId: string, file?: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Source>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadConnectorFile(sourceId, file, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API uploads a source schema template file to configure a source\'s account attributes.  To retrieve the file to modify and upload, log into Identity Now.   Click **Admin** -> **Connections** -> **Sources** -> **`<SourceName>`** -> **Import Data** -> **Account Schema** -> **Options** -> **Download Schema**  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Uploads source accounts schema template
         * @param {string} id The Source id
         * @param {any} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async uploadSourceAccountsSchema(id: string, file?: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadSourceAccountsSchema(id, file, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API uploads a source schema template file to configure a source\'s entitlement attributes.  To retrieve the file to modify and upload, log into Identity Now.   Click **Admin** -> **Connections** -> **Sources** -> **`<SourceName>`** -> **Import Data** -> **Import Entitlements** -> **Download**  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Uploads source entitlements schema template
         * @param {string} id The Source id
         * @param {string} [schemaName] Name of entitlement schema
         * @param {any} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async uploadSourceEntitlementsSchema(id: string, schemaName?: string, file?: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadSourceEntitlementsSchema(id, schemaName, file, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SourcesApi - factory interface
 * @export
 */
export const SourcesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SourcesApiFp(configuration)
    return {
        /**
         * This end-point updates a list of provisioning policies on the specified source in IdentityNow. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Bulk Update Provisioning Policies
         * @param {string} sourceId The Source id.
         * @param {Array<ProvisioningPolicyDto>} provisioningPolicyDto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateProvisioningPolicies(sourceId: string, provisioningPolicyDto: Array<ProvisioningPolicyDto>, axiosOptions?: any): AxiosPromise<Array<ProvisioningPolicyDto>> {
            return localVarFp.bulkUpdateProvisioningPolicies(sourceId, provisioningPolicyDto, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API generates a create policy/template based on field value transforms. This API is intended for use when setting up JDBC Provisioning type sources, but it will also work on other source types. A token with ORG_ADMIN authority is required to call this API.
         * @summary Create Provisioning Policy
         * @param {string} sourceId The Source id
         * @param {ProvisioningPolicyDto} provisioningPolicyDto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createProvisioningPolicy(sourceId: string, provisioningPolicyDto: ProvisioningPolicyDto, axiosOptions?: any): AxiosPromise<ProvisioningPolicyDto> {
            return localVarFp.createProvisioningPolicy(sourceId, provisioningPolicyDto, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new Schema on the specified Source in IdentityNow. 
         * @summary Create Schema on a Source
         * @param {string} sourceId The Source id.
         * @param {Schema} schema 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSchema(sourceId: string, schema: Schema, axiosOptions?: any): AxiosPromise<Schema> {
            return localVarFp.createSchema(sourceId, schema, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This creates a specific source with a full source JSON representation. Any passwords are submitted as plain-text and encrypted upon receipt in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Creates a source in IdentityNow.
         * @param {Source} source 
         * @param {boolean} [provisionAsCsv] Configures the source as a DelimitedFile type of source.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createSource(source: Source, provisionAsCsv?: boolean, axiosOptions?: any): AxiosPromise<Source> {
            return localVarFp.createSource(source, provisionAsCsv, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the provisioning policy with the specified usage on an application. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Delete Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageType} usageType The type of ProvisioningPolicy usage.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteProvisioningPolicy(sourceId: string, usageType: UsageType, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteProvisioningPolicy(sourceId, usageType, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Source Schema by ID
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSchema(sourceId: string, schemaId: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteSchema(sourceId, schemaId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This end-point deletes a specific source in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. All of accounts on the source will be removed first, then the source will be deleted. Actual status of task execution can be retrieved via method GET `/task-status/{id}`
         * @summary Delete Source by ID
         * @param {string} id The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteSource(id: string, axiosOptions?: any): AxiosPromise<DeleteSource202Response> {
            return localVarFp.deleteSource(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API downloads the CSV schema that defines the account attributes on a source. >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Downloads source accounts schema template
         * @param {string} id The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        downloadSourceAccountsSchema(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.downloadSourceAccountsSchema(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API downloads the CSV schema that defines the entitlement attributes on a source.  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Downloads source entitlements schema template
         * @param {string} id The Source id
         * @param {string} [schemaName] Name of entitlement schema
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        downloadSourceEntitlementsSchema(id: string, schemaName?: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.downloadSourceEntitlementsSchema(id, schemaName, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This end-point retrieves the ProvisioningPolicy with the specified usage on the specified Source in IdentityNow. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageType} usageType The type of ProvisioningPolicy usage.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getProvisioningPolicy(sourceId: string, usageType: UsageType, axiosOptions?: any): AxiosPromise<ProvisioningPolicyDto> {
            return localVarFp.getProvisioningPolicy(sourceId, usageType, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Get the Source Schema by ID in IdentityNow. 
         * @summary Get Source Schema by ID
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSchema(sourceId: string, schemaId: string, axiosOptions?: any): AxiosPromise<Schema> {
            return localVarFp.getSchema(sourceId, schemaId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This end-point gets a specific source in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Get Source by ID
         * @param {string} id The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSource(id: string, axiosOptions?: any): AxiosPromise<Source> {
            return localVarFp.getSource(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint fetches source health by source\'s id
         * @summary This API fetches source health by source\'s id
         * @param {string} sourceId The Source id.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSourceHealth(sourceId: string, axiosOptions?: any): AxiosPromise<SourceHealthDto> {
            return localVarFp.getSourceHealth(sourceId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This end-point lists all the ProvisioningPolicies in IdentityNow. A token with API, or ORG_ADMIN authority is required to call this API.
         * @summary Lists ProvisioningPolicies
         * @param {string} sourceId The Source id
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listProvisioningPolicies(sourceId: string, axiosOptions?: any): AxiosPromise<Array<ProvisioningPolicyDto>> {
            return localVarFp.listProvisioningPolicies(sourceId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Lists the Schemas that exist on the specified Source in IdentityNow. 
         * @summary List Schemas on a Source
         * @param {string} sourceId The Source ID.
         * @param {string} [includeTypes] If set to \&#39;group\&#39;, then the account schema is filtered and only group schemas are returned. Only a value of \&#39;group\&#39; is recognized.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSchemas(sourceId: string, includeTypes?: string, axiosOptions?: any): AxiosPromise<Array<Schema>> {
            return localVarFp.listSchemas(sourceId, includeTypes, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This end-point lists all the sources in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or ROLE_SUBADMIN authority is required to call this API.
         * @summary Lists all sources in IdentityNow.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *co, eq, in, sw*  **type**: *eq, in*  **owner.id**: *eq, in*  **features**: *ca, co*  **created**: *eq*  **modified**: *eq*  **managementWorkgroup.id**: *eq*  **description**: *eq*  **authoritative**: *eq*  **healthy**: *eq*  **status**: *eq, in*  **connectionType**: *eq*  **connectorName**: *eq*
         * @param {string} [sorters] Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **type, created, modified, name, owner.name, healthy, status**
         * @param {string} [forSubadmin] Filter the returned list of sources for the identity specified by the parameter, which is the id of an identity with the role SOURCE_SUBADMIN. By convention, the value **me** indicates the identity id of the current user. Subadmins may only view Sources which they are able to administer; all other Sources will be filtered out when this parameter is set. If the current user is a SOURCE_SUBADMIN but fails to pass a valid value for this parameter, a 403 Forbidden is returned.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listSources(limit?: number, offset?: number, count?: boolean, filters?: string, sorters?: string, forSubadmin?: string, axiosOptions?: any): AxiosPromise<Array<Source>> {
            return localVarFp.listSources(limit, offset, count, filters, sorters, forSubadmin, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This end-point updates the provisioning policy with the specified usage on the specified source in IdentityNow. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Update Provisioning Policy by UsageType
         * @param {string} sourceId The Source ID.
         * @param {UsageType} usageType The type of ProvisioningPolicy usage.
         * @param {ProvisioningPolicyDto} provisioningPolicyDto 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        replaceProvisioningPolicy(sourceId: string, usageType: UsageType, provisioningPolicyDto: ProvisioningPolicyDto, axiosOptions?: any): AxiosPromise<ProvisioningPolicyDto> {
            return localVarFp.replaceProvisioningPolicy(sourceId, usageType, provisioningPolicyDto, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API will completely replace an existing Schema with the submitted payload. Some fields of the Schema cannot be updated. These fields are listed below.  * id * name * created * modified  Any attempt to modify these fields will result in an error response with a status code of 400.  > `id` must remain in the request body, but it cannot be changed.  If `id` is omitted from the request body, the result will be a 400 error. 
         * @summary Update Source Schema (Full)
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {Schema} schema 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        replaceSchema(sourceId: string, schemaId: string, schema: Schema, axiosOptions?: any): AxiosPromise<Schema> {
            return localVarFp.replaceSchema(sourceId, schemaId, schema, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API updates a source in IdentityNow, using a full object representation. In other words, the existing Source configuration is completely replaced.  Some fields are immutable and cannot be changed, such as:  * id * type * authoritative * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. 
         * @summary Update Source (Full)
         * @param {string} id The Source id
         * @param {Source} source 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        replaceSource(id: string, source: Source, axiosOptions?: any): AxiosPromise<Source> {
            return localVarFp.replaceSource(id, source, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API selectively updates an existing Provisioning Policy using a JSONPatch payload. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
         * @summary Partial update of Provisioning Policy
         * @param {string} sourceId The Source id.
         * @param {UsageType} usageType The type of ProvisioningPolicy usage.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation The JSONPatch payload used to update the schema.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateProvisioningPolicy(sourceId: string, usageType: UsageType, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: any): AxiosPromise<ProvisioningPolicyDto> {
            return localVarFp.updateProvisioningPolicy(sourceId, usageType, jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Use this API to selectively update an existing Schema using a JSONPatch payload.   The following schema fields are immutable and cannot be updated:  - id - name - created - modified   To switch an account attribute to a group entitlement, you need to have the following in place:  - `isEntitlement: true` - Must define a schema for the group and [add it to the source](https://developer.sailpoint.com/idn/api/v3/create-schema) before updating the `isGroup` flag.  For example, here is the `group` account attribute referencing a schema that defines the group: ```json {     \"name\": \"groups\",     \"type\": \"STRING\",     \"schema\": {         \"type\": \"CONNECTOR_SCHEMA\",         \"id\": \"2c9180887671ff8c01767b4671fc7d60\",         \"name\": \"group\"     },     \"description\": \"The groups, roles etc. that reference account group objects\",     \"isMulti\": true,     \"isEntitlement\": true,     \"isGroup\": true } ``` 
         * @summary Update Source Schema (Partial)
         * @param {string} sourceId The Source id.
         * @param {string} schemaId The Schema id.
         * @param {Array<JsonPatchOperation>} jsonPatchOperation The JSONPatch payload used to update the schema.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateSchema(sourceId: string, schemaId: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: any): AxiosPromise<Schema> {
            return localVarFp.updateSchema(sourceId, schemaId, jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API partially updates a source in IdentityNow, using a list of patch operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  Some fields are immutable and cannot be changed, such as:  * id * type * authoritative * created * modified * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error.  A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or API authority is required to call this API. 
         * @summary Update Source (Partial)
         * @param {string} id The Source id
         * @param {Array<JsonPatchOperation>} jsonPatchOperation A list of account update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Any password changes are submitted as plain-text and encrypted upon receipt in IdentityNow.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateSource(id: string, jsonPatchOperation: Array<JsonPatchOperation>, axiosOptions?: any): AxiosPromise<Source> {
            return localVarFp.updateSource(id, jsonPatchOperation, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This uploads a supplemental source connector file (like jdbc driver jars) to a source\'s S3 bucket. This also sends ETS and Audit events. A token with ORG_ADMIN authority is required to call this API.
         * @summary Upload connector file to source
         * @param {string} sourceId The Source id.
         * @param {any} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        uploadConnectorFile(sourceId: string, file?: any, axiosOptions?: any): AxiosPromise<Source> {
            return localVarFp.uploadConnectorFile(sourceId, file, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API uploads a source schema template file to configure a source\'s account attributes.  To retrieve the file to modify and upload, log into Identity Now.   Click **Admin** -> **Connections** -> **Sources** -> **`<SourceName>`** -> **Import Data** -> **Account Schema** -> **Options** -> **Download Schema**  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Uploads source accounts schema template
         * @param {string} id The Source id
         * @param {any} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        uploadSourceAccountsSchema(id: string, file?: any, axiosOptions?: any): AxiosPromise<Schema> {
            return localVarFp.uploadSourceAccountsSchema(id, file, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API uploads a source schema template file to configure a source\'s entitlement attributes.  To retrieve the file to modify and upload, log into Identity Now.   Click **Admin** -> **Connections** -> **Sources** -> **`<SourceName>`** -> **Import Data** -> **Import Entitlements** -> **Download**  >**NOTE: This API is designated only for Delimited File sources.**
         * @summary Uploads source entitlements schema template
         * @param {string} id The Source id
         * @param {string} [schemaName] Name of entitlement schema
         * @param {any} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        uploadSourceEntitlementsSchema(id: string, schemaName?: string, file?: any, axiosOptions?: any): AxiosPromise<Schema> {
            return localVarFp.uploadSourceEntitlementsSchema(id, schemaName, file, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for bulkUpdateProvisioningPolicies operation in SourcesApi.
 * @export
 * @interface SourcesApiBulkUpdateProvisioningPoliciesRequest
 */
export interface SourcesApiBulkUpdateProvisioningPoliciesRequest {
    /**
     * The Source id.
     * @type {string}
     * @memberof SourcesApiBulkUpdateProvisioningPolicies
     */
    readonly sourceId: string

    /**
     * 
     * @type {Array<ProvisioningPolicyDto>}
     * @memberof SourcesApiBulkUpdateProvisioningPolicies
     */
    readonly provisioningPolicyDto: Array<ProvisioningPolicyDto>
}

/**
 * Request parameters for createProvisioningPolicy operation in SourcesApi.
 * @export
 * @interface SourcesApiCreateProvisioningPolicyRequest
 */
export interface SourcesApiCreateProvisioningPolicyRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesApiCreateProvisioningPolicy
     */
    readonly sourceId: string

    /**
     * 
     * @type {ProvisioningPolicyDto}
     * @memberof SourcesApiCreateProvisioningPolicy
     */
    readonly provisioningPolicyDto: ProvisioningPolicyDto
}

/**
 * Request parameters for createSchema operation in SourcesApi.
 * @export
 * @interface SourcesApiCreateSchemaRequest
 */
export interface SourcesApiCreateSchemaRequest {
    /**
     * The Source id.
     * @type {string}
     * @memberof SourcesApiCreateSchema
     */
    readonly sourceId: string

    /**
     * 
     * @type {Schema}
     * @memberof SourcesApiCreateSchema
     */
    readonly schema: Schema
}

/**
 * Request parameters for createSource operation in SourcesApi.
 * @export
 * @interface SourcesApiCreateSourceRequest
 */
export interface SourcesApiCreateSourceRequest {
    /**
     * 
     * @type {Source}
     * @memberof SourcesApiCreateSource
     */
    readonly source: Source

    /**
     * Configures the source as a DelimitedFile type of source.
     * @type {boolean}
     * @memberof SourcesApiCreateSource
     */
    readonly provisionAsCsv?: boolean
}

/**
 * Request parameters for deleteProvisioningPolicy operation in SourcesApi.
 * @export
 * @interface SourcesApiDeleteProvisioningPolicyRequest
 */
export interface SourcesApiDeleteProvisioningPolicyRequest {
    /**
     * The Source ID.
     * @type {string}
     * @memberof SourcesApiDeleteProvisioningPolicy
     */
    readonly sourceId: string

    /**
     * The type of ProvisioningPolicy usage.
     * @type {UsageType}
     * @memberof SourcesApiDeleteProvisioningPolicy
     */
    readonly usageType: UsageType
}

/**
 * Request parameters for deleteSchema operation in SourcesApi.
 * @export
 * @interface SourcesApiDeleteSchemaRequest
 */
export interface SourcesApiDeleteSchemaRequest {
    /**
     * The Source id.
     * @type {string}
     * @memberof SourcesApiDeleteSchema
     */
    readonly sourceId: string

    /**
     * The Schema id.
     * @type {string}
     * @memberof SourcesApiDeleteSchema
     */
    readonly schemaId: string
}

/**
 * Request parameters for deleteSource operation in SourcesApi.
 * @export
 * @interface SourcesApiDeleteSourceRequest
 */
export interface SourcesApiDeleteSourceRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesApiDeleteSource
     */
    readonly id: string
}

/**
 * Request parameters for downloadSourceAccountsSchema operation in SourcesApi.
 * @export
 * @interface SourcesApiDownloadSourceAccountsSchemaRequest
 */
export interface SourcesApiDownloadSourceAccountsSchemaRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesApiDownloadSourceAccountsSchema
     */
    readonly id: string
}

/**
 * Request parameters for downloadSourceEntitlementsSchema operation in SourcesApi.
 * @export
 * @interface SourcesApiDownloadSourceEntitlementsSchemaRequest
 */
export interface SourcesApiDownloadSourceEntitlementsSchemaRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesApiDownloadSourceEntitlementsSchema
     */
    readonly id: string

    /**
     * Name of entitlement schema
     * @type {string}
     * @memberof SourcesApiDownloadSourceEntitlementsSchema
     */
    readonly schemaName?: string
}

/**
 * Request parameters for getProvisioningPolicy operation in SourcesApi.
 * @export
 * @interface SourcesApiGetProvisioningPolicyRequest
 */
export interface SourcesApiGetProvisioningPolicyRequest {
    /**
     * The Source ID.
     * @type {string}
     * @memberof SourcesApiGetProvisioningPolicy
     */
    readonly sourceId: string

    /**
     * The type of ProvisioningPolicy usage.
     * @type {UsageType}
     * @memberof SourcesApiGetProvisioningPolicy
     */
    readonly usageType: UsageType
}

/**
 * Request parameters for getSchema operation in SourcesApi.
 * @export
 * @interface SourcesApiGetSchemaRequest
 */
export interface SourcesApiGetSchemaRequest {
    /**
     * The Source id.
     * @type {string}
     * @memberof SourcesApiGetSchema
     */
    readonly sourceId: string

    /**
     * The Schema id.
     * @type {string}
     * @memberof SourcesApiGetSchema
     */
    readonly schemaId: string
}

/**
 * Request parameters for getSource operation in SourcesApi.
 * @export
 * @interface SourcesApiGetSourceRequest
 */
export interface SourcesApiGetSourceRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesApiGetSource
     */
    readonly id: string
}

/**
 * Request parameters for getSourceHealth operation in SourcesApi.
 * @export
 * @interface SourcesApiGetSourceHealthRequest
 */
export interface SourcesApiGetSourceHealthRequest {
    /**
     * The Source id.
     * @type {string}
     * @memberof SourcesApiGetSourceHealth
     */
    readonly sourceId: string
}

/**
 * Request parameters for listProvisioningPolicies operation in SourcesApi.
 * @export
 * @interface SourcesApiListProvisioningPoliciesRequest
 */
export interface SourcesApiListProvisioningPoliciesRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesApiListProvisioningPolicies
     */
    readonly sourceId: string
}

/**
 * Request parameters for listSchemas operation in SourcesApi.
 * @export
 * @interface SourcesApiListSchemasRequest
 */
export interface SourcesApiListSchemasRequest {
    /**
     * The Source ID.
     * @type {string}
     * @memberof SourcesApiListSchemas
     */
    readonly sourceId: string

    /**
     * If set to \&#39;group\&#39;, then the account schema is filtered and only group schemas are returned. Only a value of \&#39;group\&#39; is recognized.
     * @type {string}
     * @memberof SourcesApiListSchemas
     */
    readonly includeTypes?: string
}

/**
 * Request parameters for listSources operation in SourcesApi.
 * @export
 * @interface SourcesApiListSourcesRequest
 */
export interface SourcesApiListSourcesRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SourcesApiListSources
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof SourcesApiListSources
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof SourcesApiListSources
     */
    readonly count?: boolean

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results)  Filtering is supported for the following fields and operators:  **id**: *eq, in*  **name**: *co, eq, in, sw*  **type**: *eq, in*  **owner.id**: *eq, in*  **features**: *ca, co*  **created**: *eq*  **modified**: *eq*  **managementWorkgroup.id**: *eq*  **description**: *eq*  **authoritative**: *eq*  **healthy**: *eq*  **status**: *eq, in*  **connectionType**: *eq*  **connectorName**: *eq*
     * @type {string}
     * @memberof SourcesApiListSources
     */
    readonly filters?: string

    /**
     * Sort results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#sorting-results)  Sorting is supported for the following fields: **type, created, modified, name, owner.name, healthy, status**
     * @type {string}
     * @memberof SourcesApiListSources
     */
    readonly sorters?: string

    /**
     * Filter the returned list of sources for the identity specified by the parameter, which is the id of an identity with the role SOURCE_SUBADMIN. By convention, the value **me** indicates the identity id of the current user. Subadmins may only view Sources which they are able to administer; all other Sources will be filtered out when this parameter is set. If the current user is a SOURCE_SUBADMIN but fails to pass a valid value for this parameter, a 403 Forbidden is returned.
     * @type {string}
     * @memberof SourcesApiListSources
     */
    readonly forSubadmin?: string
}

/**
 * Request parameters for replaceProvisioningPolicy operation in SourcesApi.
 * @export
 * @interface SourcesApiReplaceProvisioningPolicyRequest
 */
export interface SourcesApiReplaceProvisioningPolicyRequest {
    /**
     * The Source ID.
     * @type {string}
     * @memberof SourcesApiReplaceProvisioningPolicy
     */
    readonly sourceId: string

    /**
     * The type of ProvisioningPolicy usage.
     * @type {UsageType}
     * @memberof SourcesApiReplaceProvisioningPolicy
     */
    readonly usageType: UsageType

    /**
     * 
     * @type {ProvisioningPolicyDto}
     * @memberof SourcesApiReplaceProvisioningPolicy
     */
    readonly provisioningPolicyDto: ProvisioningPolicyDto
}

/**
 * Request parameters for replaceSchema operation in SourcesApi.
 * @export
 * @interface SourcesApiReplaceSchemaRequest
 */
export interface SourcesApiReplaceSchemaRequest {
    /**
     * The Source id.
     * @type {string}
     * @memberof SourcesApiReplaceSchema
     */
    readonly sourceId: string

    /**
     * The Schema id.
     * @type {string}
     * @memberof SourcesApiReplaceSchema
     */
    readonly schemaId: string

    /**
     * 
     * @type {Schema}
     * @memberof SourcesApiReplaceSchema
     */
    readonly schema: Schema
}

/**
 * Request parameters for replaceSource operation in SourcesApi.
 * @export
 * @interface SourcesApiReplaceSourceRequest
 */
export interface SourcesApiReplaceSourceRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesApiReplaceSource
     */
    readonly id: string

    /**
     * 
     * @type {Source}
     * @memberof SourcesApiReplaceSource
     */
    readonly source: Source
}

/**
 * Request parameters for updateProvisioningPolicy operation in SourcesApi.
 * @export
 * @interface SourcesApiUpdateProvisioningPolicyRequest
 */
export interface SourcesApiUpdateProvisioningPolicyRequest {
    /**
     * The Source id.
     * @type {string}
     * @memberof SourcesApiUpdateProvisioningPolicy
     */
    readonly sourceId: string

    /**
     * The type of ProvisioningPolicy usage.
     * @type {UsageType}
     * @memberof SourcesApiUpdateProvisioningPolicy
     */
    readonly usageType: UsageType

    /**
     * The JSONPatch payload used to update the schema.
     * @type {Array<JsonPatchOperation>}
     * @memberof SourcesApiUpdateProvisioningPolicy
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * Request parameters for updateSchema operation in SourcesApi.
 * @export
 * @interface SourcesApiUpdateSchemaRequest
 */
export interface SourcesApiUpdateSchemaRequest {
    /**
     * The Source id.
     * @type {string}
     * @memberof SourcesApiUpdateSchema
     */
    readonly sourceId: string

    /**
     * The Schema id.
     * @type {string}
     * @memberof SourcesApiUpdateSchema
     */
    readonly schemaId: string

    /**
     * The JSONPatch payload used to update the schema.
     * @type {Array<JsonPatchOperation>}
     * @memberof SourcesApiUpdateSchema
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * Request parameters for updateSource operation in SourcesApi.
 * @export
 * @interface SourcesApiUpdateSourceRequest
 */
export interface SourcesApiUpdateSourceRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesApiUpdateSource
     */
    readonly id: string

    /**
     * A list of account update operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard. Any password changes are submitted as plain-text and encrypted upon receipt in IdentityNow.
     * @type {Array<JsonPatchOperation>}
     * @memberof SourcesApiUpdateSource
     */
    readonly jsonPatchOperation: Array<JsonPatchOperation>
}

/**
 * Request parameters for uploadConnectorFile operation in SourcesApi.
 * @export
 * @interface SourcesApiUploadConnectorFileRequest
 */
export interface SourcesApiUploadConnectorFileRequest {
    /**
     * The Source id.
     * @type {string}
     * @memberof SourcesApiUploadConnectorFile
     */
    readonly sourceId: string

    /**
     * 
     * @type {any}
     * @memberof SourcesApiUploadConnectorFile
     */
    readonly file?: any
}

/**
 * Request parameters for uploadSourceAccountsSchema operation in SourcesApi.
 * @export
 * @interface SourcesApiUploadSourceAccountsSchemaRequest
 */
export interface SourcesApiUploadSourceAccountsSchemaRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesApiUploadSourceAccountsSchema
     */
    readonly id: string

    /**
     * 
     * @type {any}
     * @memberof SourcesApiUploadSourceAccountsSchema
     */
    readonly file?: any
}

/**
 * Request parameters for uploadSourceEntitlementsSchema operation in SourcesApi.
 * @export
 * @interface SourcesApiUploadSourceEntitlementsSchemaRequest
 */
export interface SourcesApiUploadSourceEntitlementsSchemaRequest {
    /**
     * The Source id
     * @type {string}
     * @memberof SourcesApiUploadSourceEntitlementsSchema
     */
    readonly id: string

    /**
     * Name of entitlement schema
     * @type {string}
     * @memberof SourcesApiUploadSourceEntitlementsSchema
     */
    readonly schemaName?: string

    /**
     * 
     * @type {any}
     * @memberof SourcesApiUploadSourceEntitlementsSchema
     */
    readonly file?: any
}

/**
 * SourcesApi - object-oriented interface
 * @export
 * @class SourcesApi
 * @extends {BaseAPI}
 */
export class SourcesApi extends BaseAPI {
    /**
     * This end-point updates a list of provisioning policies on the specified source in IdentityNow. A token with API, or ORG_ADMIN authority is required to call this API.
     * @summary Bulk Update Provisioning Policies
     * @param {SourcesApiBulkUpdateProvisioningPoliciesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public bulkUpdateProvisioningPolicies(requestParameters: SourcesApiBulkUpdateProvisioningPoliciesRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).bulkUpdateProvisioningPolicies(requestParameters.sourceId, requestParameters.provisioningPolicyDto, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API generates a create policy/template based on field value transforms. This API is intended for use when setting up JDBC Provisioning type sources, but it will also work on other source types. A token with ORG_ADMIN authority is required to call this API.
     * @summary Create Provisioning Policy
     * @param {SourcesApiCreateProvisioningPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public createProvisioningPolicy(requestParameters: SourcesApiCreateProvisioningPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).createProvisioningPolicy(requestParameters.sourceId, requestParameters.provisioningPolicyDto, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new Schema on the specified Source in IdentityNow. 
     * @summary Create Schema on a Source
     * @param {SourcesApiCreateSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public createSchema(requestParameters: SourcesApiCreateSchemaRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).createSchema(requestParameters.sourceId, requestParameters.schema, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This creates a specific source with a full source JSON representation. Any passwords are submitted as plain-text and encrypted upon receipt in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary Creates a source in IdentityNow.
     * @param {SourcesApiCreateSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public createSource(requestParameters: SourcesApiCreateSourceRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).createSource(requestParameters.source, requestParameters.provisionAsCsv, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the provisioning policy with the specified usage on an application. A token with API, or ORG_ADMIN authority is required to call this API.
     * @summary Delete Provisioning Policy by UsageType
     * @param {SourcesApiDeleteProvisioningPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public deleteProvisioningPolicy(requestParameters: SourcesApiDeleteProvisioningPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).deleteProvisioningPolicy(requestParameters.sourceId, requestParameters.usageType, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Source Schema by ID
     * @param {SourcesApiDeleteSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public deleteSchema(requestParameters: SourcesApiDeleteSchemaRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).deleteSchema(requestParameters.sourceId, requestParameters.schemaId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point deletes a specific source in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. All of accounts on the source will be removed first, then the source will be deleted. Actual status of task execution can be retrieved via method GET `/task-status/{id}`
     * @summary Delete Source by ID
     * @param {SourcesApiDeleteSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public deleteSource(requestParameters: SourcesApiDeleteSourceRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).deleteSource(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API downloads the CSV schema that defines the account attributes on a source. >**NOTE: This API is designated only for Delimited File sources.**
     * @summary Downloads source accounts schema template
     * @param {SourcesApiDownloadSourceAccountsSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public downloadSourceAccountsSchema(requestParameters: SourcesApiDownloadSourceAccountsSchemaRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).downloadSourceAccountsSchema(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API downloads the CSV schema that defines the entitlement attributes on a source.  >**NOTE: This API is designated only for Delimited File sources.**
     * @summary Downloads source entitlements schema template
     * @param {SourcesApiDownloadSourceEntitlementsSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public downloadSourceEntitlementsSchema(requestParameters: SourcesApiDownloadSourceEntitlementsSchemaRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).downloadSourceEntitlementsSchema(requestParameters.id, requestParameters.schemaName, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point retrieves the ProvisioningPolicy with the specified usage on the specified Source in IdentityNow. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary Get Provisioning Policy by UsageType
     * @param {SourcesApiGetProvisioningPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public getProvisioningPolicy(requestParameters: SourcesApiGetProvisioningPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).getProvisioningPolicy(requestParameters.sourceId, requestParameters.usageType, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the Source Schema by ID in IdentityNow. 
     * @summary Get Source Schema by ID
     * @param {SourcesApiGetSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public getSchema(requestParameters: SourcesApiGetSchemaRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).getSchema(requestParameters.sourceId, requestParameters.schemaId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point gets a specific source in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary Get Source by ID
     * @param {SourcesApiGetSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public getSource(requestParameters: SourcesApiGetSourceRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).getSource(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint fetches source health by source\'s id
     * @summary This API fetches source health by source\'s id
     * @param {SourcesApiGetSourceHealthRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public getSourceHealth(requestParameters: SourcesApiGetSourceHealthRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).getSourceHealth(requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point lists all the ProvisioningPolicies in IdentityNow. A token with API, or ORG_ADMIN authority is required to call this API.
     * @summary Lists ProvisioningPolicies
     * @param {SourcesApiListProvisioningPoliciesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public listProvisioningPolicies(requestParameters: SourcesApiListProvisioningPoliciesRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).listProvisioningPolicies(requestParameters.sourceId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the Schemas that exist on the specified Source in IdentityNow. 
     * @summary List Schemas on a Source
     * @param {SourcesApiListSchemasRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public listSchemas(requestParameters: SourcesApiListSchemasRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).listSchemas(requestParameters.sourceId, requestParameters.includeTypes, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point lists all the sources in IdentityNow. A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or ROLE_SUBADMIN authority is required to call this API.
     * @summary Lists all sources in IdentityNow.
     * @param {SourcesApiListSourcesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public listSources(requestParameters: SourcesApiListSourcesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).listSources(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.filters, requestParameters.sorters, requestParameters.forSubadmin, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This end-point updates the provisioning policy with the specified usage on the specified source in IdentityNow. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary Update Provisioning Policy by UsageType
     * @param {SourcesApiReplaceProvisioningPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public replaceProvisioningPolicy(requestParameters: SourcesApiReplaceProvisioningPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).replaceProvisioningPolicy(requestParameters.sourceId, requestParameters.usageType, requestParameters.provisioningPolicyDto, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API will completely replace an existing Schema with the submitted payload. Some fields of the Schema cannot be updated. These fields are listed below.  * id * name * created * modified  Any attempt to modify these fields will result in an error response with a status code of 400.  > `id` must remain in the request body, but it cannot be changed.  If `id` is omitted from the request body, the result will be a 400 error. 
     * @summary Update Source Schema (Full)
     * @param {SourcesApiReplaceSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public replaceSchema(requestParameters: SourcesApiReplaceSchemaRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).replaceSchema(requestParameters.sourceId, requestParameters.schemaId, requestParameters.schema, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API updates a source in IdentityNow, using a full object representation. In other words, the existing Source configuration is completely replaced.  Some fields are immutable and cannot be changed, such as:  * id * type * authoritative * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error.  A token with ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API. 
     * @summary Update Source (Full)
     * @param {SourcesApiReplaceSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public replaceSource(requestParameters: SourcesApiReplaceSourceRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).replaceSource(requestParameters.id, requestParameters.source, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API selectively updates an existing Provisioning Policy using a JSONPatch payload. A token with API, ORG_ADMIN, SOURCE_ADMIN, or SOURCE_SUBADMIN authority is required to call this API.
     * @summary Partial update of Provisioning Policy
     * @param {SourcesApiUpdateProvisioningPolicyRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public updateProvisioningPolicy(requestParameters: SourcesApiUpdateProvisioningPolicyRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).updateProvisioningPolicy(requestParameters.sourceId, requestParameters.usageType, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this API to selectively update an existing Schema using a JSONPatch payload.   The following schema fields are immutable and cannot be updated:  - id - name - created - modified   To switch an account attribute to a group entitlement, you need to have the following in place:  - `isEntitlement: true` - Must define a schema for the group and [add it to the source](https://developer.sailpoint.com/idn/api/v3/create-schema) before updating the `isGroup` flag.  For example, here is the `group` account attribute referencing a schema that defines the group: ```json {     \"name\": \"groups\",     \"type\": \"STRING\",     \"schema\": {         \"type\": \"CONNECTOR_SCHEMA\",         \"id\": \"2c9180887671ff8c01767b4671fc7d60\",         \"name\": \"group\"     },     \"description\": \"The groups, roles etc. that reference account group objects\",     \"isMulti\": true,     \"isEntitlement\": true,     \"isGroup\": true } ``` 
     * @summary Update Source Schema (Partial)
     * @param {SourcesApiUpdateSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public updateSchema(requestParameters: SourcesApiUpdateSchemaRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).updateSchema(requestParameters.sourceId, requestParameters.schemaId, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API partially updates a source in IdentityNow, using a list of patch operations according to the [JSON Patch](https://tools.ietf.org/html/rfc6902) standard.  Some fields are immutable and cannot be changed, such as:  * id * type * authoritative * created * modified * connector * connectorClass * passwordPolicies  Attempts to modify these fields will result in a 400 error.  A token with ORG_ADMIN, SOURCE_ADMIN, SOURCE_SUBADMIN, or API authority is required to call this API. 
     * @summary Update Source (Partial)
     * @param {SourcesApiUpdateSourceRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public updateSource(requestParameters: SourcesApiUpdateSourceRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).updateSource(requestParameters.id, requestParameters.jsonPatchOperation, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This uploads a supplemental source connector file (like jdbc driver jars) to a source\'s S3 bucket. This also sends ETS and Audit events. A token with ORG_ADMIN authority is required to call this API.
     * @summary Upload connector file to source
     * @param {SourcesApiUploadConnectorFileRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public uploadConnectorFile(requestParameters: SourcesApiUploadConnectorFileRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).uploadConnectorFile(requestParameters.sourceId, requestParameters.file, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API uploads a source schema template file to configure a source\'s account attributes.  To retrieve the file to modify and upload, log into Identity Now.   Click **Admin** -> **Connections** -> **Sources** -> **`<SourceName>`** -> **Import Data** -> **Account Schema** -> **Options** -> **Download Schema**  >**NOTE: This API is designated only for Delimited File sources.**
     * @summary Uploads source accounts schema template
     * @param {SourcesApiUploadSourceAccountsSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public uploadSourceAccountsSchema(requestParameters: SourcesApiUploadSourceAccountsSchemaRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).uploadSourceAccountsSchema(requestParameters.id, requestParameters.file, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API uploads a source schema template file to configure a source\'s entitlement attributes.  To retrieve the file to modify and upload, log into Identity Now.   Click **Admin** -> **Connections** -> **Sources** -> **`<SourceName>`** -> **Import Data** -> **Import Entitlements** -> **Download**  >**NOTE: This API is designated only for Delimited File sources.**
     * @summary Uploads source entitlements schema template
     * @param {SourcesApiUploadSourceEntitlementsSchemaRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public uploadSourceEntitlementsSchema(requestParameters: SourcesApiUploadSourceEntitlementsSchemaRequest, axiosOptions?: AxiosRequestConfig) {
        return SourcesApiFp(this.configuration).uploadSourceEntitlementsSchema(requestParameters.id, requestParameters.schemaName, requestParameters.file, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TransformsApi - axios parameter creator
 * @export
 */
export const TransformsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new transform object immediately. By default, the internal flag is set to false to indicate that this is a custom transform. Only SailPoint employees have the ability to create a transform with internal set to true. Newly created Transforms can be used in the Identity Profile mappings within the UI. A token with transform write authority is required to call this API.
         * @summary Create transform
         * @param {Transform} transform The transform to be created.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createTransform: async (transform: Transform, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transform' is not null or undefined
            assertParamExists('createTransform', 'transform', transform)
            const localVarPath = `/transforms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transform, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Deletes the transform specified by the given ID. Attempting to delete a transform that is used in one or more Identity Profile mappings will result in an error. If this occurs, you must first remove the transform from all mappings before deleting the transform. A token with transform delete authority is required to call this API.
         * @summary Delete a transform
         * @param {string} id ID of the transform to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransform: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTransform', 'id', id)
            const localVarPath = `/transforms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API returns the transform specified by the given ID. A token with transform read authority is required to call this API.
         * @summary Transform by ID
         * @param {string} id ID of the transform to retrieve
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getTransform: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTransform', 'id', id)
            const localVarPath = `/transforms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of all saved transform objects. A token with transforms-list read authority is required to call this API.
         * @summary List transforms
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [name] Name of the transform to retrieve from the list.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: **internal**: *eq* **name**: *eq*, *sw*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getTransformsList: async (offset?: number, limit?: number, count?: boolean, name?: string, filters?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transforms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Replaces the transform specified by the given ID with the transform provided in the request body. Only the \"attributes\" field is mutable. Attempting to change other properties (ex. \"name\" and \"type\") will result in an error. A token with transform write authority is required to call this API.
         * @summary Update a transform
         * @param {string} id ID of the transform to update
         * @param {Transform} [transform] The updated transform object (must include \&quot;name\&quot;, \&quot;type\&quot;, and \&quot;attributes\&quot; fields).
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateTransform: async (id: string, transform?: Transform, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTransform', 'id', id)
            const localVarPath = `/transforms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transform, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransformsApi - functional programming interface
 * @export
 */
export const TransformsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransformsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new transform object immediately. By default, the internal flag is set to false to indicate that this is a custom transform. Only SailPoint employees have the ability to create a transform with internal set to true. Newly created Transforms can be used in the Identity Profile mappings within the UI. A token with transform write authority is required to call this API.
         * @summary Create transform
         * @param {Transform} transform The transform to be created.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createTransform(transform: Transform, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transform>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTransform(transform, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the transform specified by the given ID. Attempting to delete a transform that is used in one or more Identity Profile mappings will result in an error. If this occurs, you must first remove the transform from all mappings before deleting the transform. A token with transform delete authority is required to call this API.
         * @summary Delete a transform
         * @param {string} id ID of the transform to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTransform(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTransform(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API returns the transform specified by the given ID. A token with transform read authority is required to call this API.
         * @summary Transform by ID
         * @param {string} id ID of the transform to retrieve
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getTransform(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transform>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransform(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a list of all saved transform objects. A token with transforms-list read authority is required to call this API.
         * @summary List transforms
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [name] Name of the transform to retrieve from the list.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: **internal**: *eq* **name**: *eq*, *sw*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getTransformsList(offset?: number, limit?: number, count?: boolean, name?: string, filters?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Transform>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransformsList(offset, limit, count, name, filters, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Replaces the transform specified by the given ID with the transform provided in the request body. Only the \"attributes\" field is mutable. Attempting to change other properties (ex. \"name\" and \"type\") will result in an error. A token with transform write authority is required to call this API.
         * @summary Update a transform
         * @param {string} id ID of the transform to update
         * @param {Transform} [transform] The updated transform object (must include \&quot;name\&quot;, \&quot;type\&quot;, and \&quot;attributes\&quot; fields).
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateTransform(id: string, transform?: Transform, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transform>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTransform(id, transform, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TransformsApi - factory interface
 * @export
 */
export const TransformsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransformsApiFp(configuration)
    return {
        /**
         * Creates a new transform object immediately. By default, the internal flag is set to false to indicate that this is a custom transform. Only SailPoint employees have the ability to create a transform with internal set to true. Newly created Transforms can be used in the Identity Profile mappings within the UI. A token with transform write authority is required to call this API.
         * @summary Create transform
         * @param {Transform} transform The transform to be created.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createTransform(transform: Transform, axiosOptions?: any): AxiosPromise<Transform> {
            return localVarFp.createTransform(transform, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the transform specified by the given ID. Attempting to delete a transform that is used in one or more Identity Profile mappings will result in an error. If this occurs, you must first remove the transform from all mappings before deleting the transform. A token with transform delete authority is required to call this API.
         * @summary Delete a transform
         * @param {string} id ID of the transform to delete
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransform(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteTransform(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API returns the transform specified by the given ID. A token with transform read authority is required to call this API.
         * @summary Transform by ID
         * @param {string} id ID of the transform to retrieve
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getTransform(id: string, axiosOptions?: any): AxiosPromise<Transform> {
            return localVarFp.getTransform(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Gets a list of all saved transform objects. A token with transforms-list read authority is required to call this API.
         * @summary List transforms
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [name] Name of the transform to retrieve from the list.
         * @param {string} [filters] Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: **internal**: *eq* **name**: *eq*, *sw*
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getTransformsList(offset?: number, limit?: number, count?: boolean, name?: string, filters?: string, axiosOptions?: any): AxiosPromise<Array<Transform>> {
            return localVarFp.getTransformsList(offset, limit, count, name, filters, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Replaces the transform specified by the given ID with the transform provided in the request body. Only the \"attributes\" field is mutable. Attempting to change other properties (ex. \"name\" and \"type\") will result in an error. A token with transform write authority is required to call this API.
         * @summary Update a transform
         * @param {string} id ID of the transform to update
         * @param {Transform} [transform] The updated transform object (must include \&quot;name\&quot;, \&quot;type\&quot;, and \&quot;attributes\&quot; fields).
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateTransform(id: string, transform?: Transform, axiosOptions?: any): AxiosPromise<Transform> {
            return localVarFp.updateTransform(id, transform, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createTransform operation in TransformsApi.
 * @export
 * @interface TransformsApiCreateTransformRequest
 */
export interface TransformsApiCreateTransformRequest {
    /**
     * The transform to be created.
     * @type {Transform}
     * @memberof TransformsApiCreateTransform
     */
    readonly transform: Transform
}

/**
 * Request parameters for deleteTransform operation in TransformsApi.
 * @export
 * @interface TransformsApiDeleteTransformRequest
 */
export interface TransformsApiDeleteTransformRequest {
    /**
     * ID of the transform to delete
     * @type {string}
     * @memberof TransformsApiDeleteTransform
     */
    readonly id: string
}

/**
 * Request parameters for getTransform operation in TransformsApi.
 * @export
 * @interface TransformsApiGetTransformRequest
 */
export interface TransformsApiGetTransformRequest {
    /**
     * ID of the transform to retrieve
     * @type {string}
     * @memberof TransformsApiGetTransform
     */
    readonly id: string
}

/**
 * Request parameters for getTransformsList operation in TransformsApi.
 * @export
 * @interface TransformsApiGetTransformsListRequest
 */
export interface TransformsApiGetTransformsListRequest {
    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof TransformsApiGetTransformsList
     */
    readonly offset?: number

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof TransformsApiGetTransformsList
     */
    readonly limit?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof TransformsApiGetTransformsList
     */
    readonly count?: boolean

    /**
     * Name of the transform to retrieve from the list.
     * @type {string}
     * @memberof TransformsApiGetTransformsList
     */
    readonly name?: string

    /**
     * Filter results using the standard syntax described in [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters#filtering-results) Filtering is supported for the following fields and operators: **internal**: *eq* **name**: *eq*, *sw*
     * @type {string}
     * @memberof TransformsApiGetTransformsList
     */
    readonly filters?: string
}

/**
 * Request parameters for updateTransform operation in TransformsApi.
 * @export
 * @interface TransformsApiUpdateTransformRequest
 */
export interface TransformsApiUpdateTransformRequest {
    /**
     * ID of the transform to update
     * @type {string}
     * @memberof TransformsApiUpdateTransform
     */
    readonly id: string

    /**
     * The updated transform object (must include \&quot;name\&quot;, \&quot;type\&quot;, and \&quot;attributes\&quot; fields).
     * @type {Transform}
     * @memberof TransformsApiUpdateTransform
     */
    readonly transform?: Transform
}

/**
 * TransformsApi - object-oriented interface
 * @export
 * @class TransformsApi
 * @extends {BaseAPI}
 */
export class TransformsApi extends BaseAPI {
    /**
     * Creates a new transform object immediately. By default, the internal flag is set to false to indicate that this is a custom transform. Only SailPoint employees have the ability to create a transform with internal set to true. Newly created Transforms can be used in the Identity Profile mappings within the UI. A token with transform write authority is required to call this API.
     * @summary Create transform
     * @param {TransformsApiCreateTransformRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TransformsApi
     */
    public createTransform(requestParameters: TransformsApiCreateTransformRequest, axiosOptions?: AxiosRequestConfig) {
        return TransformsApiFp(this.configuration).createTransform(requestParameters.transform, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the transform specified by the given ID. Attempting to delete a transform that is used in one or more Identity Profile mappings will result in an error. If this occurs, you must first remove the transform from all mappings before deleting the transform. A token with transform delete authority is required to call this API.
     * @summary Delete a transform
     * @param {TransformsApiDeleteTransformRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TransformsApi
     */
    public deleteTransform(requestParameters: TransformsApiDeleteTransformRequest, axiosOptions?: AxiosRequestConfig) {
        return TransformsApiFp(this.configuration).deleteTransform(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API returns the transform specified by the given ID. A token with transform read authority is required to call this API.
     * @summary Transform by ID
     * @param {TransformsApiGetTransformRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TransformsApi
     */
    public getTransform(requestParameters: TransformsApiGetTransformRequest, axiosOptions?: AxiosRequestConfig) {
        return TransformsApiFp(this.configuration).getTransform(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a list of all saved transform objects. A token with transforms-list read authority is required to call this API.
     * @summary List transforms
     * @param {TransformsApiGetTransformsListRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TransformsApi
     */
    public getTransformsList(requestParameters: TransformsApiGetTransformsListRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return TransformsApiFp(this.configuration).getTransformsList(requestParameters.offset, requestParameters.limit, requestParameters.count, requestParameters.name, requestParameters.filters, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replaces the transform specified by the given ID with the transform provided in the request body. Only the \"attributes\" field is mutable. Attempting to change other properties (ex. \"name\" and \"type\") will result in an error. A token with transform write authority is required to call this API.
     * @summary Update a transform
     * @param {TransformsApiUpdateTransformRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof TransformsApi
     */
    public updateTransform(requestParameters: TransformsApiUpdateTransformRequest, axiosOptions?: AxiosRequestConfig) {
        return TransformsApiFp(this.configuration).updateTransform(requestParameters.id, requestParameters.transform, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WorkItemsApi - axios parameter creator
 * @export
 */
export const WorkItemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API approves an Approval Item. Either an admin, or the owning/current user must make this request.
         * @summary Approve an Approval Item
         * @param {string} id The ID of the work item
         * @param {string} approvalItemId The ID of the approval item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approveApprovalItem: async (id: string, approvalItemId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('approveApprovalItem', 'id', id)
            // verify required parameter 'approvalItemId' is not null or undefined
            assertParamExists('approveApprovalItem', 'approvalItemId', approvalItemId)
            const localVarPath = `/work-items/{id}/approve/{approvalItemId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"approvalItemId"}}`, encodeURIComponent(String(approvalItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API bulk approves Approval Items. Either an admin, or the owning/current user must make this request.
         * @summary Bulk approve Approval Items
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        bulkApproveApprovalItem: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('bulkApproveApprovalItem', 'id', id)
            const localVarPath = `/work-items/bulk-approve/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API bulk rejects Approval Items. Either an admin, or the owning/current user must make this request.
         * @summary Bulk reject Approval Items
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        bulkRejectApprovalItem: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('bulkRejectApprovalItem', 'id', id)
            const localVarPath = `/work-items/bulk-reject/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API completes a work item. Either an admin, or the owning/current user must make this request.
         * @summary Complete a Work Item
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        completeWorkItem: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('completeWorkItem', 'id', id)
            const localVarPath = `/work-items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a collection of completed work items belonging to either the specified user(admin required), or the current user.
         * @summary Completed Work Items
         * @param {string} [ownerId] The id of the owner of the work item list being requested.  Either an admin, or the owning/current user must make this request.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        completedWorkItems: async (ownerId?: string, limit?: number, offset?: number, count?: boolean, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/work-items/completed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['ownerId'] = ownerId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a count of completed work items belonging to either the specified user(admin required), or the current user.
         * @summary Count Completed Work Items
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        countCompletedWorkItems: async (ownerId?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/work-items/completed/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['ownerId'] = ownerId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a count of work items belonging to either the specified user(admin required), or the current user.
         * @summary Count Work Items
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        countWorkItems: async (ownerId?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/work-items/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['ownerId'] = ownerId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets the details of a Work Item belonging to either the specified user(admin required), or the current user.
         * @summary Get a Work Item
         * @param {string} id ID of the work item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkItems: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWorkItems', 'id', id)
            const localVarPath = `/work-items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a collection of work items belonging to either the specified user(admin required), or the current user.
         * @summary List Work Items
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkItems: async (limit?: number, offset?: number, count?: boolean, ownerId?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/work-items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (ownerId !== undefined) {
                localVarQueryParameter['ownerId'] = ownerId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API rejects an Approval Item. Either an admin, or the owning/current user must make this request.
         * @summary Reject an Approval Item
         * @param {string} id The ID of the work item
         * @param {string} approvalItemId The ID of the approval item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        rejectApprovalItem: async (id: string, approvalItemId: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rejectApprovalItem', 'id', id)
            // verify required parameter 'approvalItemId' is not null or undefined
            assertParamExists('rejectApprovalItem', 'approvalItemId', approvalItemId)
            const localVarPath = `/work-items/{id}/reject/{approvalItemId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"approvalItemId"}}`, encodeURIComponent(String(approvalItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This API submits account selections. Either an admin, or the owning/current user must make this request.
         * @summary Submit Account Selections
         * @param {string} id The ID of the work item
         * @param {{ [key: string]: any; }} requestBody Account Selection Data map, keyed on fieldName
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        submitAccountSelection: async (id: string, requestBody: { [key: string]: any; }, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('submitAccountSelection', 'id', id)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('submitAccountSelection', 'requestBody', requestBody)
            const localVarPath = `/work-items/{id}/submit-account-selection`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This gets a summary of work items belonging to either the specified user(admin required), or the current user.
         * @summary Work Items Summary
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        summaryWorkItems: async (ownerId?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/work-items/summary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['ownerId'] = ownerId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkItemsApi - functional programming interface
 * @export
 */
export const WorkItemsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkItemsApiAxiosParamCreator(configuration)
    return {
        /**
         * This API approves an Approval Item. Either an admin, or the owning/current user must make this request.
         * @summary Approve an Approval Item
         * @param {string} id The ID of the work item
         * @param {string} approvalItemId The ID of the approval item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async approveApprovalItem(id: string, approvalItemId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveApprovalItem(id, approvalItemId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API bulk approves Approval Items. Either an admin, or the owning/current user must make this request.
         * @summary Bulk approve Approval Items
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async bulkApproveApprovalItem(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkApproveApprovalItem(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API bulk rejects Approval Items. Either an admin, or the owning/current user must make this request.
         * @summary Bulk reject Approval Items
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async bulkRejectApprovalItem(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkRejectApprovalItem(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API completes a work item. Either an admin, or the owning/current user must make this request.
         * @summary Complete a Work Item
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async completeWorkItem(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeWorkItem(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a collection of completed work items belonging to either the specified user(admin required), or the current user.
         * @summary Completed Work Items
         * @param {string} [ownerId] The id of the owner of the work item list being requested.  Either an admin, or the owning/current user must make this request.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async completedWorkItems(ownerId?: string, limit?: number, offset?: number, count?: boolean, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkItems>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completedWorkItems(ownerId, limit, offset, count, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a count of completed work items belonging to either the specified user(admin required), or the current user.
         * @summary Count Completed Work Items
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async countCompletedWorkItems(ownerId?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItemsCount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countCompletedWorkItems(ownerId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a count of work items belonging to either the specified user(admin required), or the current user.
         * @summary Count Work Items
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async countWorkItems(ownerId?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItemsCount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countWorkItems(ownerId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets the details of a Work Item belonging to either the specified user(admin required), or the current user.
         * @summary Get a Work Item
         * @param {string} id ID of the work item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkItems(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkItems(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a collection of work items belonging to either the specified user(admin required), or the current user.
         * @summary List Work Items
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkItems(limit?: number, offset?: number, count?: boolean, ownerId?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkItems>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkItems(limit, offset, count, ownerId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API rejects an Approval Item. Either an admin, or the owning/current user must make this request.
         * @summary Reject an Approval Item
         * @param {string} id The ID of the work item
         * @param {string} approvalItemId The ID of the approval item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async rejectApprovalItem(id: string, approvalItemId: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejectApprovalItem(id, approvalItemId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API submits account selections. Either an admin, or the owning/current user must make this request.
         * @summary Submit Account Selections
         * @param {string} id The ID of the work item
         * @param {{ [key: string]: any; }} requestBody Account Selection Data map, keyed on fieldName
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async submitAccountSelection(id: string, requestBody: { [key: string]: any; }, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitAccountSelection(id, requestBody, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This gets a summary of work items belonging to either the specified user(admin required), or the current user.
         * @summary Work Items Summary
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async summaryWorkItems(ownerId?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkItemsSummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.summaryWorkItems(ownerId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WorkItemsApi - factory interface
 * @export
 */
export const WorkItemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkItemsApiFp(configuration)
    return {
        /**
         * This API approves an Approval Item. Either an admin, or the owning/current user must make this request.
         * @summary Approve an Approval Item
         * @param {string} id The ID of the work item
         * @param {string} approvalItemId The ID of the approval item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        approveApprovalItem(id: string, approvalItemId: string, axiosOptions?: any): AxiosPromise<WorkItems> {
            return localVarFp.approveApprovalItem(id, approvalItemId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API bulk approves Approval Items. Either an admin, or the owning/current user must make this request.
         * @summary Bulk approve Approval Items
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        bulkApproveApprovalItem(id: string, axiosOptions?: any): AxiosPromise<WorkItems> {
            return localVarFp.bulkApproveApprovalItem(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API bulk rejects Approval Items. Either an admin, or the owning/current user must make this request.
         * @summary Bulk reject Approval Items
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        bulkRejectApprovalItem(id: string, axiosOptions?: any): AxiosPromise<WorkItems> {
            return localVarFp.bulkRejectApprovalItem(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API completes a work item. Either an admin, or the owning/current user must make this request.
         * @summary Complete a Work Item
         * @param {string} id The ID of the work item
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        completeWorkItem(id: string, axiosOptions?: any): AxiosPromise<WorkItems> {
            return localVarFp.completeWorkItem(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a collection of completed work items belonging to either the specified user(admin required), or the current user.
         * @summary Completed Work Items
         * @param {string} [ownerId] The id of the owner of the work item list being requested.  Either an admin, or the owning/current user must make this request.
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        completedWorkItems(ownerId?: string, limit?: number, offset?: number, count?: boolean, axiosOptions?: any): AxiosPromise<Array<WorkItems>> {
            return localVarFp.completedWorkItems(ownerId, limit, offset, count, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a count of completed work items belonging to either the specified user(admin required), or the current user.
         * @summary Count Completed Work Items
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        countCompletedWorkItems(ownerId?: string, axiosOptions?: any): AxiosPromise<WorkItemsCount> {
            return localVarFp.countCompletedWorkItems(ownerId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a count of work items belonging to either the specified user(admin required), or the current user.
         * @summary Count Work Items
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        countWorkItems(ownerId?: string, axiosOptions?: any): AxiosPromise<WorkItemsCount> {
            return localVarFp.countWorkItems(ownerId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets the details of a Work Item belonging to either the specified user(admin required), or the current user.
         * @summary Get a Work Item
         * @param {string} id ID of the work item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getWorkItems(id: string, axiosOptions?: any): AxiosPromise<WorkItems> {
            return localVarFp.getWorkItems(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a collection of work items belonging to either the specified user(admin required), or the current user.
         * @summary List Work Items
         * @param {number} [limit] Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {number} [offset] Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {boolean} [count] If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listWorkItems(limit?: number, offset?: number, count?: boolean, ownerId?: string, axiosOptions?: any): AxiosPromise<Array<WorkItems>> {
            return localVarFp.listWorkItems(limit, offset, count, ownerId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API rejects an Approval Item. Either an admin, or the owning/current user must make this request.
         * @summary Reject an Approval Item
         * @param {string} id The ID of the work item
         * @param {string} approvalItemId The ID of the approval item.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        rejectApprovalItem(id: string, approvalItemId: string, axiosOptions?: any): AxiosPromise<WorkItems> {
            return localVarFp.rejectApprovalItem(id, approvalItemId, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This API submits account selections. Either an admin, or the owning/current user must make this request.
         * @summary Submit Account Selections
         * @param {string} id The ID of the work item
         * @param {{ [key: string]: any; }} requestBody Account Selection Data map, keyed on fieldName
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        submitAccountSelection(id: string, requestBody: { [key: string]: any; }, axiosOptions?: any): AxiosPromise<WorkItems> {
            return localVarFp.submitAccountSelection(id, requestBody, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This gets a summary of work items belonging to either the specified user(admin required), or the current user.
         * @summary Work Items Summary
         * @param {string} [ownerId] ID of the work item owner.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        summaryWorkItems(ownerId?: string, axiosOptions?: any): AxiosPromise<WorkItemsSummary> {
            return localVarFp.summaryWorkItems(ownerId, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for approveApprovalItem operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiApproveApprovalItemRequest
 */
export interface WorkItemsApiApproveApprovalItemRequest {
    /**
     * The ID of the work item
     * @type {string}
     * @memberof WorkItemsApiApproveApprovalItem
     */
    readonly id: string

    /**
     * The ID of the approval item.
     * @type {string}
     * @memberof WorkItemsApiApproveApprovalItem
     */
    readonly approvalItemId: string
}

/**
 * Request parameters for bulkApproveApprovalItem operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiBulkApproveApprovalItemRequest
 */
export interface WorkItemsApiBulkApproveApprovalItemRequest {
    /**
     * The ID of the work item
     * @type {string}
     * @memberof WorkItemsApiBulkApproveApprovalItem
     */
    readonly id: string
}

/**
 * Request parameters for bulkRejectApprovalItem operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiBulkRejectApprovalItemRequest
 */
export interface WorkItemsApiBulkRejectApprovalItemRequest {
    /**
     * The ID of the work item
     * @type {string}
     * @memberof WorkItemsApiBulkRejectApprovalItem
     */
    readonly id: string
}

/**
 * Request parameters for completeWorkItem operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiCompleteWorkItemRequest
 */
export interface WorkItemsApiCompleteWorkItemRequest {
    /**
     * The ID of the work item
     * @type {string}
     * @memberof WorkItemsApiCompleteWorkItem
     */
    readonly id: string
}

/**
 * Request parameters for completedWorkItems operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiCompletedWorkItemsRequest
 */
export interface WorkItemsApiCompletedWorkItemsRequest {
    /**
     * The id of the owner of the work item list being requested.  Either an admin, or the owning/current user must make this request.
     * @type {string}
     * @memberof WorkItemsApiCompletedWorkItems
     */
    readonly ownerId?: string

    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof WorkItemsApiCompletedWorkItems
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof WorkItemsApiCompletedWorkItems
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof WorkItemsApiCompletedWorkItems
     */
    readonly count?: boolean
}

/**
 * Request parameters for countCompletedWorkItems operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiCountCompletedWorkItemsRequest
 */
export interface WorkItemsApiCountCompletedWorkItemsRequest {
    /**
     * ID of the work item owner.
     * @type {string}
     * @memberof WorkItemsApiCountCompletedWorkItems
     */
    readonly ownerId?: string
}

/**
 * Request parameters for countWorkItems operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiCountWorkItemsRequest
 */
export interface WorkItemsApiCountWorkItemsRequest {
    /**
     * ID of the work item owner.
     * @type {string}
     * @memberof WorkItemsApiCountWorkItems
     */
    readonly ownerId?: string
}

/**
 * Request parameters for getWorkItems operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiGetWorkItemsRequest
 */
export interface WorkItemsApiGetWorkItemsRequest {
    /**
     * ID of the work item.
     * @type {string}
     * @memberof WorkItemsApiGetWorkItems
     */
    readonly id: string
}

/**
 * Request parameters for listWorkItems operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiListWorkItemsRequest
 */
export interface WorkItemsApiListWorkItemsRequest {
    /**
     * Max number of results to return. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof WorkItemsApiListWorkItems
     */
    readonly limit?: number

    /**
     * Offset into the full result set. Usually specified with *limit* to paginate through the results. See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {number}
     * @memberof WorkItemsApiListWorkItems
     */
    readonly offset?: number

    /**
     * If *true* it will populate the *X-Total-Count* response header with the number of results that would be returned if *limit* and *offset* were ignored.  Since requesting a total count can have a performance impact, it is recommended not to send **count&#x3D;true** if that value will not be used.  See [V3 API Standard Collection Parameters](https://developer.sailpoint.com/idn/api/standard-collection-parameters) for more information.
     * @type {boolean}
     * @memberof WorkItemsApiListWorkItems
     */
    readonly count?: boolean

    /**
     * ID of the work item owner.
     * @type {string}
     * @memberof WorkItemsApiListWorkItems
     */
    readonly ownerId?: string
}

/**
 * Request parameters for rejectApprovalItem operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiRejectApprovalItemRequest
 */
export interface WorkItemsApiRejectApprovalItemRequest {
    /**
     * The ID of the work item
     * @type {string}
     * @memberof WorkItemsApiRejectApprovalItem
     */
    readonly id: string

    /**
     * The ID of the approval item.
     * @type {string}
     * @memberof WorkItemsApiRejectApprovalItem
     */
    readonly approvalItemId: string
}

/**
 * Request parameters for submitAccountSelection operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiSubmitAccountSelectionRequest
 */
export interface WorkItemsApiSubmitAccountSelectionRequest {
    /**
     * The ID of the work item
     * @type {string}
     * @memberof WorkItemsApiSubmitAccountSelection
     */
    readonly id: string

    /**
     * Account Selection Data map, keyed on fieldName
     * @type {{ [key: string]: any; }}
     * @memberof WorkItemsApiSubmitAccountSelection
     */
    readonly requestBody: { [key: string]: any; }
}

/**
 * Request parameters for summaryWorkItems operation in WorkItemsApi.
 * @export
 * @interface WorkItemsApiSummaryWorkItemsRequest
 */
export interface WorkItemsApiSummaryWorkItemsRequest {
    /**
     * ID of the work item owner.
     * @type {string}
     * @memberof WorkItemsApiSummaryWorkItems
     */
    readonly ownerId?: string
}

/**
 * WorkItemsApi - object-oriented interface
 * @export
 * @class WorkItemsApi
 * @extends {BaseAPI}
 */
export class WorkItemsApi extends BaseAPI {
    /**
     * This API approves an Approval Item. Either an admin, or the owning/current user must make this request.
     * @summary Approve an Approval Item
     * @param {WorkItemsApiApproveApprovalItemRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public approveApprovalItem(requestParameters: WorkItemsApiApproveApprovalItemRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).approveApprovalItem(requestParameters.id, requestParameters.approvalItemId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API bulk approves Approval Items. Either an admin, or the owning/current user must make this request.
     * @summary Bulk approve Approval Items
     * @param {WorkItemsApiBulkApproveApprovalItemRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public bulkApproveApprovalItem(requestParameters: WorkItemsApiBulkApproveApprovalItemRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).bulkApproveApprovalItem(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API bulk rejects Approval Items. Either an admin, or the owning/current user must make this request.
     * @summary Bulk reject Approval Items
     * @param {WorkItemsApiBulkRejectApprovalItemRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public bulkRejectApprovalItem(requestParameters: WorkItemsApiBulkRejectApprovalItemRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).bulkRejectApprovalItem(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API completes a work item. Either an admin, or the owning/current user must make this request.
     * @summary Complete a Work Item
     * @param {WorkItemsApiCompleteWorkItemRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public completeWorkItem(requestParameters: WorkItemsApiCompleteWorkItemRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).completeWorkItem(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a collection of completed work items belonging to either the specified user(admin required), or the current user.
     * @summary Completed Work Items
     * @param {WorkItemsApiCompletedWorkItemsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public completedWorkItems(requestParameters: WorkItemsApiCompletedWorkItemsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).completedWorkItems(requestParameters.ownerId, requestParameters.limit, requestParameters.offset, requestParameters.count, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a count of completed work items belonging to either the specified user(admin required), or the current user.
     * @summary Count Completed Work Items
     * @param {WorkItemsApiCountCompletedWorkItemsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public countCompletedWorkItems(requestParameters: WorkItemsApiCountCompletedWorkItemsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).countCompletedWorkItems(requestParameters.ownerId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a count of work items belonging to either the specified user(admin required), or the current user.
     * @summary Count Work Items
     * @param {WorkItemsApiCountWorkItemsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public countWorkItems(requestParameters: WorkItemsApiCountWorkItemsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).countWorkItems(requestParameters.ownerId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets the details of a Work Item belonging to either the specified user(admin required), or the current user.
     * @summary Get a Work Item
     * @param {WorkItemsApiGetWorkItemsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public getWorkItems(requestParameters: WorkItemsApiGetWorkItemsRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).getWorkItems(requestParameters.id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a collection of work items belonging to either the specified user(admin required), or the current user.
     * @summary List Work Items
     * @param {WorkItemsApiListWorkItemsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public listWorkItems(requestParameters: WorkItemsApiListWorkItemsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).listWorkItems(requestParameters.limit, requestParameters.offset, requestParameters.count, requestParameters.ownerId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API rejects an Approval Item. Either an admin, or the owning/current user must make this request.
     * @summary Reject an Approval Item
     * @param {WorkItemsApiRejectApprovalItemRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public rejectApprovalItem(requestParameters: WorkItemsApiRejectApprovalItemRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).rejectApprovalItem(requestParameters.id, requestParameters.approvalItemId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API submits account selections. Either an admin, or the owning/current user must make this request.
     * @summary Submit Account Selections
     * @param {WorkItemsApiSubmitAccountSelectionRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public submitAccountSelection(requestParameters: WorkItemsApiSubmitAccountSelectionRequest, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).submitAccountSelection(requestParameters.id, requestParameters.requestBody, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This gets a summary of work items belonging to either the specified user(admin required), or the current user.
     * @summary Work Items Summary
     * @param {WorkItemsApiSummaryWorkItemsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkItemsApi
     */
    public summaryWorkItems(requestParameters: WorkItemsApiSummaryWorkItemsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return WorkItemsApiFp(this.configuration).summaryWorkItems(requestParameters.ownerId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


