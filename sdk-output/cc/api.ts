/* tslint:disable */
/* eslint-disable */
/**
 * IdentityNow cc (private) APIs
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from '../configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface CreateApplicationRequestCC
 */
export interface CreateApplicationRequestCC {
    /**
     * 
     * @type {string}
     * @memberof CreateApplicationRequestCC
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateApplicationRequestCC
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface CreateConnectorRequestCC
 */
export interface CreateConnectorRequestCC {
    /**
     * 
     * @type {string}
     * @memberof CreateConnectorRequestCC
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateConnectorRequestCC
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateConnectorRequestCC
     */
    'className'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateConnectorRequestCC
     */
    'directConnect'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateConnectorRequestCC
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface ImportConnectorConfigRequestCC
 */
export interface ImportConnectorConfigRequestCC {
    /**
     * This is the connector config zip bundle which gets uploaded.
     * @type {any}
     * @memberof ImportConnectorConfigRequestCC
     */
    'file'?: any;
}
/**
 * 
 * @export
 * @interface LoadAccountsRequestCC
 */
export interface LoadAccountsRequestCC {
    /**
     * 
     * @type {boolean}
     * @memberof LoadAccountsRequestCC
     */
    'disableOptimization'?: boolean;
    /**
     * 
     * @type {any}
     * @memberof LoadAccountsRequestCC
     */
    'file'?: any;
}
/**
 * 
 * @export
 * @interface UpdateApplicationRequestCC
 */
export interface UpdateApplicationRequestCC {
    /**
     * 
     * @type {string}
     * @memberof UpdateApplicationRequestCC
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface UpdateUserPermissionsRequestCC
 */
export interface UpdateUserPermissionsRequestCC {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserPermissionsRequestCC
     */
    'ids'?: string;
    /**
     * Indicates if user should be an IDN Admin.  \"0\" for false, \"1\" for true.
     * @type {string}
     * @memberof UpdateUserPermissionsRequestCC
     */
    'isAdmin'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserPermissionsRequestCC
     */
    'adminType'?: UpdateUserPermissionsRequestCCAdminTypeEnum;
}

export const UpdateUserPermissionsRequestCCAdminTypeEnum = {
    Admin: 'ADMIN',
    CertAdmin: 'CERT_ADMIN',
    Helpdesk: 'HELPDESK',
    ReportAdmin: 'REPORT_ADMIN',
    RoleAdmin: 'ROLE_ADMIN',
    RoleSubadmin: 'ROLE_SUBADMIN',
    SourceAdmin: 'SOURCE_ADMIN',
    SourceSubadmin: 'SOURCE_SUBADMIN'
} as const;

export type UpdateUserPermissionsRequestCCAdminTypeEnum = typeof UpdateUserPermissionsRequestCCAdminTypeEnum[keyof typeof UpdateUserPermissionsRequestCCAdminTypeEnum];


/**
 * AccountsCCApi - axios parameter creator
 * @export
 */
export const AccountsCCApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List Accounts
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccounts: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cc/api/account/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove Account
         * @param {string} [id] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        removeAccount: async (id?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cc/api/account/remove/:id`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsCCApi - functional programming interface
 * @export
 */
export const AccountsCCApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsCCApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List Accounts
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listAccounts(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccounts(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove Account
         * @param {string} [id] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async removeAccount(id?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAccount(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountsCCApi - factory interface
 * @export
 */
export const AccountsCCApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsCCApiFp(configuration)
    return {
        /**
         * 
         * @summary List Accounts
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listAccounts(axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.listAccounts(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove Account
         * @param {string} [id] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        removeAccount(id?: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.removeAccount(id, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountsCCApi - object-oriented interface
 * @export
 * @class AccountsCCApi
 * @extends {BaseAPI}
 */
export class AccountsCCApi extends BaseAPI {
    /**
     * 
     * @summary List Accounts
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsCCApi
     */
    public listAccounts(axiosOptions?: AxiosRequestConfig) {
        return AccountsCCApiFp(this.configuration).listAccounts(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove Account
     * @param {string} [id] 
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsCCApi
     */
    public removeAccount(id?: string, axiosOptions?: AxiosRequestConfig) {
        return AccountsCCApiFp(this.configuration).removeAccount(id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApplicationsCCApi - axios parameter creator
 * @export
 */
export const ApplicationsCCApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Application
         * @param {CreateApplicationRequestCC} [createApplicationRequestCC] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createApplication: async (createApplicationRequestCC?: CreateApplicationRequestCC, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cc/api/app/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createApplicationRequestCC, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Application
         * @param {string} [id] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplication: async (id?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cc/api/app/delete/:id`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Single Application
         * @param {string} [id] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getApplication: async (id?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cc/api/app/get/:id`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Access Profiles for Application
         * @param {string} [id] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationAccessProfiles: async (id?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cc/api/app/getAccessProfiles/:id`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Applications
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listApplications: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cc/api/app`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Application
         * @param {string} [id] 
         * @param {UpdateApplicationRequestCC} [updateApplicationRequestCC] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateApplication: async (id?: string, updateApplicationRequestCC?: UpdateApplicationRequestCC, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cc/api/app/update/:id`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateApplicationRequestCC, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationsCCApi - functional programming interface
 * @export
 */
export const ApplicationsCCApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationsCCApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Application
         * @param {CreateApplicationRequestCC} [createApplicationRequestCC] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createApplication(createApplicationRequestCC?: CreateApplicationRequestCC, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplication(createApplicationRequestCC, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Application
         * @param {string} [id] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApplication(id?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplication(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Single Application
         * @param {string} [id] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getApplication(id?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplication(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Access Profiles for Application
         * @param {string} [id] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationAccessProfiles(id?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationAccessProfiles(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Applications
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listApplications(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplications(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update Application
         * @param {string} [id] 
         * @param {UpdateApplicationRequestCC} [updateApplicationRequestCC] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateApplication(id?: string, updateApplicationRequestCC?: UpdateApplicationRequestCC, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateApplication(id, updateApplicationRequestCC, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApplicationsCCApi - factory interface
 * @export
 */
export const ApplicationsCCApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationsCCApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Application
         * @param {CreateApplicationRequestCC} [createApplicationRequestCC] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createApplication(createApplicationRequestCC?: CreateApplicationRequestCC, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.createApplication(createApplicationRequestCC, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Application
         * @param {string} [id] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplication(id?: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteApplication(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Single Application
         * @param {string} [id] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getApplication(id?: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.getApplication(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Access Profiles for Application
         * @param {string} [id] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationAccessProfiles(id?: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.getApplicationAccessProfiles(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Applications
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listApplications(axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.listApplications(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Application
         * @param {string} [id] 
         * @param {UpdateApplicationRequestCC} [updateApplicationRequestCC] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateApplication(id?: string, updateApplicationRequestCC?: UpdateApplicationRequestCC, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.updateApplication(id, updateApplicationRequestCC, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationsCCApi - object-oriented interface
 * @export
 * @class ApplicationsCCApi
 * @extends {BaseAPI}
 */
export class ApplicationsCCApi extends BaseAPI {
    /**
     * 
     * @summary Create Application
     * @param {CreateApplicationRequestCC} [createApplicationRequestCC] 
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsCCApi
     */
    public createApplication(createApplicationRequestCC?: CreateApplicationRequestCC, axiosOptions?: AxiosRequestConfig) {
        return ApplicationsCCApiFp(this.configuration).createApplication(createApplicationRequestCC, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Application
     * @param {string} [id] 
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsCCApi
     */
    public deleteApplication(id?: string, axiosOptions?: AxiosRequestConfig) {
        return ApplicationsCCApiFp(this.configuration).deleteApplication(id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Single Application
     * @param {string} [id] 
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsCCApi
     */
    public getApplication(id?: string, axiosOptions?: AxiosRequestConfig) {
        return ApplicationsCCApiFp(this.configuration).getApplication(id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Access Profiles for Application
     * @param {string} [id] 
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsCCApi
     */
    public getApplicationAccessProfiles(id?: string, axiosOptions?: AxiosRequestConfig) {
        return ApplicationsCCApiFp(this.configuration).getApplicationAccessProfiles(id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Applications
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsCCApi
     */
    public listApplications(axiosOptions?: AxiosRequestConfig) {
        return ApplicationsCCApiFp(this.configuration).listApplications(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Application
     * @param {string} [id] 
     * @param {UpdateApplicationRequestCC} [updateApplicationRequestCC] 
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsCCApi
     */
    public updateApplication(id?: string, updateApplicationRequestCC?: UpdateApplicationRequestCC, axiosOptions?: AxiosRequestConfig) {
        return ApplicationsCCApiFp(this.configuration).updateApplication(id, updateApplicationRequestCC, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ConnectorsCCApi - axios parameter creator
 * @export
 */
export const ConnectorsCCApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Connector
         * @param {string} [contentType] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [className] 
         * @param {boolean} [directConnect] 
         * @param {string} [status] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createConnector: async (contentType?: string, name?: string, description?: string, className?: string, directConnect?: boolean, status?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cc/api/connector/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


            if (name !== undefined) { 
                localVarFormParams.set('name', name as any);
            }
    
            if (description !== undefined) { 
                localVarFormParams.set('description', description as any);
            }
    
            if (className !== undefined) { 
                localVarFormParams.set('className', className as any);
            }
    
            if (directConnect !== undefined) { 
                localVarFormParams.set('directConnect', directConnect as any);
            }
    
            if (status !== undefined) { 
                localVarFormParams.set('status', status as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Connector
         * @param {string} id 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnector: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteConnector', 'id', id)
            const localVarPath = `/cc/api/connector/delete/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Export Connector Config
         * @param {string} id 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportConnectorConfig: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('exportConnectorConfig', 'id', id)
            const localVarPath = `/cc/api/connector/export/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Import Connector Config
         * @param {string} id 
         * @param {any} [file] This is the connector config zip bundle which gets uploaded.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importConnectorConfig: async (id: string, file?: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('importConnectorConfig', 'id', id)
            const localVarPath = `/cc/api/connector/import/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Connectors
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listConnectors: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cc/api/connector/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConnectorsCCApi - functional programming interface
 * @export
 */
export const ConnectorsCCApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConnectorsCCApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Connector
         * @param {string} [contentType] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [className] 
         * @param {boolean} [directConnect] 
         * @param {string} [status] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createConnector(contentType?: string, name?: string, description?: string, className?: string, directConnect?: boolean, status?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createConnector(contentType, name, description, className, directConnect, status, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Connector
         * @param {string} id 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deleteConnector(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteConnector(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Export Connector Config
         * @param {string} id 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async exportConnectorConfig(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportConnectorConfig(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Import Connector Config
         * @param {string} id 
         * @param {any} [file] This is the connector config zip bundle which gets uploaded.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async importConnectorConfig(id: string, file?: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importConnectorConfig(id, file, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Connectors
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async listConnectors(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listConnectors(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ConnectorsCCApi - factory interface
 * @export
 */
export const ConnectorsCCApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConnectorsCCApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Connector
         * @param {string} [contentType] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [className] 
         * @param {boolean} [directConnect] 
         * @param {string} [status] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createConnector(contentType?: string, name?: string, description?: string, className?: string, directConnect?: boolean, status?: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.createConnector(contentType, name, description, className, directConnect, status, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Connector
         * @param {string} id 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnector(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deleteConnector(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Export Connector Config
         * @param {string} id 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportConnectorConfig(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.exportConnectorConfig(id, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Import Connector Config
         * @param {string} id 
         * @param {any} [file] This is the connector config zip bundle which gets uploaded.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        importConnectorConfig(id: string, file?: any, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.importConnectorConfig(id, file, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Connectors
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        listConnectors(axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.listConnectors(axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConnectorsCCApi - object-oriented interface
 * @export
 * @class ConnectorsCCApi
 * @extends {BaseAPI}
 */
export class ConnectorsCCApi extends BaseAPI {
    /**
     * 
     * @summary Create Connector
     * @param {string} [contentType] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [className] 
     * @param {boolean} [directConnect] 
     * @param {string} [status] 
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsCCApi
     */
    public createConnector(contentType?: string, name?: string, description?: string, className?: string, directConnect?: boolean, status?: string, axiosOptions?: AxiosRequestConfig) {
        return ConnectorsCCApiFp(this.configuration).createConnector(contentType, name, description, className, directConnect, status, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Connector
     * @param {string} id 
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsCCApi
     */
    public deleteConnector(id: string, axiosOptions?: AxiosRequestConfig) {
        return ConnectorsCCApiFp(this.configuration).deleteConnector(id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Export Connector Config
     * @param {string} id 
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsCCApi
     */
    public exportConnectorConfig(id: string, axiosOptions?: AxiosRequestConfig) {
        return ConnectorsCCApiFp(this.configuration).exportConnectorConfig(id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Import Connector Config
     * @param {string} id 
     * @param {any} [file] This is the connector config zip bundle which gets uploaded.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsCCApi
     */
    public importConnectorConfig(id: string, file?: any, axiosOptions?: AxiosRequestConfig) {
        return ConnectorsCCApiFp(this.configuration).importConnectorConfig(id, file, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Connectors
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsCCApi
     */
    public listConnectors(axiosOptions?: AxiosRequestConfig) {
        return ConnectorsCCApiFp(this.configuration).listConnectors(axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SourcesAccountsCCApi - axios parameter creator
 * @export
 */
export const SourcesAccountsCCApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Exports a CSV of the accounts for a particular source.
         * @summary Export Account Feed
         * @param {string} id 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportAccountFeed: async (id: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('exportAccountFeed', 'id', id)
            const localVarPath = `/cc/api/source/exportAccountFeed/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * SourcesAccountsCCApi - functional programming interface
 * @export
 */
export const SourcesAccountsCCApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SourcesAccountsCCApiAxiosParamCreator(configuration)
    return {
        /**
         * Exports a CSV of the accounts for a particular source.
         * @summary Export Account Feed
         * @param {string} id 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async exportAccountFeed(id: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportAccountFeed(id, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SourcesAccountsCCApi - factory interface
 * @export
 */
export const SourcesAccountsCCApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SourcesAccountsCCApiFp(configuration)
    return {
        /**
         * Exports a CSV of the accounts for a particular source.
         * @summary Export Account Feed
         * @param {string} id 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        exportAccountFeed(id: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.exportAccountFeed(id, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SourcesAccountsCCApi - object-oriented interface
 * @export
 * @class SourcesAccountsCCApi
 * @extends {BaseAPI}
 */
export class SourcesAccountsCCApi extends BaseAPI {
    /**
     * Exports a CSV of the accounts for a particular source.
     * @summary Export Account Feed
     * @param {string} id 
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesAccountsCCApi
     */
    public exportAccountFeed(id: string, axiosOptions?: AxiosRequestConfig) {
        return SourcesAccountsCCApiFp(this.configuration).exportAccountFeed(id, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SourcesAggregationCCApi - axios parameter creator
 * @export
 */
export const SourcesAggregationCCApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Aggregates a delimited file for the given source.  This only works for file-based sources.
         * @summary Account Aggregation (File)
         * @param {string} id 
         * @param {string} [contentType] 
         * @param {boolean} [disableOptimization] 
         * @param {any} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        loadAccounts: async (id: string, contentType?: string, disableOptimization?: boolean, file?: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('loadAccounts', 'id', id)
            const localVarPath = `/cc/api/source/loadAccounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


            if (disableOptimization !== undefined) { 
                localVarFormParams.append('disableOptimization', disableOptimization as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * SourcesAggregationCCApi - functional programming interface
 * @export
 */
export const SourcesAggregationCCApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SourcesAggregationCCApiAxiosParamCreator(configuration)
    return {
        /**
         * Aggregates a delimited file for the given source.  This only works for file-based sources.
         * @summary Account Aggregation (File)
         * @param {string} id 
         * @param {string} [contentType] 
         * @param {boolean} [disableOptimization] 
         * @param {any} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async loadAccounts(id: string, contentType?: string, disableOptimization?: boolean, file?: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loadAccounts(id, contentType, disableOptimization, file, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SourcesAggregationCCApi - factory interface
 * @export
 */
export const SourcesAggregationCCApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SourcesAggregationCCApiFp(configuration)
    return {
        /**
         * Aggregates a delimited file for the given source.  This only works for file-based sources.
         * @summary Account Aggregation (File)
         * @param {string} id 
         * @param {string} [contentType] 
         * @param {boolean} [disableOptimization] 
         * @param {any} [file] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        loadAccounts(id: string, contentType?: string, disableOptimization?: boolean, file?: any, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.loadAccounts(id, contentType, disableOptimization, file, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SourcesAggregationCCApi - object-oriented interface
 * @export
 * @class SourcesAggregationCCApi
 * @extends {BaseAPI}
 */
export class SourcesAggregationCCApi extends BaseAPI {
    /**
     * Aggregates a delimited file for the given source.  This only works for file-based sources.
     * @summary Account Aggregation (File)
     * @param {string} id 
     * @param {string} [contentType] 
     * @param {boolean} [disableOptimization] 
     * @param {any} [file] 
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesAggregationCCApi
     */
    public loadAccounts(id: string, contentType?: string, disableOptimization?: boolean, file?: any, axiosOptions?: AxiosRequestConfig) {
        return SourcesAggregationCCApiFp(this.configuration).loadAccounts(id, contentType, disableOptimization, file, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SystemCCApi - axios parameter creator
 * @export
 */
export const SystemCCApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This kicks off an identity refresh for a specified set of identity attributes.  This can be a long running process.  IdentityNow has pre-scheduled versions of this task at set intervals and events already, so only run this when directed by SailPoint.  _Note: If the identities specified by the filter do not exist, a full identity refresh will be run.  Use with caution._  Refresh Arguments:  | Key                   | Description                                        | |-----------------------|----------------------------------------------------| | correlateEntitlements | Analyzes entitlements, access profiles, and roles. | | promoteAttributes     | Calculates identity attributes.                    | | refreshManagerStatus  | Calculates manager correlation and manager status. | | synchronizeAttributes | Performs attribute sync provisioning.              | | pruneIdentities       | Removes any identities which don\'t have accounts.  | | provision             | Provisions any assigned roles or access profiles.  |
         * @summary Refresh Identities
         * @param {string} [contentType] 
         * @param {string} [body] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        refreshIdentities: async (contentType?: string, body?: string, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cc/api/system/refreshIdentities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemCCApi - functional programming interface
 * @export
 */
export const SystemCCApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemCCApiAxiosParamCreator(configuration)
    return {
        /**
         * This kicks off an identity refresh for a specified set of identity attributes.  This can be a long running process.  IdentityNow has pre-scheduled versions of this task at set intervals and events already, so only run this when directed by SailPoint.  _Note: If the identities specified by the filter do not exist, a full identity refresh will be run.  Use with caution._  Refresh Arguments:  | Key                   | Description                                        | |-----------------------|----------------------------------------------------| | correlateEntitlements | Analyzes entitlements, access profiles, and roles. | | promoteAttributes     | Calculates identity attributes.                    | | refreshManagerStatus  | Calculates manager correlation and manager status. | | synchronizeAttributes | Performs attribute sync provisioning.              | | pruneIdentities       | Removes any identities which don\'t have accounts.  | | provision             | Provisions any assigned roles or access profiles.  |
         * @summary Refresh Identities
         * @param {string} [contentType] 
         * @param {string} [body] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async refreshIdentities(contentType?: string, body?: string, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshIdentities(contentType, body, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SystemCCApi - factory interface
 * @export
 */
export const SystemCCApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SystemCCApiFp(configuration)
    return {
        /**
         * This kicks off an identity refresh for a specified set of identity attributes.  This can be a long running process.  IdentityNow has pre-scheduled versions of this task at set intervals and events already, so only run this when directed by SailPoint.  _Note: If the identities specified by the filter do not exist, a full identity refresh will be run.  Use with caution._  Refresh Arguments:  | Key                   | Description                                        | |-----------------------|----------------------------------------------------| | correlateEntitlements | Analyzes entitlements, access profiles, and roles. | | promoteAttributes     | Calculates identity attributes.                    | | refreshManagerStatus  | Calculates manager correlation and manager status. | | synchronizeAttributes | Performs attribute sync provisioning.              | | pruneIdentities       | Removes any identities which don\'t have accounts.  | | provision             | Provisions any assigned roles or access profiles.  |
         * @summary Refresh Identities
         * @param {string} [contentType] 
         * @param {string} [body] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        refreshIdentities(contentType?: string, body?: string, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.refreshIdentities(contentType, body, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SystemCCApi - object-oriented interface
 * @export
 * @class SystemCCApi
 * @extends {BaseAPI}
 */
export class SystemCCApi extends BaseAPI {
    /**
     * This kicks off an identity refresh for a specified set of identity attributes.  This can be a long running process.  IdentityNow has pre-scheduled versions of this task at set intervals and events already, so only run this when directed by SailPoint.  _Note: If the identities specified by the filter do not exist, a full identity refresh will be run.  Use with caution._  Refresh Arguments:  | Key                   | Description                                        | |-----------------------|----------------------------------------------------| | correlateEntitlements | Analyzes entitlements, access profiles, and roles. | | promoteAttributes     | Calculates identity attributes.                    | | refreshManagerStatus  | Calculates manager correlation and manager status. | | synchronizeAttributes | Performs attribute sync provisioning.              | | pruneIdentities       | Removes any identities which don\'t have accounts.  | | provision             | Provisions any assigned roles or access profiles.  |
     * @summary Refresh Identities
     * @param {string} [contentType] 
     * @param {string} [body] 
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemCCApi
     */
    public refreshIdentities(contentType?: string, body?: string, axiosOptions?: AxiosRequestConfig) {
        return SystemCCApiFp(this.configuration).refreshIdentities(contentType, body, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserCCApi - axios parameter creator
 * @export
 */
export const UserCCApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Update User Permissions
         * @param {UpdateUserPermissionsRequestCC} [updateUserPermissionsRequestCC] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPermissions: async (updateUserPermissionsRequestCC?: UpdateUserPermissionsRequestCC, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cc/api/user/updatePermissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserPermissionsRequestCC, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserCCApi - functional programming interface
 * @export
 */
export const UserCCApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserCCApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Update User Permissions
         * @param {UpdateUserPermissionsRequestCC} [updateUserPermissionsRequestCC] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserPermissions(updateUserPermissionsRequestCC?: UpdateUserPermissionsRequestCC, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserPermissions(updateUserPermissionsRequestCC, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserCCApi - factory interface
 * @export
 */
export const UserCCApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserCCApiFp(configuration)
    return {
        /**
         * 
         * @summary Update User Permissions
         * @param {UpdateUserPermissionsRequestCC} [updateUserPermissionsRequestCC] 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPermissions(updateUserPermissionsRequestCC?: UpdateUserPermissionsRequestCC, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.updateUserPermissions(updateUserPermissionsRequestCC, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserCCApi - object-oriented interface
 * @export
 * @class UserCCApi
 * @extends {BaseAPI}
 */
export class UserCCApi extends BaseAPI {
    /**
     * 
     * @summary Update User Permissions
     * @param {UpdateUserPermissionsRequestCC} [updateUserPermissionsRequestCC] 
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof UserCCApi
     */
    public updateUserPermissions(updateUserPermissionsRequestCC?: UpdateUserPermissionsRequestCC, axiosOptions?: AxiosRequestConfig) {
        return UserCCApiFp(this.configuration).updateUserPermissions(updateUserPermissionsRequestCC, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


